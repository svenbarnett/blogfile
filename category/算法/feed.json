{
    "version": "https://jsonfeed.org/version/1",
    "title": "人间日常 • All posts by \"算法\" category",
    "description": "所行皆过往，所愿皆成真",
    "home_page_url": "https://www.pswen.cn",
    "items": [
        {
            "id": "https://www.pswen.cn/p/52a5c0f5/index.html",
            "url": "https://www.pswen.cn/p/52a5c0f5/index.html",
            "title": "被围绕的区域——LeetCode130",
            "date_published": "2022-02-08T11:56:55.000Z",
            "content_html": "<html><head></head><body><p>给你一个  <code>m x n</code>  的矩阵  <code>board</code>  ，由若干字符  <code>'X'</code>  和  <code>'O'</code>  ，找到所有被  <code>'X'</code>  围绕的区域，并将这些区域里所有的  <code>'O'</code>  用  <code>'X'</code>  填充。</p>\n<p><img src=\"/p/52a5c0f5/xogrid.jpg\" alt=\"img\"></p>\n<span id=\"more\"></span>\n<p>示例 1</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：board = [[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"O\",\"X\"],[\"X\",\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]]</span><br><span class=\"line\">输出：[[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]]</span><br><span class=\"line\">解释：被围绕的区间不会存在于边界上，换句话说，任何边界上的&nbsp;'O'&nbsp;都不会被填充为&nbsp;'X'。 任何不在边界上，或不与边界上的&nbsp;'O'&nbsp;相连的&nbsp;'O'&nbsp;最终都会被填充为&nbsp;'X'。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。</span><br></pre></td></tr></tbody></table></figure></div>\n<p>示例 2</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：board = [[\"X\"]]</span><br><span class=\"line\">输出：[[\"X\"]]</span><br></pre></td></tr></tbody></table></figure></div>\n<p>提示：</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">m == board.length</span><br><span class=\"line\">n == board[i].length</span><br><span class=\"line\">1 &lt;= m, n &lt;= 200</span><br><span class=\"line\">board[i][j] 为 'X' 或 'O'</span><br></pre></td></tr></tbody></table></figure></div>\n<h3 id=\"解题\"><a class=\"markdownIt-Anchor\" href=\"#解题\">#</a> 解题</h3>\n<p>写在前面<br>\n本题给定的矩阵中有三种元素：</p>\n<ul>\n<li>\n<p>字母 X；</p>\n</li>\n<li>\n<p>被字母 X 包围的字母 O；</p>\n</li>\n<li>\n<p>没有被字母 X 包围的字母 O。</p>\n</li>\n</ul>\n<p>本题要求将所有被字母 X 包围的字母 O 都变为字母 X ，但很难判断哪些 O 是被包围的，哪些 O 不是被包围的。</p>\n<p>注意到题目解释中提到： <code>任何边界上的 O 都不会被填充为 X</code> 。 我们可以想到，所有的不被包围的 O 都直接或间接与边界上的 O 相连。我们可以利用这个性质判断 O 是否在边界上，具体地说：</p>\n<ul>\n<li>对于每一个边界上的 O，我们以它为起点，标记所有与它直接或间接相连的字母 O；<br>\n最后我们遍历这个矩阵，对于每一个字母：</li>\n<li>如果该字母被标记过，则该字母为没有被字母 X 包围的字母 O，我们将其还原为字母 O；<br>\n如果该字母没有被标记过，则该字母为被字母 X 包围的字母 O，我们将其修改为字母 X。</li>\n</ul>\n<h3 id=\"方法一深度优先搜索\"><a class=\"markdownIt-Anchor\" href=\"#方法一深度优先搜索\">#</a> 方法一：深度优先搜索</h3>\n<h4 id=\"思路及解法\"><a class=\"markdownIt-Anchor\" href=\"#思路及解法\">#</a> 思路及解法</h4>\n<p>我们可以使用深度优先搜索实现标记操作。在下面的代码中，我们把标记过的字母 O 修改为字母 A。</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"JAVA\"><figure class=\"iseeu highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> {</span><br><span class=\"line\">    <span class=\"type\">int</span> n, m;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">solve</span><span class=\"params\">(<span class=\"type\">char</span>[][] board)</span> {</span><br><span class=\"line\">        n = board.length;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) {</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        m = board[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; i++) {</span><br><span class=\"line\">            dfs(board, i, <span class=\"number\">0</span>);</span><br><span class=\"line\">            dfs(board, i, m - <span class=\"number\">1</span>);</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; m - <span class=\"number\">1</span>; i++) {</span><br><span class=\"line\">            dfs(board, <span class=\"number\">0</span>, i);</span><br><span class=\"line\">            dfs(board, n - <span class=\"number\">1</span>, i);</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; i++) {</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; m; j++) {</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (board[i][j] == <span class=\"string\">'A'</span>) {</span><br><span class=\"line\">                    board[i][j] = <span class=\"string\">'O'</span>;</span><br><span class=\"line\">                } <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (board[i][j] == <span class=\"string\">'O'</span>) {</span><br><span class=\"line\">                    board[i][j] = <span class=\"string\">'X'</span>;</span><br><span class=\"line\">                }</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">dfs</span><span class=\"params\">(<span class=\"type\">char</span>[][] board, <span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span> {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x &lt; <span class=\"number\">0</span> || x &gt;= n || y &lt; <span class=\"number\">0</span> || y &gt;= m || board[x][y] != <span class=\"string\">'O'</span>) {</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        board[x][y] = <span class=\"string\">'A'</span>;</span><br><span class=\"line\">        dfs(board, x + <span class=\"number\">1</span>, y);</span><br><span class=\"line\">        dfs(board, x - <span class=\"number\">1</span>, y);</span><br><span class=\"line\">        dfs(board, x, y + <span class=\"number\">1</span>);</span><br><span class=\"line\">        dfs(board, x, y - <span class=\"number\">1</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure></div>\n<h4 id=\"复杂度分析\"><a class=\"markdownIt-Anchor\" href=\"#复杂度分析\">#</a> 复杂度分析</h4>\n<ul>\n<li>\n<p>时间复杂度： <code>O(n×m)</code> ，其中  <code>n</code>  和  <code>m </code> 分别为矩阵的行数和列数。深度优先搜索过程中，每一个点至多只会被标记一次。</p>\n</li>\n<li>\n<p>空间复杂度： <code>O(n×m)</code> ，其中  <code>n</code>  和  <code>m</code>  分别为矩阵的行数和列数。主要为深度优先搜索的栈的开销。</p>\n</li>\n</ul>\n<h3 id=\"方法二广度优先搜索\"><a class=\"markdownIt-Anchor\" href=\"#方法二广度优先搜索\">#</a> 方法二：广度优先搜索</h3>\n<h4 id=\"思路及解法-2\"><a class=\"markdownIt-Anchor\" href=\"#思路及解法-2\">#</a> 思路及解法</h4>\n<p>我们可以使用广度优先搜索实现标记操作。在下面的代码中，我们把标记过的字母  <code>O</code>  修改为字母  <code>A</code> 。</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"JAVA\"><figure class=\"iseeu highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> {</span><br><span class=\"line\">    <span class=\"type\">int</span>[] dx = {<span class=\"number\">1</span>, -<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>};</span><br><span class=\"line\">    <span class=\"type\">int</span>[] dy = {<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, -<span class=\"number\">1</span>};</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">solve</span><span class=\"params\">(<span class=\"type\">char</span>[][] board)</span> {</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> board.length;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) {</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">m</span> <span class=\"operator\">=</span> board[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">        Queue&lt;<span class=\"type\">int</span>[]&gt; queue = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;<span class=\"type\">int</span>[]&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; i++) {</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (board[i][<span class=\"number\">0</span>] == <span class=\"string\">'O'</span>) {</span><br><span class=\"line\">                queue.offer(<span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[]{i, <span class=\"number\">0</span>});</span><br><span class=\"line\">                board[i][<span class=\"number\">0</span>] = <span class=\"string\">'A'</span>;</span><br><span class=\"line\">            }</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (board[i][m - <span class=\"number\">1</span>] == <span class=\"string\">'O'</span>) {</span><br><span class=\"line\">                queue.offer(<span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[]{i, m - <span class=\"number\">1</span>});</span><br><span class=\"line\">                board[i][m - <span class=\"number\">1</span>] = <span class=\"string\">'A'</span>;</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; m - <span class=\"number\">1</span>; i++) {</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (board[<span class=\"number\">0</span>][i] == <span class=\"string\">'O'</span>) {</span><br><span class=\"line\">                queue.offer(<span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[]{<span class=\"number\">0</span>, i});</span><br><span class=\"line\">                board[<span class=\"number\">0</span>][i] = <span class=\"string\">'A'</span>;</span><br><span class=\"line\">            }</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (board[n - <span class=\"number\">1</span>][i] == <span class=\"string\">'O'</span>) {</span><br><span class=\"line\">                queue.offer(<span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[]{n - <span class=\"number\">1</span>, i});</span><br><span class=\"line\">                board[n - <span class=\"number\">1</span>][i] = <span class=\"string\">'A'</span>;</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!queue.isEmpty()) {</span><br><span class=\"line\">            <span class=\"type\">int</span>[] cell = queue.poll();</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">x</span> <span class=\"operator\">=</span> cell[<span class=\"number\">0</span>], y = cell[<span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++) {</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">mx</span> <span class=\"operator\">=</span> x + dx[i], my = y + dy[i];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mx &lt; <span class=\"number\">0</span> || my &lt; <span class=\"number\">0</span> || mx &gt;= n || my &gt;= m || board[mx][my] != <span class=\"string\">'O'</span>) {</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                }</span><br><span class=\"line\">                queue.offer(<span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[]{mx, my});</span><br><span class=\"line\">                board[mx][my] = <span class=\"string\">'A'</span>;</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; i++) {</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; m; j++) {</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (board[i][j] == <span class=\"string\">'A'</span>) {</span><br><span class=\"line\">                    board[i][j] = <span class=\"string\">'O'</span>;</span><br><span class=\"line\">                } <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (board[i][j] == <span class=\"string\">'O'</span>) {</span><br><span class=\"line\">                    board[i][j] = <span class=\"string\">'X'</span>;</span><br><span class=\"line\">                }</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure></div>\n<h4 id=\"复杂度分析-2\"><a class=\"markdownIt-Anchor\" href=\"#复杂度分析-2\">#</a> 复杂度分析</h4>\n<ul>\n<li>\n<p>时间复杂度： <code>O(n×m)</code> ，其中  <code>n</code>  和  <code>m</code>  分别为矩阵的行数和列数。广度优先搜索过程中，每一个点至多只会被标记一次。</p>\n</li>\n<li>\n<p>空间复杂度： <code>O(n×m)</code> ，其中  <code>n</code>  和  <code>m</code>  分别为矩阵的行数和列数。主要为广度优先搜索的队列的开销。</p>\n</li>\n</ul>\n</body></html>",
            "tags": [
                "矩阵",
                "深度遍历",
                "广度遍历"
            ]
        },
        {
            "id": "https://www.pswen.cn/p/fbb9fe6d/index.html",
            "url": "https://www.pswen.cn/p/fbb9fe6d/index.html",
            "title": "单词接龙——leetcode127",
            "date_published": "2022-01-09T10:38:08.000Z",
            "content_html": "<html><head></head><body><h1 id=\"题目描述\"><a class=\"markdownIt-Anchor\" href=\"#题目描述\">#</a> 题目描述</h1>\n<p>字典&nbsp;wordList 中从单词 beginWord&nbsp;和 endWord 的 转换序列 是一个按下述规格形成的序列：<br>\n序列中第一个单词是  <code>beginWord</code>  。<br>\n序列中最后一个单词是  <code>endWord</code> 。<br>\n每次转换只能改变一个字母。<br>\n转换过程中的中间单词必须是字典&nbsp; <code>wordList</code>  中的单词。<br>\n给你两个单词  <code>beginWord</code> &nbsp;和  <code>endWord</code>  和一个字典  <code>wordList</code>  ，找到从&nbsp; <code>beginWord </code> 到&nbsp; <code>endWord</code>  的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回  <code>0</code> 。</p>\n<span id=\"more\"></span>\n<p>示例 1：</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]</span><br><span class=\"line\">输出：5</span><br><span class=\"line\">解释：一个最短转换序列是 \"hit\" -&gt; \"hot\" -&gt; \"dot\" -&gt; \"dog\" -&gt; \"cog\", 返回它的长度 5。</span><br></pre></td></tr></tbody></table></figure></div>\n<p>示例 2：</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]</span><br><span class=\"line\">输出：0</span><br><span class=\"line\">解释：endWord \"cog\" 不在字典中，所以无法进行转换。</span><br></pre></td></tr></tbody></table></figure></div>\n<p>提示：</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 &lt;= beginWord.length &lt;= 10</span><br><span class=\"line\">endWord.length == beginWord.length</span><br><span class=\"line\">1 &lt;= wordList.length &lt;= 5000</span><br><span class=\"line\">wordList[i].length == beginWord.length</span><br><span class=\"line\">beginWord、endWord 和 wordList[i] 由小写英文字母组成</span><br><span class=\"line\">beginWord != endWord</span><br><span class=\"line\">wordList 中的所有字符串 互不相同</span><br></pre></td></tr></tbody></table></figure></div>\n<h1 id=\"解题\"><a class=\"markdownIt-Anchor\" href=\"#解题\">#</a> 解题</h1>\n<h3 id=\"方法一广度优先搜索-优化建图\"><a class=\"markdownIt-Anchor\" href=\"#方法一广度优先搜索-优化建图\">#</a> 方法一：广度优先搜索 + 优化建图</h3>\n<h4 id=\"思路\"><a class=\"markdownIt-Anchor\" href=\"#思路\">#</a> 思路</h4>\n<p>本题要求的是最短转换序列的长度，看到最短首先想到的就是广度优先搜索。想到广度优先搜索自然而然的就能想到图，但是本题并没有直截了当的给出图的模型，因此我们需要把它抽象成图的模型。</p>\n<p>我们可以把每个单词都抽象为一个点，如果两个单词可以只改变一个字母进行转换，那么说明他们之间有一条双向边。因此我们只需要把满足转换条件的点相连，就形成了一张图。</p>\n<p>基于该图，我们以 beginWord 为图的起点，以 endWord 为终点进行广度优先搜索，寻找 beginWord 到 endWord 的最短路径。</p>\n<h4 id=\"算法\"><a class=\"markdownIt-Anchor\" href=\"#算法\">#</a> 算法</h4>\n<p>基于上面的思路我们考虑如何编程实现。</p>\n<p>首先为了方便表示，我们先给每一个单词标号，即给每个单词分配一个 id。创建一个由单词 word 到 id 对应的映射 wordId，并将 beginWord 与 wordList 中所有的单词都加入这个映射中。之后我们检查 endWord 是否在该映射内，若不存在，则输入无解。我们可以使用哈希表实现上面的映射关系。</p>\n<p>然后我们需要建图，依据朴素的思路，我们可以枚举每一对单词的组合，判断它们是否恰好相差一个字符，以判断这两个单词对应的节点是否能够相连。但是这样效率太低，我们可以优化建图。</p>\n<p>具体地，我们可以创建虚拟节点。对于单词 hit，我们创建三个虚拟节点 <em>it、h</em>t、hi*，并让 hit 向这三个虚拟节点分别连一条边即可。如果一个单词能够转化为 hit，那么该单词必然会连接到这三个虚拟节点之一。对于每一个单词，我们枚举它连接到的虚拟节点，把该单词对应的 id 与这些虚拟节点对应的 id 相连即可。</p>\n<p>最后我们将起点加入队列开始广度优先搜索，当搜索到终点时，我们就找到了最短路径的长度。注意因为添加了虚拟节点，所以我们得到的距离为实际最短路径长度的两倍。同时我们并未计算起点对答案的贡献，所以我们应当返回距离的一半再加一的结果。</p>\n<h4 id=\"代码\"><a class=\"markdownIt-Anchor\" href=\"#代码\">#</a> 代码</h4>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"JAVA\"><figure class=\"iseeu highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> {</span><br><span class=\"line\">    Map&lt;String, Integer&gt; wordId = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;String, Integer&gt;();</span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; edge = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">nodeNum</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">ladderLength</span><span class=\"params\">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> {</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String word : wordList) {</span><br><span class=\"line\">            addEdge(word);</span><br><span class=\"line\">        }</span><br><span class=\"line\">        addEdge(beginWord);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!wordId.containsKey(endWord)) {</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"type\">int</span>[] dis = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[nodeNum];</span><br><span class=\"line\">        Arrays.fill(dis, Integer.MAX_VALUE);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">beginId</span> <span class=\"operator\">=</span> wordId.get(beginWord), endId = wordId.get(endWord);</span><br><span class=\"line\">        dis[beginId] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        Queue&lt;Integer&gt; que = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;Integer&gt;();</span><br><span class=\"line\">        que.offer(beginId);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!que.isEmpty()) {</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">x</span> <span class=\"operator\">=</span> que.poll();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (x == endId) {</span><br><span class=\"line\">                <span class=\"keyword\">return</span> dis[endId] / <span class=\"number\">2</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">            }</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> it : edge.get(x)) {</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (dis[it] == Integer.MAX_VALUE) {</span><br><span class=\"line\">                    dis[it] = dis[x] + <span class=\"number\">1</span>;</span><br><span class=\"line\">                    que.offer(it);</span><br><span class=\"line\">                }</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">addEdge</span><span class=\"params\">(String word)</span> {</span><br><span class=\"line\">        addWord(word);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">id1</span> <span class=\"operator\">=</span> wordId.get(word);</span><br><span class=\"line\">        <span class=\"type\">char</span>[] array = word.toCharArray();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">length</span> <span class=\"operator\">=</span> array.length;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; length; ++i) {</span><br><span class=\"line\">            <span class=\"type\">char</span> <span class=\"variable\">tmp</span> <span class=\"operator\">=</span> array[i];</span><br><span class=\"line\">            array[i] = <span class=\"string\">'*'</span>;</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">newWord</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(array);</span><br><span class=\"line\">            addWord(newWord);</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">id2</span> <span class=\"operator\">=</span> wordId.get(newWord);</span><br><span class=\"line\">            edge.get(id1).add(id2);</span><br><span class=\"line\">            edge.get(id2).add(id1);</span><br><span class=\"line\">            array[i] = tmp;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">addWord</span><span class=\"params\">(String word)</span> {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!wordId.containsKey(word)) {</span><br><span class=\"line\">            wordId.put(word, nodeNum++);</span><br><span class=\"line\">            edge.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;Integer&gt;());</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure></div>\n<h4 id=\"复杂度分析\"><a class=\"markdownIt-Anchor\" href=\"#复杂度分析\">#</a> 复杂度分析</h4>\n<ul>\n<li>时间复杂度： <code>O(N×C2)</code> 。其中  N 为 wordList 的长度， C 为列表中单词的长度。</li>\n</ul>\n<p>建图过程中，对于每一个单词，我们需要枚举它连接到的所有虚拟节点，时间复杂度为   <code>O(C)</code> ，将这些单词加入到哈希表中，时间复杂度为  <code>O(N×C)</code> ，因此总时间复杂度为  <code>O(N×C)</code> 。</p>\n<p>广度优先搜索的时间复杂度最坏情况下是 O (N \\times C) O (N×C)。每一个单词需要拓展出 O©O© 个虚拟节点，因此节点数 O (N \\times C) O (N×C)。</p>\n<ul>\n<li>空间复杂度： <code>O(N×C2)</code> 。其中 N 为 wordList 的长度，C 为列表中单词的长度。哈希表中包含  <code>O(N×C)</code>  个节点，每个节点占用空间  <code>O(C)</code> ，因此总的空间复杂度为  <code>O(N×C^2)</code> 。</li>\n</ul>\n</body></html>",
            "tags": [
                "leetcode",
                "算法",
                "单词接龙"
            ]
        }
    ]
}