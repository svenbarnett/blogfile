{
    "version": "https://jsonfeed.org/version/1",
    "title": "人间日常 • All posts by \"java\" category",
    "description": "所行皆过往，所愿皆成真",
    "home_page_url": "https://www.pswen.cn",
    "items": [
        {
            "id": "https://www.pswen.cn/p/4c633c0c/index.html",
            "url": "https://www.pswen.cn/p/4c633c0c/index.html",
            "title": "从Apollo动态配置原理学Spring(二)",
            "date_published": "2023-02-26T12:39:24.000Z",
            "content_html": "<html><head></head><body><blockquote>\n<p>Apollo 动态配置其实本质就是利用 Spring Bean 的生命周期的扩展点，这个扩展点超级多，不可能全部列出来，只说核心的扩展点。这也就是为什么 Spring 的扩展性很好的原因，开了很多的口子，尽可能让某个功能高内聚松耦合，用户需要哪个功能就用哪个，而不是直接来一个大而全的东西。</p>\n</blockquote>\n<p>我们先通过学习核心的，然后后续对照 Apollo 用到了哪些再对照，就会发现很多地方就能理解的很好了</p>\n<span id=\"more\"></span>\n<p><strong>什么是 Spring Bean 的生命周期</strong></p>\n<p>对于普通的 Java 对象，当 new 的时候创建对象，然后该对象就能够使用了。一旦该对象不再被使用，则由 Java 自动进行垃圾回收。</p>\n<p>而 Spring 中的对象是 bean，bean 和普通的 Java 对象没啥大的区别，只不过 Spring 不再自己去 new 对象了，而是由 IoC 容器去帮助我们实例化对象并且管理它，我们需要哪个对象，去问 IoC 容器要即可。IoC 其实就是解决对象之间的耦合问题，Spring Bean 的生命周期完全由容器控制。</p>\n<h2 id=\"spring-bean-的生命周期\"><a class=\"markdownIt-Anchor\" href=\"#spring-bean-的生命周期\">#</a> Spring Bean 的生命周期</h2>\n<p>这里要提一下，这里我们说的 Spring Bean 的生命周期主要指的是 singleton bean，对于 prototype 的 bean ，Spring 在创建好交给使用者之后则不会再管理后续的生命周期。</p>\n<p>我们也来复习下 Spring 中的 bean 的作用域有哪些？</p>\n<ul>\n<li><code>singleton</code>  : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。</li>\n<li><code>prototype</code>  : 每次请求都会创建一个新的 bean 实例。</li>\n<li><code>request</code>  : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。</li>\n<li><code>session</code>  : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。</li>\n<li><code>global-session</code> ： 全局 session 作用域，仅仅在基于 Portlet 的 web 应用中才有意义，Spring5 已经没有了。Portlet 是能够生成语义代码（例如：HTML）片段的小型 Java Web 插件。它们基于 portlet 容器，可以像 servlet 一样处理 HTTP 请求。但是，与 servlet 不同，每个 portlet 都有不同的会话。</li>\n</ul>\n<p>我们知道对于普通的 Java 对象来说，它们的生命周期就是：</p>\n<ul>\n<li>实例化</li>\n<li>该对象不再被使用时通过垃圾回收机制进行回收</li>\n</ul>\n<p>而对于 Spring Bean 的生命周期来说：</p>\n<ul>\n<li>实例化 Instantiation</li>\n<li>属性赋值 Populate</li>\n<li>初始化 Initialization</li>\n<li>销毁 Destruction</li>\n</ul>\n<p>实例化 -&gt; 属性赋值 -&gt; 初始化 -&gt; 销毁</p>\n<p>只有四个步骤，这样拆解的话是不是感觉也不难？不像其他人写的那样直接一上来就各种 BeanPostProcessor、BeanFactoryPostProcessor 全部怼进流程里去，别说读者看着头大，自己写的可能短时间内还记得流程，隔个一段时间，你可能都不知道自己写了个啥。</p>\n<p>通过 Bean 创建流程入口 <code>AbstractApplicationContext#refresh()</code>  方法的  <code>finishBeanFactoryInitialization(beanFactory)</code>  处带大家跟一下源码，想了想还是不带入过多的代码进来，直接给到最终的主要逻辑。</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"JAVA\"><figure class=\"iseeu highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> Object <span class=\"title function_\">doCreateBean</span><span class=\"params\">(String beanName, RootBeanDefinition mbd, <span class=\"meta\">@Nullable</span> Object[] args)</span> <span class=\"keyword\">throws</span> BeanCreationException {</span><br><span class=\"line\">    <span class=\"type\">BeanWrapper</span> <span class=\"variable\">instanceWrapper</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mbd.isSingleton()) {</span><br><span class=\"line\">        instanceWrapper = (BeanWrapper)<span class=\"built_in\">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instanceWrapper == <span class=\"literal\">null</span>) {</span><br><span class=\"line\">    \t<span class=\"comment\">// 实例化阶段</span></span><br><span class=\"line\">        instanceWrapper = <span class=\"built_in\">this</span>.createBeanInstance(beanName, mbd, args);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"type\">Object</span> <span class=\"variable\">exposedObject</span> <span class=\"operator\">=</span> bean;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> {</span><br><span class=\"line\">    \t<span class=\"comment\">// 属性赋值阶段</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.populateBean(beanName, mbd, instanceWrapper);</span><br><span class=\"line\">        <span class=\"comment\">// 初始化阶段</span></span><br><span class=\"line\">        exposedObject = <span class=\"built_in\">this</span>.initializeBean(beanName, exposedObject, mbd);</span><br><span class=\"line\">    } <span class=\"keyword\">catch</span> (Throwable var18) {</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    }</span><br><span class=\"line\">    ...</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure></div>\n<p>至于销毁，是在容器关闭时调用的，详见  <code>ConfigurableApplicationContext#close()</code></p>\n<p>是不是很清爽了？至于 BeanPostProcessor、BeanFactoryPostProcessor 以及其他的类，只不过是对主流程四个步骤的一系列扩展点而已。</p>\n<h2 id=\"spring-bean-的生命周期的扩展点\"><a class=\"markdownIt-Anchor\" href=\"#spring-bean-的生命周期的扩展点\">#</a> Spring Bean 的生命周期的扩展点</h2>\n<p>Spring Bean 的生命周期的扩展点超级多，老周这里不可能全部列出来，只说核心的扩展点。这也就是为什么 Spring 的扩展性很好的原因，开了很多的口子，尽可能让某个功能高内聚松耦合，用户需要哪个功能就用哪个，而不是直接来一个大而全的东西。</p>\n<p><strong>Bean 自身的方法</strong></p>\n<p>比如构造函数、getter/setter 以及 init-method 和 destory-method 所指定的方法等，也就对应着上文说的实例化 -&gt; 属性赋值 -&gt; 初始化 -&gt; 销毁四个阶段。</p>\n<p><img src=\"/p/4c633c0c/index.html20210707002134280.png\" alt=\"阶段示意图\"></p>\n<p><strong>容器级的方法（BeanPostProcessor 一系列接口）</strong></p>\n<p>主要是后处理器方法，比如下图的  <code>InstantiationAwareBeanPostProcessor</code> 、 <code>BeanPostProcessor</code>  接口方法。这些接口的实现类是独立于 Bean 的，并且会注册到 Spring 容器中。在 Spring 容器创建任何 Bean 的时候，这些后处理器都会发生作用。</p>\n<p><img src=\"/p/4c633c0c/index.html20210707225212729.png\" alt=\"扩展点\"></p>\n<p><strong>InstantiationAwareBeanPostProcessor 源码分析</strong></p>\n<p>我们翻一下源码发现 InstantiationAwareBeanPostProcessor 是继承了 BeanPostProcessor</p>\n<p><img src=\"/p/4c633c0c/index.html20210707230505579.png\" alt=\"InstantiationAwareBeanPostProcessor \"></p>\n<p><img src=\"/p/4c633c0c/index.html20210707230919307.png\" alt=\"BeanPostProcessor\"></p>\n<ul>\n<li><code>InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation</code>  调用点</li>\n</ul>\n<blockquote>\n<p>Object postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName)<br>\n 返回值：如果返回的不为 null，那么后续的 Bean 的创建流程【实例化、初始化 afterProperties】都不会执行，而是直接使用返回的快捷 Bean，此时的正常执行顺序如下：<br>\nInstantiationAwareBeanPostProcessor 接口中的 postProcessBeforeInstantiation，在实例化之前调用。<br>\nBeanPostProcessor 接口中的 postProcessAfterInitialization，在实例化之后调用。</p>\n</blockquote>\n<p><img src=\"https://img-blog.csdnimg.cn/20210707233026943.png\" alt=\"createbean\"></p>\n<p><img src=\"/p/4c633c0c/index.html20210707235533784.png\" alt=\"resolveBeforeInstantiation\"></p>\n<p><img src=\"/p/4c633c0c/index.html20210708000228655.png\" alt=\"applyBean\"></p>\n<p>总之，postProcessBeforeInstantiation 在 doCreateBean 之前调用，也就是在 bean 实例化之前调用的，英文源码注释解释道该方法的返回值会替换原本的 Bean 作为代理，这也是 <a href=\"https://so.csdn.net/so/search?q=AOP&amp;spm=1001.2101.3001.7020\">AOP</a> 等功能实现的关键点。</p>\n<ul>\n<li><code>InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation</code>  调用点</li>\n</ul>\n<blockquote>\n<p>boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException<br>\n 正常情况下在实例化之后在执行 populateBean 之前调用<br>\n返回值：如果有指定的 bean 的时候返回 false，那么后续的属性填充和属性依赖注入【populateBean】将不会执行，同时后续的 postProcessPropertyValues 将不会执行，但是初始化和 BeanPostProcessor 的仍然会执行。</p>\n</blockquote>\n<p><img src=\"/p/4c633c0c/index.html20210708005050274.png\" alt=\"populateBean\"></p>\n<p>public PropertyValues postProcessPropertyValues(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)<br>\n 实例化之后调用，在方法 applyPropertyValues【属性填充】之前<br>\n返回值：如果返回 null，那么将不会进行后续的属性填充，比如依赖注入等，如果返回的 pvs 额外的添加了属性，那么后续会填充到该类对应的属性中。<br>\npvs：PropertyValues 对象，用于封装指定类的对象，简单来说就是 PropertyValue 的集合，里面相当于以 key-value 形式存放类的属性和值。<br>\npds：PropertyDescriptor 对象数组，PropertyDescriptor 相当于存储类的属性，不过可以调用 set，get 方法设置和获取对应属性的值。</p>\n<p><img src=\"/p/4c633c0c/index.html20210708010057366.png\" alt=\"postProcessPropertyValues\"></p>\n<p><strong>BeanPostProcessor 源码分析</strong></p>\n<blockquote>\n<p>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#doCreateBean</p>\n</blockquote>\n<p><img src=\"/p/4c633c0c/index.html20210708232740951.png\" alt=\"在这里插入图片描述\"><br>\n进入初始化接口：</p>\n<p><img src=\"/p/4c633c0c/index.html20210708233139731.png\" alt=\"在这里插入图片描述\"><br>\n我们先来看</p>\n<blockquote>\n<p>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#applyBeanPostProcessorsBeforeInitialization</p>\n</blockquote>\n<p><img src=\"/p/4c633c0c/index.html20210708233742525.png\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li>首先获取到所有的后置处理器 getBeanPostProcessors ()</li>\n<li>在 for 循环中依次调用后置处理器的方法  <code>processor.postProcessBeforeInitialization(result, beanName);</code></li>\n<li>进入 postProcessBeforeInitialization 方法</li>\n</ul>\n<blockquote>\n<p>org.springframework.context.support.ApplicationContextAwareProcessor#postProcessBeforeInitialization</p>\n</blockquote>\n<p><img src=\"/p/4c633c0c/index.html20210708234443215.png\" alt=\"在这里插入图片描述\"></p>\n<p>进入  <code>invokeAwareInterfaces(bean);</code>  方法，当前 bean 实现了 ApplicationContextAware 接口。</p>\n<p><img src=\"/p/4c633c0c/index.html20210708234639952.png\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li><code>ApplicationContextAwareProcessor#postProcessBeforeInitialization</code>  首先判断此 bean 是不是各种的 Aware，如果是它列举的那几个 Aware 就获取 Bean 工厂的权限，可以向容器中导入相关的上下文环境，目的是为了 Bean 实例能够获取到相关的上下文，如果不是它列举的几个 Aware，那就调用  <code>invokeAwareInterfaces(bean)</code> ，向容器中添加相关接口的上下文环境。</li>\n</ul>\n<p><strong>3.3 工厂后处理器方法（BeanFactoryProcessor 一系列接口）</strong></p>\n<p>包括  <code>AspectJWeavingEnabler</code> 、 <code>CustomAutowireConfigurer</code> 、 <code>ConfigurationClassPostProcessor</code>  等。这些都是 Spring 框架中已经实现好的 BeanFactoryPostProcessor，用来实现某些特定的功能。</p>\n<p>我们知道 Spring IoC 容器初始化的关键环节就在  <code>org.springframework.context.support.AbstractApplicationContext#refresh</code>  方法中 ，容器创建的主体流程都在这个方法里面，这个方法是真的重要！！！</p>\n<p>对于工厂后处理器方法老周这里直接带你看  <code>invokeBeanFactoryPostProcessors(beanFactory);</code>  方法，这个方法处理的是  <code>BeanFactoryPostProcessor</code>  接口的 Bean。调用方法如下：</p>\n<p><img src=\"/p/4c633c0c/index.html20210709231013239.png\" alt=\"在这里插入图片描述\"><br>\n跟到最重要的方法里去，代码虽长，但逻辑中规中矩。</p>\n<p><code>BeanFactoryPostProcessor</code> ：一切处理 BeanFactory 的父接口<br>\n <code>BeanDefinitionRegistryPostProcessor</code> ：实现了 BeanFactoryPostProcessor 接口的接口</p>\n<p><img src=\"/p/4c633c0c/index.html20210709233225102.png\" alt=\"在这里插入图片描述\"><br>\n流程说明：</p>\n<ul>\n<li>调用 BeanDefinitionRegistryPostProcessor#postProcessBeanDefinitionRegistry (registry) 方法。参数 beanFactoryPostProcessors 传入的优先处理掉。然后获取容器注册的，对于这些 Bean 按照 PriorityOrdered 接口、Ordered、没有排序接口的实例分别进行处理。</li>\n<li>调用 BeanFactoryPostProcessor#postProcessBeanFactory (beanFactory) 方法。备注：BeanDefinitionRegistryPostProcessor 属于 BeanFactoryPostProcessor 子接口。先处理属于 BeanDefinitionRegistryPostProcessor 接口实例的 postProcessBeanFactory (beanFactory) 方法，然后获取容器注册的。对于这些 Bean 按照 PriorityOrdered 接口、Ordered、没有排序接口的实例分别进行处理。</li>\n</ul>\n</body></html>",
            "tags": [
                "Apollo",
                "Spring"
            ]
        },
        {
            "id": "https://www.pswen.cn/p/e352a76e/index.html",
            "url": "https://www.pswen.cn/p/e352a76e/index.html",
            "title": "从Apollo动态配置原理学Spring(一)",
            "date_published": "2023-02-23T14:29:54.000Z",
            "content_html": "<html><head></head><body><blockquote>\n<p>最近工作碰到需要写一个类似携程 Apollo 的动态配置功能，以此系统学习该原理，熟练掌握下 Spring 的各种机制</p>\n</blockquote>\n<p><strong>Apollo 动态配置原理简述</strong></p>\n<p>Apollo 配置中心动态生效机制，是基于 Http 长轮询请求和 Spring 扩展机制实现的，在 Spring 容器启动过程中，Apollo 通过自定义的 <code>BeanPostProcessor</code>  和 <code>BeanFactoryPostProcessor</code>  將参数中包含 <code>${…}</code>  占位符和 <code>@Value</code>  注解的 Bean 注册到 Apollo 框架中定义的注册表中。然后通过 Http 长轮询不断的去获取服务端的配置信息，一旦配置发生变化，Apollo 会根据变化的配置的 Key 找到对应的 Bean，然后修改 Bean 的属性，从而实现了配置动态生效的特性。</p>\n<p>需要注意的是，Apollo 在配置变化后，只能修改 Bean 的属性，例如我们数据源的属性发生变化，新创建的 Connection 对象是没问题的，但是连接池中已经创建的 Connection 对象相关信息是不能动态修改的，所以依然需要重启应用。</p>\n<span id=\"more\"></span>\n<p>其中涉及到的 Spring 的扩展机制有：</p>\n<ul>\n<li>BeanFactoryPostProcessor</li>\n<li>BeanPostProcessor</li>\n<li>BeanDefinitionRegistry</li>\n<li>PropertySource</li>\n<li>ImportBeanDefinitionRegistrar</li>\n<li>PropertySourcesPlaceholderConfigurer</li>\n</ul>\n<p>…</p>\n<p>其中每一个都是非常关键的点，我们后续会一一进行学习。</p>\n<h2 id=\"apollo启动过程\"><a class=\"markdownIt-Anchor\" href=\"#apollo启动过程\">#</a> Apollo 启动过程</h2>\n<p>首先，我们先看一张图：</p>\n<p><img src=\"/p/e352a76e/index.htmlimage-20230223224050610.png\" alt=\"Apollo启动图\"></p>\n<ol>\n<li>\n<p>Spring 启动，扫描 bean，将相关变量参数注册到 Apollo 属性注册表</p>\n</li>\n<li>\n<p>通过 RemoteConfigRepository 获取配置，持久化本地，后续读取从本地读取，通过 <code>PropertySourcesProcessor</code>  执行如下步骤</p>\n</li>\n</ol>\n<p>（1）根据命名空间从配置中心获取配置信息，创建 RemoteConfigRepository 和 LocalFileConfigRepository 对象。RemoteConfigRepository 表示远程配置中心资源，LocalFileConfigRepository 表示本地缓存配置资源。</p>\n<p>（2）LocalFileConfigRepository 对象缓存配置信息到 C:\\opt\\data 或者 /opt/data 目录</p>\n<p>（3）RemoteConfigRepository 开启 HTTP 长轮询请求定时任务，默认 2s 请求一次。</p>\n<p>（4）將本地缓存配置信息转换为 PropertySource 对象（Apollo 自定义了 Spring 的 PropertySource），加载到 Spring 的 Environment 对象中。至此静态配置就已经加入到环境变量中</p>\n<p>（5）將自定义的 ConfigPropertySource 注册为观察者。一旦 RemoteConfigRepository 发现远程配置中心信息发生变化，ConfigPropertySource 对象会得到通知。</p>\n<ol start=\"3\">\n<li>\n<p>通过一个自定义监听器，监听对应事件</p>\n</li>\n<li>\n<p>后续通过长轮询请求监听到配置变化，根据配置读取注册表里面的 key 和对应的 bean，通过反射修改 bean 对应属性值</p>\n</li>\n</ol>\n<h2 id=\"apollo扩展点\"><a class=\"markdownIt-Anchor\" href=\"#apollo扩展点\">#</a> Apollo 扩展点</h2>\n<ol>\n<li><code>PropertySourcesProcessor</code>  初始化 Apollo 配置、接入 Spring environment，初始化 Apollo 监听器</li>\n<li><code>ApolloAnnotationProcessor</code>  提供 Apollo 一些注解支持 <code>@ApolloConfig</code> ， <code>@ApolloConfigChangeListener</code></li>\n<li><code>SpringValueProcessor</code>  提供对 <code>@Value</code>  动态生效能力 针对实例 bean</li>\n<li><code>SpringValueDefinitionProcessor</code>  提供对 <code>@Value</code>  动态生效能力 针对 bean 定义</li>\n<li><code>ApolloJsonValueProcessor</code>  提供对 <code>@ApolloJsonValue</code>  支持</li>\n</ol>\n<p>上述分别对应使用 Spring 的扩展能力 <code>BeanFactoryPostProcessor</code> 、 <code>BeanPostProcessor</code> 、 <code>BeanPostProcessor</code>  和 <code>BeanFactoryPostProcessor</code> 、 <code>BeanDefinitionRegistryPostProcessor</code> 、 <code>BeanPostProcessor</code></p>\n<p>我们这个系列也会对 apollo 基于 spring 提供的扩展点来嵌入自己的能力。主要为 BeanFactoryPostProcessor、BeanPostProcessor 这两个扩展点；先简单说一下：<em><strong>只需要知道，BeanFactoryPostProcessor、BeanDefinitionRegistryPostProcessor 在生成所有 beandefinition 之后调用，而 BeanPostProcessor 在通过 beandefinition 实例化 bean 的过程中调用即可。</strong></em></p>\n<p>那这些实现我们就下篇见了！！！</p>\n</body></html>",
            "tags": [
                "Apollo",
                "Spring",
                "动态配置"
            ]
        },
        {
            "id": "https://www.pswen.cn/p/52a5c0f5/index.html",
            "url": "https://www.pswen.cn/p/52a5c0f5/index.html",
            "title": "被围绕的区域——LeetCode130",
            "date_published": "2022-02-08T11:56:55.000Z",
            "content_html": "<html><head></head><body><p>给你一个  <code>m x n</code>  的矩阵  <code>board</code>  ，由若干字符  <code>'X'</code>  和  <code>'O'</code>  ，找到所有被  <code>'X'</code>  围绕的区域，并将这些区域里所有的  <code>'O'</code>  用  <code>'X'</code>  填充。</p>\n<p><img src=\"/p/52a5c0f5/index.htmlxogrid.jpg\" alt=\"img\"></p>\n<span id=\"more\"></span>\n<p>示例 1</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：board = [[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"O\",\"X\"],[\"X\",\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]]</span><br><span class=\"line\">输出：[[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]]</span><br><span class=\"line\">解释：被围绕的区间不会存在于边界上，换句话说，任何边界上的&nbsp;'O'&nbsp;都不会被填充为&nbsp;'X'。 任何不在边界上，或不与边界上的&nbsp;'O'&nbsp;相连的&nbsp;'O'&nbsp;最终都会被填充为&nbsp;'X'。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。</span><br></pre></td></tr></tbody></table></figure></div>\n<p>示例 2</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：board = [[\"X\"]]</span><br><span class=\"line\">输出：[[\"X\"]]</span><br></pre></td></tr></tbody></table></figure></div>\n<p>提示：</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">m == board.length</span><br><span class=\"line\">n == board[i].length</span><br><span class=\"line\">1 &lt;= m, n &lt;= 200</span><br><span class=\"line\">board[i][j] 为 'X' 或 'O'</span><br></pre></td></tr></tbody></table></figure></div>\n<h3 id=\"解题\"><a class=\"markdownIt-Anchor\" href=\"#解题\">#</a> 解题</h3>\n<p>写在前面<br>\n本题给定的矩阵中有三种元素：</p>\n<ul>\n<li>\n<p>字母 X；</p>\n</li>\n<li>\n<p>被字母 X 包围的字母 O；</p>\n</li>\n<li>\n<p>没有被字母 X 包围的字母 O。</p>\n</li>\n</ul>\n<p>本题要求将所有被字母 X 包围的字母 O 都变为字母 X ，但很难判断哪些 O 是被包围的，哪些 O 不是被包围的。</p>\n<p>注意到题目解释中提到： <code>任何边界上的 O 都不会被填充为 X</code> 。 我们可以想到，所有的不被包围的 O 都直接或间接与边界上的 O 相连。我们可以利用这个性质判断 O 是否在边界上，具体地说：</p>\n<ul>\n<li>对于每一个边界上的 O，我们以它为起点，标记所有与它直接或间接相连的字母 O；<br>\n最后我们遍历这个矩阵，对于每一个字母：</li>\n<li>如果该字母被标记过，则该字母为没有被字母 X 包围的字母 O，我们将其还原为字母 O；<br>\n如果该字母没有被标记过，则该字母为被字母 X 包围的字母 O，我们将其修改为字母 X。</li>\n</ul>\n<h3 id=\"方法一深度优先搜索\"><a class=\"markdownIt-Anchor\" href=\"#方法一深度优先搜索\">#</a> 方法一：深度优先搜索</h3>\n<h4 id=\"思路及解法\"><a class=\"markdownIt-Anchor\" href=\"#思路及解法\">#</a> 思路及解法</h4>\n<p>我们可以使用深度优先搜索实现标记操作。在下面的代码中，我们把标记过的字母 O 修改为字母 A。</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"JAVA\"><figure class=\"iseeu highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> {</span><br><span class=\"line\">    <span class=\"type\">int</span> n, m;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">solve</span><span class=\"params\">(<span class=\"type\">char</span>[][] board)</span> {</span><br><span class=\"line\">        n = board.length;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) {</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        m = board[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; i++) {</span><br><span class=\"line\">            dfs(board, i, <span class=\"number\">0</span>);</span><br><span class=\"line\">            dfs(board, i, m - <span class=\"number\">1</span>);</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; m - <span class=\"number\">1</span>; i++) {</span><br><span class=\"line\">            dfs(board, <span class=\"number\">0</span>, i);</span><br><span class=\"line\">            dfs(board, n - <span class=\"number\">1</span>, i);</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; i++) {</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; m; j++) {</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (board[i][j] == <span class=\"string\">'A'</span>) {</span><br><span class=\"line\">                    board[i][j] = <span class=\"string\">'O'</span>;</span><br><span class=\"line\">                } <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (board[i][j] == <span class=\"string\">'O'</span>) {</span><br><span class=\"line\">                    board[i][j] = <span class=\"string\">'X'</span>;</span><br><span class=\"line\">                }</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">dfs</span><span class=\"params\">(<span class=\"type\">char</span>[][] board, <span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span> {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x &lt; <span class=\"number\">0</span> || x &gt;= n || y &lt; <span class=\"number\">0</span> || y &gt;= m || board[x][y] != <span class=\"string\">'O'</span>) {</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        board[x][y] = <span class=\"string\">'A'</span>;</span><br><span class=\"line\">        dfs(board, x + <span class=\"number\">1</span>, y);</span><br><span class=\"line\">        dfs(board, x - <span class=\"number\">1</span>, y);</span><br><span class=\"line\">        dfs(board, x, y + <span class=\"number\">1</span>);</span><br><span class=\"line\">        dfs(board, x, y - <span class=\"number\">1</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure></div>\n<h4 id=\"复杂度分析\"><a class=\"markdownIt-Anchor\" href=\"#复杂度分析\">#</a> 复杂度分析</h4>\n<ul>\n<li>\n<p>时间复杂度： <code>O(n×m)</code> ，其中  <code>n</code>  和  <code>m </code> 分别为矩阵的行数和列数。深度优先搜索过程中，每一个点至多只会被标记一次。</p>\n</li>\n<li>\n<p>空间复杂度： <code>O(n×m)</code> ，其中  <code>n</code>  和  <code>m</code>  分别为矩阵的行数和列数。主要为深度优先搜索的栈的开销。</p>\n</li>\n</ul>\n<h3 id=\"方法二广度优先搜索\"><a class=\"markdownIt-Anchor\" href=\"#方法二广度优先搜索\">#</a> 方法二：广度优先搜索</h3>\n<h4 id=\"思路及解法-2\"><a class=\"markdownIt-Anchor\" href=\"#思路及解法-2\">#</a> 思路及解法</h4>\n<p>我们可以使用广度优先搜索实现标记操作。在下面的代码中，我们把标记过的字母  <code>O</code>  修改为字母  <code>A</code> 。</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"JAVA\"><figure class=\"iseeu highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> {</span><br><span class=\"line\">    <span class=\"type\">int</span>[] dx = {<span class=\"number\">1</span>, -<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>};</span><br><span class=\"line\">    <span class=\"type\">int</span>[] dy = {<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, -<span class=\"number\">1</span>};</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">solve</span><span class=\"params\">(<span class=\"type\">char</span>[][] board)</span> {</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> board.length;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) {</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">m</span> <span class=\"operator\">=</span> board[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">        Queue&lt;<span class=\"type\">int</span>[]&gt; queue = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;<span class=\"type\">int</span>[]&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; i++) {</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (board[i][<span class=\"number\">0</span>] == <span class=\"string\">'O'</span>) {</span><br><span class=\"line\">                queue.offer(<span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[]{i, <span class=\"number\">0</span>});</span><br><span class=\"line\">                board[i][<span class=\"number\">0</span>] = <span class=\"string\">'A'</span>;</span><br><span class=\"line\">            }</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (board[i][m - <span class=\"number\">1</span>] == <span class=\"string\">'O'</span>) {</span><br><span class=\"line\">                queue.offer(<span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[]{i, m - <span class=\"number\">1</span>});</span><br><span class=\"line\">                board[i][m - <span class=\"number\">1</span>] = <span class=\"string\">'A'</span>;</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; m - <span class=\"number\">1</span>; i++) {</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (board[<span class=\"number\">0</span>][i] == <span class=\"string\">'O'</span>) {</span><br><span class=\"line\">                queue.offer(<span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[]{<span class=\"number\">0</span>, i});</span><br><span class=\"line\">                board[<span class=\"number\">0</span>][i] = <span class=\"string\">'A'</span>;</span><br><span class=\"line\">            }</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (board[n - <span class=\"number\">1</span>][i] == <span class=\"string\">'O'</span>) {</span><br><span class=\"line\">                queue.offer(<span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[]{n - <span class=\"number\">1</span>, i});</span><br><span class=\"line\">                board[n - <span class=\"number\">1</span>][i] = <span class=\"string\">'A'</span>;</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!queue.isEmpty()) {</span><br><span class=\"line\">            <span class=\"type\">int</span>[] cell = queue.poll();</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">x</span> <span class=\"operator\">=</span> cell[<span class=\"number\">0</span>], y = cell[<span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++) {</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">mx</span> <span class=\"operator\">=</span> x + dx[i], my = y + dy[i];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mx &lt; <span class=\"number\">0</span> || my &lt; <span class=\"number\">0</span> || mx &gt;= n || my &gt;= m || board[mx][my] != <span class=\"string\">'O'</span>) {</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                }</span><br><span class=\"line\">                queue.offer(<span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[]{mx, my});</span><br><span class=\"line\">                board[mx][my] = <span class=\"string\">'A'</span>;</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; i++) {</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; m; j++) {</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (board[i][j] == <span class=\"string\">'A'</span>) {</span><br><span class=\"line\">                    board[i][j] = <span class=\"string\">'O'</span>;</span><br><span class=\"line\">                } <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (board[i][j] == <span class=\"string\">'O'</span>) {</span><br><span class=\"line\">                    board[i][j] = <span class=\"string\">'X'</span>;</span><br><span class=\"line\">                }</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure></div>\n<h4 id=\"复杂度分析-2\"><a class=\"markdownIt-Anchor\" href=\"#复杂度分析-2\">#</a> 复杂度分析</h4>\n<ul>\n<li>\n<p>时间复杂度： <code>O(n×m)</code> ，其中  <code>n</code>  和  <code>m</code>  分别为矩阵的行数和列数。广度优先搜索过程中，每一个点至多只会被标记一次。</p>\n</li>\n<li>\n<p>空间复杂度： <code>O(n×m)</code> ，其中  <code>n</code>  和  <code>m</code>  分别为矩阵的行数和列数。主要为广度优先搜索的队列的开销。</p>\n</li>\n</ul>\n</body></html>",
            "tags": [
                "矩阵",
                "深度遍历",
                "广度遍历"
            ]
        },
        {
            "id": "https://www.pswen.cn/p/638c83fa/index.html",
            "url": "https://www.pswen.cn/p/638c83fa/index.html",
            "title": "JVM调优——X参数,方法内联",
            "date_published": "2022-01-12T15:06:08.000Z",
            "content_html": "<html><head></head><body><p>JVM 的 <code>-X</code>  参数是非标准参数，在不同版本的 JVM 中，参数可能会有所不同，可以通过 <code>java -X</code>  查看非标准参数</p>\n<span id=\"more\"></span>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; java -X</span><br><span class=\"line\"></span><br><span class=\"line\">    -Xbatch           禁用后台编译</span><br><span class=\"line\">    -Xbootclasspath/a:&lt;以 : 分隔的目录和 zip/jar 文件&gt;</span><br><span class=\"line\">                      附加在引导类路径末尾</span><br><span class=\"line\">    -Xcheck:jni       对 JNI 函数执行其他检查</span><br><span class=\"line\">    -Xcomp            强制在首次调用时编译方法</span><br><span class=\"line\">    -Xdebug           不执行任何操作。为实现向后兼容而提供。</span><br><span class=\"line\">    -Xdiag            显示附加诊断消息</span><br><span class=\"line\">    -Xfuture          启用最严格的检查，预期将来的默认值。</span><br><span class=\"line\">                      此选项已过时，可能会在</span><br><span class=\"line\">                      未来发行版中删除。</span><br><span class=\"line\">    -Xint             仅解释模式执行</span><br><span class=\"line\">    -Xinternalversion</span><br><span class=\"line\">                      显示比 -version 选项更详细的</span><br><span class=\"line\">                      JVM 版本信息</span><br><span class=\"line\">    -Xlog:&lt;opts&gt;      配置或启用采用 Java 虚拟</span><br><span class=\"line\">                      机 (Java Virtual Machine, JVM) 统一记录框架进行事件记录。使用 -Xlog:help</span><br><span class=\"line\">                      可了解详细信息。</span><br><span class=\"line\">    -Xloggc:&lt;file&gt;    将 GC 状态记录在文件中（带时间戳）。</span><br><span class=\"line\">                      此选项已过时，可能会在</span><br><span class=\"line\">                      将来的发行版中删除。它将替换为 -Xlog:gc:&lt;file&gt;。</span><br><span class=\"line\">    -Xmixed           混合模式执行（默认值）</span><br><span class=\"line\">    -Xmn&lt;size&gt;        为年轻代（新生代）设置初始和最大堆大小</span><br><span class=\"line\">                      （以字节为单位）</span><br><span class=\"line\">    -Xms&lt;size&gt;        设置初始 Java 堆大小</span><br><span class=\"line\">    -Xmx&lt;size&gt;        设置最大 Java 堆大小</span><br><span class=\"line\">    -Xnoclassgc       禁用类垃圾收集</span><br><span class=\"line\">    -Xrs              减少 Java/VM 对操作系统信号的使用（请参见文档）</span><br><span class=\"line\">    -Xshare:auto      在可能的情况下使用共享类数据（默认值）</span><br><span class=\"line\">    -Xshare:off       不尝试使用共享类数据</span><br><span class=\"line\">    -Xshare:on        要求使用共享类数据，否则将失败。</span><br><span class=\"line\">                      这是一个测试选项，可能导致间歇性</span><br><span class=\"line\">                      故障。不应在生产环境中使用它。</span><br><span class=\"line\">    -XshowSettings    显示所有设置并继续</span><br><span class=\"line\">    -XshowSettings:all</span><br><span class=\"line\">                      显示所有设置并继续</span><br><span class=\"line\">    -XshowSettings:locale</span><br><span class=\"line\">                      显示所有与区域设置相关的设置并继续</span><br><span class=\"line\">    -XshowSettings:properties</span><br><span class=\"line\">                      显示所有属性设置并继续</span><br><span class=\"line\">    -XshowSettings:vm</span><br><span class=\"line\">                      显示所有与 vm 相关的设置并继续</span><br><span class=\"line\">    -XshowSettings:system</span><br><span class=\"line\">                      （仅 Linux）显示主机系统或容器</span><br><span class=\"line\">                      配置并继续</span><br><span class=\"line\">    -Xss&lt;size&gt;        设置 Java 线程堆栈大小</span><br><span class=\"line\">    -Xverify          设置字节码验证器的模式</span><br><span class=\"line\">                      请注意，选项 -Xverify:none 已过时，</span><br><span class=\"line\">                      可能会在未来发行版中删除。</span><br><span class=\"line\">    --add-reads &lt;module&gt;=&lt;target-module&gt;(,&lt;target-module&gt;)*</span><br><span class=\"line\">                      更新 &lt;module&gt; 以读取 &lt;target-module&gt;，而无论</span><br><span class=\"line\">                      模块如何声明。</span><br><span class=\"line\">                      &lt;target-module&gt; 可以是 ALL-UNNAMED，将读取所有未命名</span><br><span class=\"line\">                      模块。</span><br><span class=\"line\">    --add-exports &lt;module&gt;/&lt;package&gt;=&lt;target-module&gt;(,&lt;target-module&gt;)*</span><br><span class=\"line\">                      更新 &lt;module&gt; 以将 &lt;package&gt; 导出到 &lt;target-module&gt;，</span><br><span class=\"line\">                      而无论模块如何声明。</span><br><span class=\"line\">                      &lt;target-module&gt; 可以是 ALL-UNNAMED，将导出到所有</span><br><span class=\"line\">                      未命名模块。</span><br><span class=\"line\">    --add-opens &lt;module&gt;/&lt;package&gt;=&lt;target-module&gt;(,&lt;target-module&gt;)*</span><br><span class=\"line\">                      更新 &lt;module&gt; 以在 &lt;target-module&gt; 中打开</span><br><span class=\"line\">                      &lt;package&gt;，而无论模块如何声明。</span><br><span class=\"line\">    --illegal-access=&lt;value&gt;</span><br><span class=\"line\">                      允许或拒绝通过未命名模块中的代码对命名模块中的</span><br><span class=\"line\">                      类型成员进行访问。</span><br><span class=\"line\">                      &lt;value&gt; 为 \"deny\"、\"permit\"、\"warn\" 或 \"debug\" 之一</span><br><span class=\"line\">                      此选项将在未来发行版中删除。</span><br><span class=\"line\">    --limit-modules &lt;module name&gt;[,&lt;module name&gt;...]</span><br><span class=\"line\">                      限制可观察模块的领域</span><br><span class=\"line\">    --patch-module &lt;module&gt;=&lt;file&gt;(:&lt;file&gt;)*</span><br><span class=\"line\">                      使用 JAR 文件或目录中的类和资源</span><br><span class=\"line\">                      覆盖或增强模块。</span><br><span class=\"line\">    --source &lt;version&gt;</span><br><span class=\"line\">                      设置源文件模式中源的版本。</span><br><span class=\"line\"></span><br><span class=\"line\">这些额外选项如有更改, 恕不另行通知。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">以下选项是特定于 macOS 的选项：</span><br><span class=\"line\">    -XstartOnFirstThread</span><br><span class=\"line\">                      在第一个 (AppKit) 线程上运行 main() 方法</span><br><span class=\"line\">    -Xdock:name=&lt;application name&gt;</span><br><span class=\"line\">                      覆盖停靠栏中显示的默认应用程序名称</span><br><span class=\"line\">    -Xdock:icon=&lt;path to icon file&gt;</span><br><span class=\"line\">                     覆盖停靠栏中显示的默认图标</span><br></pre></td></tr></tbody></table></figure></div>\n<h2 id=\"-xint-xcomp与-xmixed参数\"><a class=\"markdownIt-Anchor\" href=\"#-xint-xcomp与-xmixed参数\">#</a> -Xint、-Xcomp 与 - Xmixed 参数</h2>\n<h3 id=\"-xint参数\"><a class=\"markdownIt-Anchor\" href=\"#-xint参数\">#</a> -Xint 参数</h3>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在解释模式（interpreted mode）下，-Xint标记会强制JVM执行所有的字节码，这当然会降低运行速度，通常低10倍或更多。</span><br></pre></td></tr></tbody></table></figure></div>\n<p><img src=\"/p/638c83fa/index.html20190729122640228.png\" alt=\"interpreted-mode\"></p>\n<h3 id=\"-xcomp参数\"><a class=\"markdownIt-Anchor\" href=\"#-xcomp参数\">#</a> -Xcomp 参数</h3>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Xcomp参数与-Xint正好相反，JVM在第一次使用时会把所有的字节码编译成本地代码，从而带来最大程度的优化。</span><br></pre></td></tr></tbody></table></figure></div>\n<p><img src=\"/p/638c83fa/index.html20190729122919297.png\" alt=\"compiled-mode\"></p>\n<p>然而，很多应用在使用 - Xcomp 也会有一些性能损失，当然这笔 - Xint 损失的少，原因是 - Xcomp 没有让 JVM 启用 JIT 编译器的全部功能。JIT 编译器可以对是否需要编译做出判断。如果所有代码都需要进行编译的话，对于一些只执行一次的代码就没有意义了。</p>\n<h3 id=\"-xmixed参数\"><a class=\"markdownIt-Anchor\" href=\"#-xmixed参数\">#</a> -Xmixed 参数</h3>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Xmixed是混合模式，将解释模式和变异模式进行混合使用，有JVM自己决定，这是JVM的默认模式，也是推荐模式</span><br></pre></td></tr></tbody></table></figure></div>\n<p><img src=\"/p/638c83fa/index.html2019072913573773.png\" alt=\"mixed-model\"></p>\n<h2 id=\"jvm方法内联优化\"><a class=\"markdownIt-Anchor\" href=\"#jvm方法内联优化\">#</a> JVM 方法内联优化</h2>\n<h3 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\">#</a> 前言</h3>\n<p>在日常中工作中，我们时不时会代码进行一些优化，比如用新的算法，简化计算逻辑，减少计算量等。对于 java 程序来说，除了开发者本身对代码优化之外，还有一个 \"人\" 也在背后默默的优化我们的代码，这个 \"人\" 就是 jvm。jvm 会帮我们分析出热点代码，优化代码逻辑。其中 jvm 最常做的优化之一就是：方法内联优化。</p>\n<h3 id=\"方法内联\"><a class=\"markdownIt-Anchor\" href=\"#方法内联\">#</a> 方法内联</h3>\n<p>什么是方法内联？又可以叫做函数内联，java 中方法可等同于其它语言中的函数。关于方法内联维基百科上面解释是：</p>\n<blockquote>\n<p>在计算机科学中，内联函数（有时称作在线函数或编译时期展开函数）是一种编程语言结构，用来建议编译器对一些特殊函数进行内联扩展（有时称作在线扩展）；也就是说<strong>建议编译器将指定的函数体插入并取代每一处调用该函数的地方（上下文），从而节省了每次调用函数带来的额外时间开支。</strong></p>\n</blockquote>\n<p>简单通俗的讲就是把方法内部调用的其它方法的逻辑，嵌入到自身的方法中去，变成自身的一部分，之后不再调用该方法，从而节省调用函数带来的额外开支。</p>\n<h3 id=\"函数调用开销\"><a class=\"markdownIt-Anchor\" href=\"#函数调用开销\">#</a> 函数调用开销</h3>\n<p>之所以出现方法内联是因为函数调用除了执行自身逻辑的开销外，还有一些不为人知的额外开销。这部分额外的开销主要来自方法栈帧的生成、参数字段的压入、栈帧的弹出、还有指令执行地址的跳转。比如有下面这样代码：</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"JAVA\"><figure class=\"iseeu highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">function_A</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span>{</span><br><span class=\"line\">    <span class=\"comment\">//do something</span></span><br><span class=\"line\">    function_B(a,b);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">function_B</span><span class=\"params\">(<span class=\"type\">int</span> c, <span class=\"type\">int</span> d)</span>{</span><br><span class=\"line\">    <span class=\"comment\">//do something</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span>{</span><br><span class=\"line\">     function_A(<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure></div>\n<p>则代码的执行过程如下：</p>\n<p><img src=\"/p/638c83fa/index.html247487dfbaf1ec956441e9e5e2f85817_1440w.jpg\" alt=\"img\"></p>\n<p>所以如果 java 中方法调用嵌套过多或者方法过多，这种额外的开销就越多。</p>\n<p>试想一下想 get/set 这种方法调用：</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"JAVA\"><figure class=\"iseeu highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getI</span><span class=\"params\">()</span> {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setI</span><span class=\"params\">(<span class=\"type\">int</span> i)</span> {</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.i = i;</span><br><span class=\"line\">} </span><br></pre></td></tr></tbody></table></figure></div>\n<p>很可能自身执行逻辑的开销还比不上为了调用这个方法的额外开锁。如果类似的方法被频繁的调用，则真正相对执行效率就会很低，虽然这类方法的执行时间很短。这也是为什么 jvm 会在热点代码中执行方法内联的原因，这样的话就可以省去调用调用函数带来的额外开支。</p>\n<p>这里举个内联的可能形式：</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"JAVA\"><figure class=\"iseeu highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span>  <span class=\"title function_\">add</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b , <span class=\"type\">int</span> c, <span class=\"type\">int</span> d)</span>{</span><br><span class=\"line\">      <span class=\"keyword\">return</span> add(a, b) + add(c, d);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">add</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure></div>\n<p>内联之后：</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"JAVA\"><figure class=\"iseeu highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span>  <span class=\"title function_\">add</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b , <span class=\"type\">int</span> c, <span class=\"type\">int</span> d)</span>{</span><br><span class=\"line\">      <span class=\"keyword\">return</span> a + b + c + d;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure></div>\n<p>这样除了本身的相加逻辑的开销，比内联前减少了二次调用函数带来的额外开销。</p>\n<h3 id=\"内联条件\"><a class=\"markdownIt-Anchor\" href=\"#内联条件\">#</a> 内联条件</h3>\n<p>一个方法如果满足以下条件就很可能被 jvm 内联。</p>\n<p>1、热点代码： 如果一个方法的执行频率很高就表示优化的潜在价值就越大。那代码执行多少次才能确定为热点代码？这是根据编译器的编译模式来决定的。如果是客户端编译模式则次数是 1500，服务端编译模式是 10000。次数的大小可以通过 - XX:CompileThreshold 来调整。</p>\n<p>2、方法体不能太大：jvm 中被内联的方法会编译成机器码放在 code cache 中。如果方法体太大，则能缓存热点方法就少，反而会影响性能。</p>\n<p>3、如果希望方法被内联，尽量用 private、static、final 修饰，这样 jvm 可以直接内联。如果是 public、protected 修饰方法 jvm 则需要进行类型判断，因为这些方法可以被子类继承和覆盖，jvm 需要判断内联究竟内联是父类还是其中某个子类的方法。</p>\n<blockquote>\n<p>所以了解 jvm 方法内联机制之后，会有助于我们工作中写出能让 jvm 更容易优化的代码，有助于提升程序的性能。</p>\n</blockquote>\n</body></html>",
            "tags": [
                "jvm调优",
                "混合模式",
                "解释模式",
                "纯编译模式"
            ]
        },
        {
            "id": "https://www.pswen.cn/p/f883163f/index.html",
            "url": "https://www.pswen.cn/p/f883163f/index.html",
            "title": "买卖股票的最佳时机 II——LeetCode122",
            "date_published": "2022-01-06T15:28:13.000Z",
            "content_html": "<html><head></head><body><h1 id=\"题目描述\"><a class=\"markdownIt-Anchor\" href=\"#题目描述\">#</a> 题目描述</h1>\n<p>给定一个数组 prices ，其中&nbsp;prices [i] 是一支给定股票第 i 天的价格。</p>\n<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>\n<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>\n<span id=\"more\"></span>\n<p>示例 1:</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: prices = [7,1,5,3,6,4]</span><br><span class=\"line\">输出: 7</span><br></pre></td></tr></tbody></table></figure></div>\n<p>解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出，这笔交易所能获得利润 = 5-1 = 4 。<br>\n随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，这笔交易所能获得利润 = 6-3 = 3 。<br>\n&nbsp;<br>\n示例 2:</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: prices = [1,2,3,4,5]</span><br><span class=\"line\">输出: 4</span><br></pre></td></tr></tbody></table></figure></div>\n<p>解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出，这笔交易所能获得利润 = 5-1 = 4 。<br>\n注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</p>\n<p>示例&nbsp;3:</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: prices = [7,6,4,3,1]</span><br><span class=\"line\">输出: 0</span><br></pre></td></tr></tbody></table></figure></div>\n<p>解释：在这种情况下，没有交易完成，所以最大利润为 0。</p>\n<p>提示：<br>\n]<br>\n1 &lt;= prices.length &lt;= 3 * 10^4<br>\n0 &lt;= prices[i] &lt;= 10^4</p>\n<h1 id=\"解题\"><a class=\"markdownIt-Anchor\" href=\"#解题\">#</a> 解题</h1>\n<h2 id=\"解法一动态规划\"><a class=\"markdownIt-Anchor\" href=\"#解法一动态规划\">#</a> 解法一：动态规划</h2>\n<h3 id=\"思路\"><a class=\"markdownIt-Anchor\" href=\"#思路\">#</a> 思路</h3>\n<p>虑到「不能同时参与多笔交易」，因此每天交易结束后只可能存在手里有一支股票或者没有股票的状态。</p>\n<p>定义状态 <code>dp[i][0]</code>  表示第 i 天交易完后手里没有股票的最大利润， <code>dp[i][1]</code>  表示第 i 天交易完后手里持有一支股票的最大利润（i 从 0 开始）。(<strong>定义状态</strong>)</p>\n<p>考虑 <code>dp[i][0]</code>  的转移方程，如果这一天交易完后手里没有股票，那么可能的转移状态为前一天已经没有股票，即  <code>dp[i−1][0]</code> ，或者前一天结束的时候手里持有一支股票，即  <code>dp[i−1][1]</code> ，这时候我们要将其卖出，并获得  <code>prices[i]</code>  的收益。因此为了收益最大化，我们列出如下的转移方程：</p>\n<p><code>dp[i][0] = max{ dp[i−1][0] , dp[i−1][1] + prices[i]}</code></p>\n<p>再来考虑 <code>dp[i][1]</code> ，按照同样的方式考虑转移状态，那么可能的转移状态为前一天已经持有一支股票，即 <code>dp[i−1][1]</code> ，或者前一天结束时还没有股票，即  <code>dp[i−1][0]</code> ，这时候我们要将其买入，并减少 <code>prices[i]</code>  的收益。可以列出如下的转移方程：</p>\n<p><code>dp[i][1] = max{ dp[i−1][1], dp[i−1][0]−prices[i] }</code></p>\n<p>对于初始状态，根据状态定义我们可以知道第 00 天交易结束的时候  <code>dp[0][0]=0</code> ， <code>dp[0][1]=−prices[0]</code> 。</p>\n<p>因此，我们只要从前往后依次计算状态即可。由于全部交易结束后，持有股票的收益一定低于不持有股票的收益，因此这时候  <code>dp[n−1][0]</code>  的收益必然是大于 <code>dp[n−1][1]</code>  的，最后的答案即为  <code>dp[n−1][0]</code> 。</p>\n<h3 id=\"解题-2\"><a class=\"markdownIt-Anchor\" href=\"#解题-2\">#</a> 解题</h3>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"JAVA\"><figure class=\"iseeu highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> {</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxProfit</span><span class=\"params\">(<span class=\"type\">int</span>[] prices)</span> {</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> prices.length;</span><br><span class=\"line\">        <span class=\"comment\">// 状态定义 x为天数  y为0为当天不持有 1为当天持有</span></span><br><span class=\"line\">        <span class=\"type\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n][<span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"comment\">// 定义起始状态</span></span><br><span class=\"line\">        <span class=\"comment\">// 第一天 不持有，不花钱 收益为0</span></span><br><span class=\"line\">        dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 第一天 持有，花钱 收益为当天买股票的钱</span></span><br><span class=\"line\">        dp[<span class=\"number\">0</span>][<span class=\"number\">1</span>] = - prices[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"comment\">// 从第二天开始递推哈</span></span><br><span class=\"line\">        <span class=\"comment\">//</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">d</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; d &lt; n; d++) {</span><br><span class=\"line\">            <span class=\"comment\">// 第二天不持有股票：</span></span><br><span class=\"line\">            <span class=\"comment\">// 第一天不持有股票的收益 + （没买）0  |  第一天持有股票 + （卖出）第二天价格 ；</span></span><br><span class=\"line\">            dp[d][<span class=\"number\">0</span>] = Math.max(dp[d-<span class=\"number\">1</span>][<span class=\"number\">0</span>], dp[d-<span class=\"number\">1</span>][<span class=\"number\">1</span>] + prices[d]);</span><br><span class=\"line\">            <span class=\"comment\">// 第二天持有股票：</span></span><br><span class=\"line\">            <span class=\"comment\">// 第一天不持有股票的收益 + 买入第二天价格  |  第一天持有股票 + 没买也没卖 ；</span></span><br><span class=\"line\">            dp[d][<span class=\"number\">1</span>] = Math.max(dp[d-<span class=\"number\">1</span>][<span class=\"number\">0</span>] - prices[d], dp[d-<span class=\"number\">1</span>][<span class=\"number\">1</span>]);</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"comment\">// 持有股票的收益必定小于不持有股票</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n-<span class=\"number\">1</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure></div>\n<p>注意到上面的状态转移方程中，每一天的状态只与前一天的状态有关，而与更早的状态都无关，因此我们不必存储这些无关的状态，只需要将 <code>dp[i−1][0] </code> 和 <code>dp[i−1][1]</code>  存放在两个变量中，通过它们计算出 <code>dp[i][0]</code>  和 <code>dp[i][1]</code>  并存回对应的变量，以便于第 <code>i+1</code>  天的状态转移即可。</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"JAVA\"><figure class=\"iseeu highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> {</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxProfit</span><span class=\"params\">(<span class=\"type\">int</span>[] prices)</span> {</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> prices.length;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">dp0</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, dp1 = -prices[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; n; ++i) {</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">newDp0</span> <span class=\"operator\">=</span> Math.max(dp0, dp1 + prices[i]);</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">newDp1</span> <span class=\"operator\">=</span> Math.max(dp1, dp0 - prices[i]);</span><br><span class=\"line\">            dp0 = newDp0;</span><br><span class=\"line\">            dp1 = newDp1;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp0;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure></div>\n<h3 id=\"复杂度分析\"><a class=\"markdownIt-Anchor\" href=\"#复杂度分析\">#</a> 复杂度分析</h3>\n<ul>\n<li>\n<p>时间复杂度： <code>O(n)</code> ，其中 n 为数组的长度。一共有 2n 个状态，每次状态转移的时间复杂度为  <code>O(1)</code> ，因此时间复杂度为 <code>O(2n)=O(n)</code> 。</p>\n</li>\n<li>\n<p>空间复杂度： <code>O(n)</code> 。我们需要开辟 <code>O(n)</code>  空间存储动态规划中的所有状态。如果使用空间优化，空间复杂度可以优化至  <code>O(1)</code> 。</p>\n</li>\n</ul>\n<h2 id=\"解法二贪心\"><a class=\"markdownIt-Anchor\" href=\"#解法二贪心\">#</a> 解法二：贪心</h2>\n<h3 id=\"思路-2\"><a class=\"markdownIt-Anchor\" href=\"#思路-2\">#</a> 思路</h3>\n<h3 id=\"解题-3\"><a class=\"markdownIt-Anchor\" href=\"#解题-3\">#</a> 解题</h3>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"JAVA\"><figure class=\"iseeu highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> {</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxProfit</span><span class=\"params\">(<span class=\"type\">int</span>[] prices)</span> {</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">ans</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> prices.length;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; n; ++i) {</span><br><span class=\"line\">            ans += Math.max(<span class=\"number\">0</span>, prices[i] - prices[i - <span class=\"number\">1</span>]);</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure></div>\n<h3 id=\"复杂度分析-2\"><a class=\"markdownIt-Anchor\" href=\"#复杂度分析-2\">#</a> 复杂度分析</h3>\n</body></html>",
            "tags": [
                "leetcode",
                "算法",
                "贪心",
                "动态规划"
            ]
        },
        {
            "id": "https://www.pswen.cn/p/7d31a8bc/index.html",
            "url": "https://www.pswen.cn/p/7d31a8bc/index.html",
            "title": "路径总和 II——LeetCode113",
            "date_published": "2022-01-05T14:27:28.000Z",
            "content_html": "<html><head></head><body><h1 id=\"题目描述\"><a class=\"markdownIt-Anchor\" href=\"#题目描述\">#</a> 题目描述</h1>\n<p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p>\n<p>叶子节点 是指没有子节点的节点。</p>\n<span id=\"more\"></span>\n<p>示例 1：</p>\n<p><img src=\"/p/7d31a8bc/index.htmlpathsumii1.jpg\" alt=\"\"></p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22</span><br><span class=\"line\">输出：[[5,4,11,2],[5,8,4,5]]</span><br></pre></td></tr></tbody></table></figure></div>\n<p>示例 2：</p>\n<p><img src=\"/p/7d31a8bc/index.htmlpathsum2.jpg\" alt=\"img\"></p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：root = [1,2,3], targetSum = 5</span><br><span class=\"line\">输出：[]</span><br></pre></td></tr></tbody></table></figure></div>\n<p>示例 3：</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：root = [1,2], targetSum = 0</span><br><span class=\"line\">输出：[]</span><br></pre></td></tr></tbody></table></figure></div>\n<p>提示：</p>\n<p>树中节点总数在范围 [0, 5000] 内<br>\n - 1000 &lt;= Node.val &lt;= 1000<br>\n-1000 &lt;= targetSum &lt;= 1000</p>\n<h1 id=\"解题\"><a class=\"markdownIt-Anchor\" href=\"#解题\">#</a> 解题</h1>\n<h2 id=\"dfs解法\"><a class=\"markdownIt-Anchor\" href=\"#dfs解法\">#</a> dfs 解法</h2>\n<ul>\n<li>\n<p>前言<br>\n注意到本题的要求是，找到所有满足从「根节点」到某个「叶子节点」经过的路径上的节点之和等于目标和的路径。核心思想是对树进行一次遍历，在遍历时记录从根节点到当前节点的路径和，以防止重复计算。</p>\n</li>\n<li>\n<p>思路及算法</p>\n<p>我们可以采用深度优先搜索的方式，枚举每一条从根节点到叶子节点的路径。当我们遍历到叶子节点，且此时路径和恰为目标和时，我们就找到了一条满足条件的路径。</p>\n</li>\n<li>\n<p>代码实现</p>\n</li>\n</ul>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"JAVA\"><figure class=\"iseeu highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> {</span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; ret = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class=\"line\">    Deque&lt;Integer&gt; path = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;Integer&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">pathSum</span><span class=\"params\">(TreeNode root, <span class=\"type\">int</span> targetSum)</span> {</span><br><span class=\"line\">        dfs(root, targetSum);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">dfs</span><span class=\"params\">(TreeNode root, <span class=\"type\">int</span> targetSum)</span> {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) {</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        path.offerLast(root.val);</span><br><span class=\"line\">        targetSum -= root.val;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root.left == <span class=\"literal\">null</span> &amp;&amp; root.right == <span class=\"literal\">null</span> &amp;&amp; targetSum == <span class=\"number\">0</span>) {</span><br><span class=\"line\">            ret.add(<span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;Integer&gt;(path));</span><br><span class=\"line\">        }</span><br><span class=\"line\">        dfs(root.left, targetSum);</span><br><span class=\"line\">        dfs(root.right, targetSum);</span><br><span class=\"line\">        path.pollLast();</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure></div>\n<ul>\n<li>复杂度分析</li>\n</ul>\n<p>复杂度分析</p>\n<p>时间复杂度： <code>O(N^2)</code> ・，其中 N 是树的节点数。在最坏情况下，树的上半部分为链状，下半部分为完全二叉树，并且从根节点到每一个叶子节点的路径都符合题目要求。此时，路径的数目为  <code>O(N)</code> ，并且每一条路径的节点个数也为 O (N) O (N)，因此要将这些路径全部添加进答案中，时间复杂度为  <code>O(N^2)</code></p>\n<p>空间复杂度： <code>O(N)</code> ，其中 N 是树的节点数。空间复杂度主要取决于栈空间的开销，栈中的元素个数不会超过树的节点数。</p>\n<h2 id=\"bfs解法\"><a class=\"markdownIt-Anchor\" href=\"#bfs解法\">#</a> bfs 解法</h2>\n<ul>\n<li>思路及算法</li>\n</ul>\n<p>我们也可以采用广度优先搜索的方式，遍历这棵树。当我们遍历到叶子节点，且此时路径和恰为目标和时，我们就找到了一条满足条件的路径。</p>\n<p>为了节省空间，我们使用哈希表记录树中的每一个节点的父节点。每次找到一个满足条件的节点，我们就从该节点出发不断向父节点迭代，即可还原出从根节点到当前节点的路径。</p>\n<ul>\n<li>代码实现</li>\n</ul>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"JAVA\"><figure class=\"iseeu highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> {</span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; ret = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class=\"line\">    Map&lt;TreeNode, TreeNode&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;TreeNode, TreeNode&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">pathSum</span><span class=\"params\">(TreeNode root, <span class=\"type\">int</span> targetSum)</span> {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) {</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        Queue&lt;TreeNode&gt; queueNode = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class=\"line\">        Queue&lt;Integer&gt; queueSum = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;Integer&gt;();</span><br><span class=\"line\">        queueNode.offer(root);</span><br><span class=\"line\">        queueSum.offer(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!queueNode.isEmpty()) {</span><br><span class=\"line\">            <span class=\"type\">TreeNode</span> <span class=\"variable\">node</span> <span class=\"operator\">=</span> queueNode.poll();</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">rec</span> <span class=\"operator\">=</span> queueSum.poll() + node.val;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node.left == <span class=\"literal\">null</span> &amp;&amp; node.right == <span class=\"literal\">null</span>) {</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (rec == targetSum) {</span><br><span class=\"line\">                    getPath(node);</span><br><span class=\"line\">                }</span><br><span class=\"line\">            } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (node.left != <span class=\"literal\">null</span>) {</span><br><span class=\"line\">                    map.put(node.left, node);</span><br><span class=\"line\">                    queueNode.offer(node.left);</span><br><span class=\"line\">                    queueSum.offer(rec);</span><br><span class=\"line\">                }</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (node.right != <span class=\"literal\">null</span>) {</span><br><span class=\"line\">                    map.put(node.right, node);</span><br><span class=\"line\">                    queueNode.offer(node.right);</span><br><span class=\"line\">                    queueSum.offer(rec);</span><br><span class=\"line\">                }</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getPath</span><span class=\"params\">(TreeNode node)</span> {</span><br><span class=\"line\">        List&lt;Integer&gt; temp = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;Integer&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (node != <span class=\"literal\">null</span>) {</span><br><span class=\"line\">            temp.add(node.val);</span><br><span class=\"line\">            node = map.get(node);</span><br><span class=\"line\">        }</span><br><span class=\"line\">        Collections.reverse(temp);</span><br><span class=\"line\">        ret.add(<span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;Integer&gt;(temp));</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure></div>\n<ul>\n<li>复杂度分析</li>\n</ul>\n<p>时间复杂度： <code>O(N^2)</code> ，其中 NN 是树的节点数。分析思路与方法一相同。</p>\n<p>空间复杂度： <code>O(N)</code> ，其中 NN 是树的节点数。空间复杂度主要取决于哈希表和队列空间的开销，哈希表需要存储除根节点外的每个节点的父节点，队列中的元素个数不会超过树的节点数</p>\n</body></html>",
            "tags": [
                "leetcode",
                "树",
                "dfs",
                "bfs"
            ]
        },
        {
            "id": "https://www.pswen.cn/p/ab179abd/index.html",
            "url": "https://www.pswen.cn/p/ab179abd/index.html",
            "title": "复原IP地址——LeetCode93",
            "date_published": "2022-01-04T13:58:27.000Z",
            "content_html": "<html><head></head><body><h1 id=\"题目描述\"><a class=\"markdownIt-Anchor\" href=\"#题目描述\">#</a> 题目描述</h1>\n<p>有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。</p>\n<p>例如：“0.1.2.201” 和 “192.168.1.1” 是 有效 IP 地址，但是 “0.011.255.245”、“192.168.1.312” 和 “192.168@1.1” 是 无效 IP 地址。<br>\n给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 ‘.’ 来形成。你不能重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。</p>\n<span id=\"more\"></span>\n<h2 id=\"用例\"><a class=\"markdownIt-Anchor\" href=\"#用例\">#</a> 用例</h2>\n<p>示例 1：</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = \"25525511135\"</span><br><span class=\"line\">输出：[\"255.255.11.135\",\"255.255.111.35\"]</span><br></pre></td></tr></tbody></table></figure></div>\n<p>示例 2：</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = \"0000\"</span><br><span class=\"line\">输出：[\"0.0.0.0\"]</span><br></pre></td></tr></tbody></table></figure></div>\n<p>示例 3：</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = \"1111\"</span><br><span class=\"line\">输出：[\"1.1.1.1\"]</span><br></pre></td></tr></tbody></table></figure></div>\n<p>示例 4：</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = \"010010\"</span><br><span class=\"line\">输出：[\"0.10.0.10\",\"0.100.1.0\"]</span><br></pre></td></tr></tbody></table></figure></div>\n<p>示例 5：</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = \"101023\"</span><br><span class=\"line\">输出：[\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]</span><br></pre></td></tr></tbody></table></figure></div>\n<p>提示：</p>\n<p>0 &lt;= s.length &lt;= 20<br>\ns 仅由数字组成</p>\n<h1 id=\"解题\"><a class=\"markdownIt-Anchor\" href=\"#解题\">#</a> 解题</h1>\n<h2 id=\"解题思路\"><a class=\"markdownIt-Anchor\" href=\"#解题思路\">#</a> 解题思路</h2>\n<p>由于我们需要找出所有可能复原出的 IP 地址，因此可以考虑使用<strong>回溯</strong>的方法，对<strong>所有可能的字符串分隔方式</strong>进行搜索，并筛选出满足要求的作为答案。</p>\n<p>设题目中给出的字符串为 s。我们用递归函数  <code>dfs(segId,segStart)</code>  表示我们正在从 <code>s[segStart] </code> 的位置开始，搜索 IP 地址中的第 segId 段，其中 <code>segId∈{0,1,2,3}</code> 。由于 IP 地址的每一段必须是  <code>[0, 255] </code> 中的整数，因此我们从 segStart 开始，从小到大依次枚举当前这一段 IP 地址的结束位置 segEnd。如果满足要求，就递归地进行下一段搜索，调用递归函数 <code>dfs(segId+1,segEnd+1)</code> 。</p>\n<p>特别地，由于 IP 地址的每一段不能有前导零，因此如果  <code>s[segStart]</code>  等于字符 0，那么 IP 地址的第 segId 段只能为 0，需要作为特殊情况进行考虑。</p>\n<p>在搜索的过程中，如果我们已经得到了全部的 4 段 IP 地址（即 segId=4），并且遍历完了整个字符串（即  <code>segStart=∣s∣</code> ，其中  <code>|s|</code>  表示字符串 s 的长度），那么就复原出了一种满足题目要求的 IP 地址，我们将其加入答案。在其它的时刻，如果提前遍历完了整个字符串，那么我们需要结束搜索，回溯到上一步。</p>\n<h2 id=\"代码实现\"><a class=\"markdownIt-Anchor\" href=\"#代码实现\">#</a> 代码实现</h2>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"JAVA\"><figure class=\"iseeu highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> {</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">SEG_COUNT</span> <span class=\"operator\">=</span> <span class=\"number\">4</span>;</span><br><span class=\"line\">    List&lt;String&gt; ans = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;String&gt;();</span><br><span class=\"line\">    <span class=\"type\">int</span>[] segments = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[SEG_COUNT];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;String&gt; <span class=\"title function_\">restoreIpAddresses</span><span class=\"params\">(String s)</span> {</span><br><span class=\"line\">        segments = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[SEG_COUNT];</span><br><span class=\"line\">        dfs(s, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">dfs</span><span class=\"params\">(String s, <span class=\"type\">int</span> segId, <span class=\"type\">int</span> segStart)</span> {</span><br><span class=\"line\">        <span class=\"comment\">// 如果找到了 4 段 IP 地址并且遍历完了字符串，那么就是一种答案</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (segId == SEG_COUNT) {</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (segStart == s.length()) {</span><br><span class=\"line\">                <span class=\"type\">StringBuffer</span> <span class=\"variable\">ipAddr</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuffer</span>();</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; SEG_COUNT; ++i) {</span><br><span class=\"line\">                    ipAddr.append(segments[i]);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (i != SEG_COUNT - <span class=\"number\">1</span>) {</span><br><span class=\"line\">                        ipAddr.append(<span class=\"string\">'.'</span>);</span><br><span class=\"line\">                    }</span><br><span class=\"line\">                }</span><br><span class=\"line\">                ans.add(ipAddr.toString());</span><br><span class=\"line\">            }</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果还没有找到 4 段 IP 地址就已经遍历完了字符串，那么提前回溯</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (segStart == s.length()) {</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 由于不能有前导零，如果当前数字为 0，那么这一段 IP 地址只能为 0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.charAt(segStart) == <span class=\"string\">'0'</span>) {</span><br><span class=\"line\">            segments[segId] = <span class=\"number\">0</span>;</span><br><span class=\"line\">            dfs(s, segId + <span class=\"number\">1</span>, segStart + <span class=\"number\">1</span>);</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 一般情况，枚举每一种可能性并递归</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">addr</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">segEnd</span> <span class=\"operator\">=</span> segStart; segEnd &lt; s.length(); ++segEnd) {</span><br><span class=\"line\">            addr = addr * <span class=\"number\">10</span> + (s.charAt(segEnd) - <span class=\"string\">'0'</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (addr &gt; <span class=\"number\">0</span> &amp;&amp; addr &lt;= <span class=\"number\">0xFF</span>) {</span><br><span class=\"line\">                segments[segId] = addr;</span><br><span class=\"line\">                dfs(s, segId + <span class=\"number\">1</span>, segEnd + <span class=\"number\">1</span>);</span><br><span class=\"line\">            } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure></div>\n<h2 id=\"复杂度分析\"><a class=\"markdownIt-Anchor\" href=\"#复杂度分析\">#</a> 复杂度分析</h2>\n<p>复杂度分析</p>\n<p>我们用 SEG_COUNT=4 表示 IP 地址的段数。</p>\n<p>时间复杂度： <code>O(3^SEG_COUNT × ∣s∣)</code> 。由于 IP 地址的每一段的位数不会超过 3，因此在递归的每一层，我们最多只会深入到下一层的 33 种情况。由于 SEG_COUNT=4，对应着递归的最大层数。如果我们复原出了一种满足题目要求的 IP 地址，那么需要  <code>O(∣s∣) </code> 的时间将其加入答案数组中，因此总时间复杂度为 <code>O(3 ^SEG_COUNT ×∣s∣)</code> 。</p>\n<p>空间复杂度： <code>O(SEG_COUNT)</code> ，这里只计入除了用来存储答案数组以外的额外空间复杂度。递归使用的空间与递归的最大深度 \\text {SEG_COUNT} SEG_COUNT 成正比。并且在上面的代码中，我们只额外使用了长度为  <code>SEG_COUNT</code>  的数组  <code>segments</code>  存储已经搜索过的 IP 地址，因此空间复杂度为 <code>O(SEG_COUNT)</code> 。</p>\n</body></html>",
            "tags": [
                "leetcode",
                "算法",
                "回溯"
            ]
        },
        {
            "id": "https://www.pswen.cn/p/dfd6ab93/index.html",
            "url": "https://www.pswen.cn/p/dfd6ab93/index.html",
            "title": "最长回文子串——Leetcode5",
            "date_published": "2022-01-03T06:28:19.000Z",
            "content_html": "<html><head></head><body><h1 id=\"题目描述\"><a class=\"markdownIt-Anchor\" href=\"#题目描述\">#</a> 题目描述</h1>\n<p>给你一个字符串 s，找到 s 中最长的回文子串。</p>\n<span id=\"more\"></span>\n<p>示例 1：</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = \"babad\"</span><br><span class=\"line\">输出：\"bab\"</span><br><span class=\"line\">解释：\"aba\" 同样是符合题意的答案。</span><br></pre></td></tr></tbody></table></figure></div>\n<p>示例 2：</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = \"cbbd\"</span><br><span class=\"line\">输出：\"bb\"</span><br></pre></td></tr></tbody></table></figure></div>\n<p>示例 3：</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = \"a\"</span><br><span class=\"line\">输出：\"a\"</span><br></pre></td></tr></tbody></table></figure></div>\n<p>示例 4：</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = \"ac\"</span><br><span class=\"line\">输出：\"a\"</span><br></pre></td></tr></tbody></table></figure></div>\n<p>提示：</p>\n<p><code>1 &lt;= s.length &lt;= 1000</code> <br>\ns 仅由数字和英文字母（大写和 / 或小写）组成</p>\n<h1 id=\"解题\"><a class=\"markdownIt-Anchor\" href=\"#解题\">#</a> 解题</h1>\n<h2 id=\"解题思路\"><a class=\"markdownIt-Anchor\" href=\"#解题思路\">#</a> 解题思路</h2>\n<p>对于一个子串而言，如果它是回文串，并且长度大于 22，那么将它首尾的两个字母去除之后，它仍然是个回文串。例如对于字符串 “ababa”，如果我们已经知道 “bab” 是回文串，那么 “ababa” 一定是回文串，这是因为它的首尾两个字母都是 “a”。</p>\n<p>根据这样的思路，我们就可以用动态规划的方法解决本题。我们用  <code>P(i,j) </code> 表示字符串 s 的第 i 到 j 个字母组成的串（下文表示成  <code>s[i:j]</code> ）是否为回文串：如果字符串 s 从 i 到 j 是回文串，那么 <code>P(i,j)= true</code> ，否则为 <code>P(i,j)= true</code> ；</p>\n<p>这里的「否」包含两种可能性：</p>\n<ul>\n<li>\n<p><code>s[i,j]</code>  本身不是一个回文串；</p>\n</li>\n<li>\n<p><code>i&gt;j</code> ，此时  <code>s[i,j]</code>  本身不合法。</p>\n</li>\n</ul>\n<p>那么我们就可以写出动态规划的状态转移方程：</p>\n<p><img src=\"/p/dfd6ab93/index.htmlimage-20220104210656306.png\" alt=\"状态转移方程\"></p>\n<p>也就是说，只有  <code>s[i+1:j−1] </code> 是回文串，并且  <code>s</code>  的第 <code>i</code>  和  <code>j</code>  个字母相同时， <code>s[i:j]</code>  才会是回文串。</p>\n<p>上文的所有讨论是建立在子串长度大于 2 的前提之上的，我们还需要考虑动态规划中的<strong>边界条件</strong>，即子串的长度为 1 或 2。</p>\n<ul>\n<li>\n<p>对于长度为 1 的子串，它显然是个回文串；</p>\n</li>\n<li>\n<p>对于长度为 2 的子串，只要它的两个字母相同，它就是一个回文串。</p>\n</li>\n</ul>\n<p>因此我们就可以写出动态规划的边界条件：</p>\n<p><img src=\"/p/dfd6ab93/index.htmlimage-20220104210730308.png\" alt=\"边界条件\"></p>\n<p>根据这个思路，我们就可以完成动态规划了，最终的答案即为所有 <code> P(i, j) = true</code>  中  <code>j−i+1</code> （即子串长度）的最大值。注意：在状态转移方程中，我们是从长度较短的字符串向长度较长的字符串进行转移的，因此一定要注意动态规划的循环顺序。</p>\n<h2 id=\"代码实现\"><a class=\"markdownIt-Anchor\" href=\"#代码实现\">#</a> 代码实现</h2>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"JAVA\"><figure class=\"iseeu highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> {</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">longestPalindrome</span><span class=\"params\">(String s)</span> {</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> s.length();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (len &lt; <span class=\"number\">2</span>) {</span><br><span class=\"line\">            <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">maxLen</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">begin</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// dp[i][j] 表示 s[i..j] 是否是回文串</span></span><br><span class=\"line\">        <span class=\"type\">boolean</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">boolean</span>[len][len];</span><br><span class=\"line\">        <span class=\"comment\">// 初始化：所有长度为 1 的子串都是回文串</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; len; i++) {</span><br><span class=\"line\">            dp[i][i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">char</span>[] charArray = s.toCharArray();</span><br><span class=\"line\">        <span class=\"comment\">// 递推开始</span></span><br><span class=\"line\">        <span class=\"comment\">// 先枚举子串长度</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">L</span> <span class=\"operator\">=</span> <span class=\"number\">2</span>; L &lt;= len; L++) {</span><br><span class=\"line\">            <span class=\"comment\">// 枚举左边界，左边界的上限设置可以宽松一些</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; len; i++) {</span><br><span class=\"line\">                <span class=\"comment\">// 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得</span></span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> L + i - <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"comment\">// 如果右边界越界，就可以退出当前循环</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (j &gt;= len) {</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                }</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (charArray[i] != charArray[j]) {</span><br><span class=\"line\">                    dp[i][j] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">                } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (j - i &lt; <span class=\"number\">3</span>) {</span><br><span class=\"line\">                        dp[i][j] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                    } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">                        dp[i][j] = dp[i + <span class=\"number\">1</span>][j - <span class=\"number\">1</span>];</span><br><span class=\"line\">                    }</span><br><span class=\"line\">                }</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (dp[i][j] &amp;&amp; j - i + <span class=\"number\">1</span> &gt; maxLen) {</span><br><span class=\"line\">                    maxLen = j - i + <span class=\"number\">1</span>;</span><br><span class=\"line\">                    begin = i;</span><br><span class=\"line\">                }</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s.substring(begin, begin + maxLen);</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure></div>\n<h2 id=\"复杂度分析\"><a class=\"markdownIt-Anchor\" href=\"#复杂度分析\">#</a> 复杂度分析</h2>\n<p>时间复杂度： <code>O(n^2) </code> 其中 n 是字符串的长度。动态规划的状态总数为  <code>O(n^2)</code>  对于每个状态，我们需要转移的时间为  <code>O(1)</code> 。</p>\n<p>空间复杂度： <code>O(n^2)</code> ，即存储动态规划状态需要的空间。</p>\n</body></html>",
            "tags": [
                "leetcode",
                "算法",
                "动态规划"
            ]
        }
    ]
}