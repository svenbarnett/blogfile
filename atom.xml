<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>人间日常</title>
  
  <subtitle>所行皆过往，所愿皆成真</subtitle>
  <link href="https://www.pswen.cn/atom.xml" rel="self"/>
  
  <link href="https://www.pswen.cn/"/>
  <updated>2023-02-23T15:19:10.371Z</updated>
  <id>https://www.pswen.cn/</id>
  
  <author>
    <name>SIWEN.PENG</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从Apollo动态配置原理学Spring(一)</title>
    <link href="https://www.pswen.cn/p/e352a76e/"/>
    <id>https://www.pswen.cn/p/e352a76e/</id>
    <published>2023-02-23T14:29:54.000Z</published>
    <updated>2023-02-23T15:19:10.371Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近工作碰到需要写一个类似携程 Apollo 的动态配置功能，以此系统学习该原理，熟练掌握下 Spring 的各种机制</p></blockquote><p><strong>Apollo 动态配置原理简述</strong></p><p>Apollo 配置中心动态生效机制，是基于 Http 长轮询请求和 Spring 扩展机制实现的，在 Spring 容器启动过程中，Apollo 通过自定义的 <code>BeanPostProcessor</code>  和 <code>BeanFactoryPostProcessor</code>  將参数中包含 <code>$&#123;…&#125;</code>  占位符和 <code>@Value</code>  注解的 Bean 注册到 Apollo 框架中定义的注册表中。然后通过 Http 长轮询不断的去获取服务端的配置信息，一旦配置发生变化，Apollo 会根据变化的配置的 Key 找到对应的 Bean，然后修改 Bean 的属性，从而实现了配置动态生效的特性。</p><p>需要注意的是，Apollo 在配置变化后，只能修改 Bean 的属性，例如我们数据源的属性发生变化，新创建的 Connection 对象是没问题的，但是连接池中已经创建的 Connection 对象相关信息是不能动态修改的，所以依然需要重启应用。</p><span id="more"></span><p>其中涉及到的 Spring 的扩展机制有：</p><ul><li>BeanFactoryPostProcessor</li><li>BeanPostProcessor</li><li>BeanDefinitionRegistry</li><li>PropertySource</li><li>ImportBeanDefinitionRegistrar</li><li>PropertySourcesPlaceholderConfigurer</li></ul><p>…</p><p>其中每一个都是非常关键的点，我们后续会一一进行学习。</p><h2 id="apollo启动过程"><a class="markdownIt-Anchor" href="#apollo启动过程">#</a> Apollo 启动过程</h2><p>首先，我们先看一张图：</p><p><img src="/p/e352a76e/image-20230223224050610.png" alt="Apollo启动图"></p><ol><li><p>Spring 启动，扫描 bean，将相关变量参数注册到 Apollo 属性注册表</p></li><li><p>通过 RemoteConfigRepository 获取配置，持久化本地，后续读取从本地读取，通过 <code>PropertySourcesProcessor</code>  执行如下步骤</p></li></ol><p>（1）根据命名空间从配置中心获取配置信息，创建 RemoteConfigRepository 和 LocalFileConfigRepository 对象。RemoteConfigRepository 表示远程配置中心资源，LocalFileConfigRepository 表示本地缓存配置资源。</p><p>（2）LocalFileConfigRepository 对象缓存配置信息到 C:\opt\data 或者 /opt/data 目录</p><p>（3）RemoteConfigRepository 开启 HTTP 长轮询请求定时任务，默认 2s 请求一次。</p><p>（4）將本地缓存配置信息转换为 PropertySource 对象（Apollo 自定义了 Spring 的 PropertySource），加载到 Spring 的 Environment 对象中。至此静态配置就已经加入到环境变量中</p><p>（5）將自定义的 ConfigPropertySource 注册为观察者。一旦 RemoteConfigRepository 发现远程配置中心信息发生变化，ConfigPropertySource 对象会得到通知。</p><ol start="3"><li><p>通过一个自定义监听器，监听对应事件</p></li><li><p>后续通过长轮询请求监听到配置变化，根据配置读取注册表里面的 key 和对应的 bean，通过反射修改 bean 对应属性值</p></li></ol><h2 id="apollo扩展点"><a class="markdownIt-Anchor" href="#apollo扩展点">#</a> Apollo 扩展点</h2><ol><li><code>PropertySourcesProcessor</code>  初始化 Apollo 配置、接入 Spring environment，初始化 Apollo 监听器</li><li><code>ApolloAnnotationProcessor</code>  提供 Apollo 一些注解支持 <code>@ApolloConfig</code> ， <code>@ApolloConfigChangeListener</code></li><li><code>SpringValueProcessor</code>  提供对 <code>@Value</code>  动态生效能力 针对实例 bean</li><li><code>SpringValueDefinitionProcessor</code>  提供对 <code>@Value</code>  动态生效能力 针对 bean 定义</li><li><code>ApolloJsonValueProcessor</code>  提供对 <code>@ApolloJsonValue</code>  支持</li></ol><p>上述分别对应使用 Spring 的扩展能力 <code>BeanFactoryPostProcessor</code> 、 <code>BeanPostProcessor</code> 、 <code>BeanPostProcessor</code>  和 <code>BeanFactoryPostProcessor</code> 、 <code>BeanDefinitionRegistryPostProcessor</code> 、 <code>BeanPostProcessor</code></p><p>我们这个系列也会对 apollo 基于 spring 提供的扩展点来嵌入自己的能力。主要为 BeanFactoryPostProcessor、BeanPostProcessor 这两个扩展点；先简单说一下：<em><strong>只需要知道，BeanFactoryPostProcessor、BeanDefinitionRegistryPostProcessor 在生成所有 beandefinition 之后调用，而 BeanPostProcessor 在通过 beandefinition 实例化 bean 的过程中调用即可。</strong></em></p><p>那这些实现我们就下篇见了！！！</p>]]></content>
    
    
    <summary type="html">从学习Apollo的动态配置生效原理，从而学习Spring的扩展机制</summary>
    
    
    
    <category term="Java" scheme="https://www.pswen.cn/categories/Java/"/>
    
    
    <category term="Apollo" scheme="https://www.pswen.cn/tags/Apollo/"/>
    
    <category term="Spring" scheme="https://www.pswen.cn/tags/Spring/"/>
    
    <category term="动态配置" scheme="https://www.pswen.cn/tags/%E5%8A%A8%E6%80%81%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>QQ上线了24周年注册全球排名这个活动</title>
    <link href="https://www.pswen.cn/p/75466bf9/"/>
    <id>https://www.pswen.cn/p/75466bf9/</id>
    <published>2023-02-10T12:58:50.000Z</published>
    <updated>2023-02-23T15:19:10.371Z</updated>
    
    <content type="html"><![CDATA[<p>2023 年 2 月 10 日是 QQ24 周年的日子，在这天 QQ 上线了 24 周年注册全球排名这个活动，玩家可以在这里看到自己是什么时候创建的账号，并且还可以看到自己的排名信息哦。</p><span id="more"></span><p><img src="/p/75466bf9/20230210161435_71813.jpg" alt="QQ"></p><h3 id="qq24周年全球排名查看攻略"><a class="markdownIt-Anchor" href="#qq24周年全球排名查看攻略">#</a> QQ24 周年全球排名查看攻略</h3><p>这个活动的查看有着两种方式，分别如下：</p><p>1、点击链接（<strong>24 周年全球排名网址 &gt;&gt;</strong><a href="https://ti.qq.com/open_qq/newIndex.html?url=https%3A%2F%2Fti.qq.com%2Fact%2Fqq24th%2Findex.html%3F_wv%3D16777219%26_wwv%3D128%26source%3D2"> 点击查看</a>）</p><p>点击上方的 24 周年全球排名网址链接，这个会直接唤起 qq。</p><p>点击立即查看我们就可以看到自己的排名，需要同意协议。</p><p>下面是我的排名：</p><p><img src="/p/75466bf9/IMG_0057.JPG" alt="IMG_0057"></p>]]></content>
    
    
    <summary type="html">2023年2月10日是qq24周年的日子，在这天qq上线了24周年注册全球排名这个活动，玩家可以在这里看到自己是什么时候创建的账号，并且还可以看到自己的排名信息哦。</summary>
    
    
    
    
    <category term="QQ" scheme="https://www.pswen.cn/tags/QQ/"/>
    
    <category term="那些年" scheme="https://www.pswen.cn/tags/%E9%82%A3%E4%BA%9B%E5%B9%B4/"/>
    
  </entry>
  
  <entry>
    <title>元宵节，放了烟花</title>
    <link href="https://www.pswen.cn/p/277fd0ba/"/>
    <id>https://www.pswen.cn/p/277fd0ba/</id>
    <published>2023-02-08T14:29:06.000Z</published>
    <updated>2023-02-23T15:19:10.371Z</updated>
    
    <content type="html"><![CDATA[<p>烟花又称 [花炮]、烟火、焰火、[炮仗]，根据《中国 [烟花爆竹] 标准 — 安全与质量》对烟花爆竹的定义为：以烟火药为原料，用于产生声光色的娱乐用品。中国劳动人民较早发明，常用于盛大的典礼或表演中。</p><p>烟花其实和爆竹的结构类似，其结构都包含黑 [火药] 和药引。为了达到好的表演效果，[焰火] 和 [礼花弹] 中填充了大量用于发射以及爆炸的火药，例如，一个直径为 20 厘米的礼花弹在发射后，要上升到大概 200 米的高空才会爆炸，而这些星星点点覆盖的 [半径] 大约可以有 80 米左右。</p><span id="more"></span><p><img src="/p/277fd0ba/IMG_0698_1.jpeg" alt="小区放烟花"></p><p>醴陵花炮起源最早可上溯至唐代，已经有着上千年的历史，以产地醴陵而被概括命名。当地是烟花的发祥地，也是花炮祖师李畋的故乡，被誉为名副其实的 “花炮之乡”。</p><p>浏阳花炮，湖南省浏阳市特产，中国国家地理标志产品。<br>浏阳市是世界著名的花炮之乡。浏阳花炮造型美观，色彩鲜艳，质量可靠，素有 “浏阳花炮震天下” 的美名。2002 年 10 月，在浏阳闭幕的首届国际花炮合作与贸易大会上，浏阳成为国际花炮协会总部永久所在地。2007 年，“浏阳花炮” 被正式认定为中国驰名商标。 [3]<br> 2003 年 03 月 06 日，原国家质检总局批准对 “浏阳花炮” 实施地理标志产品保护。</p><p>作为醴陵人，说实话，浏阳花炮的科技量要比醴陵花炮高，这几年醴陵也在紧追猛赶！加油！</p>]]></content>
    
    
    <summary type="html">元宵节，深圳小区内放了烟花，还挺好看的；还是得放烟花才有氛围</summary>
    
    
    
    
    <category term="烟花" scheme="https://www.pswen.cn/tags/%E7%83%9F%E8%8A%B1/"/>
    
    <category term="元宵节" scheme="https://www.pswen.cn/tags/%E5%85%83%E5%AE%B5%E8%8A%82/"/>
    
  </entry>
  
  <entry>
    <title>2023兔年春节</title>
    <link href="https://www.pswen.cn/p/ebb8427d/"/>
    <id>https://www.pswen.cn/p/ebb8427d/</id>
    <published>2023-02-04T07:27:08.000Z</published>
    <updated>2023-02-23T15:19:10.251Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-春节年前家县城进行烟花表演"><a class="markdownIt-Anchor" href="#1-春节年前家县城进行烟花表演">#</a> 1. 春节年前，家县城进行烟花表演：</h3><p><img src="/p/ebb8427d/IMG_0650.PNG" alt="烟花表演1"></p><p>估计是增加了延迟拍摄</p><span id="more"></span><p><img src="/p/ebb8427d/IMG_0651.PNG" alt="烟花表演2"></p><p><img src="/p/ebb8427d/IMG_0652.PNG" alt="烟花表演3"></p><p>还是得加滤镜啊</p><p><img src="/p/ebb8427d/IMG_0653.PNG" alt="烟花表演4"></p><h3 id="2-大伯家客厅搞了个灯"><a class="markdownIt-Anchor" href="#2-大伯家客厅搞了个灯">#</a> 2. 大伯家客厅搞了个 “灯”</h3><p><img src="/p/ebb8427d/IMG_0656.JPG" alt="大伯家的“灯”"></p><h3 id="3-玩游戏的小外甥"><a class="markdownIt-Anchor" href="#3-玩游戏的小外甥">#</a> 3. 玩游戏的小外甥</h3><p><img src="/p/ebb8427d/IMG_0657.jpg" alt="认真玩游戏"></p><h3 id="4-外婆家合照"><a class="markdownIt-Anchor" href="#4-外婆家合照">#</a> 4. 外婆家合照</h3><p><img src="/p/ebb8427d/IMG_0681.jpg" alt="外婆家合照"></p><h3 id="5-老表们"><a class="markdownIt-Anchor" href="#5-老表们">#</a> 5. 老表们</h3><p><img src="/p/ebb8427d/IMG_1794.jpg" alt="我和老表们"></p><h3 id="6-主公我是忠臣"><a class="markdownIt-Anchor" href="#6-主公我是忠臣">#</a> 6. 主公，我是忠臣</h3><p>特别说明：服务员也太不走心，少拍了一个人都说挺好，那个人是 “望叔”，给望叔郑重道歉！</p><p><img src="/p/ebb8427d/IMG_0690.JPG" alt="同学聚合照"></p><h3 id="7-王家码头"><a class="markdownIt-Anchor" href="#7-王家码头">#</a> 7. 王家码头</h3><p><img src="/p/ebb8427d/IMG_0691.JPG" alt="王家码头"></p><h3 id="8-家族祠堂"><a class="markdownIt-Anchor" href="#8-家族祠堂">#</a> 8. 家族祠堂</h3><p><img src="/p/ebb8427d/IMG_0692.JPG" alt="祠堂"></p><h3 id="9-返程堵车"><a class="markdownIt-Anchor" href="#9-返程堵车">#</a> 9. 返程堵车</h3><p>原本的 12h 变成 20 多小时，真是辛苦司机了。</p><p><img src="/p/ebb8427d/IMG_0694.JPG" alt="堵车"></p>]]></content>
    
    
    <summary type="html">兔年生活记录</summary>
    
    
    
    <category term="杂记" scheme="https://www.pswen.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="春节" scheme="https://www.pswen.cn/tags/%E6%98%A5%E8%8A%82/"/>
    
  </entry>
  
  <entry>
    <title>室友“羊”了</title>
    <link href="https://www.pswen.cn/p/850ce73f/"/>
    <id>https://www.pswen.cn/p/850ce73f/</id>
    <published>2022-12-19T12:46:23.000Z</published>
    <updated>2023-02-23T15:19:10.243Z</updated>
    
    <content type="html"><![CDATA[<p>室友这几天不舒服，就测了，果不其然🐑了，我应该是很危险了。</p><span id="more"></span><p><img src="/p/850ce73f/image-20221219212509735.png" alt="抗原检测阳性"></p>]]></content>
    
    
    <summary type="html">室友这几天核酸检测阳性了，我很慌</summary>
    
    
    
    <category term="杂记" scheme="https://www.pswen.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="疫情" scheme="https://www.pswen.cn/tags/%E7%96%AB%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>疫情三年，是时候结束了！</title>
    <link href="https://www.pswen.cn/p/d223f900/"/>
    <id>https://www.pswen.cn/p/d223f900/</id>
    <published>2022-12-12T12:56:26.000Z</published>
    <updated>2023-02-23T15:19:10.235Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>疫情三年，什么变化了？什么没有变化呢？</p></blockquote><p>疫情三年变化的是，出现了健康码、行程码、核酸检测</p><p>疫情三年变化的是，到处都贴起了二维码、出行限制、经济发展滞缓</p><span id="more"></span><p><img src="/p/d223f900/image-20221212210631735.png" alt="核酸检测点即将拆除"></p><p>三年疫情，突然放开，大家还是有些许不适应</p><p>还是习惯的过门卡掏出手机，还是习惯每天准点测核酸</p><p>三年疫情对国家也有很大冲击，国家开始发行国债，用来弥补这三年的核酸检测国家政府开支</p><p>三年疫情对经济冲击夜很大，许多行业都开始收紧，业务调整，裁员潮，都开始 “过冬” 了</p><p><img src="/p/d223f900/image-20221212210553921.png" alt="行程码下线"></p><p>不变的是啥呢？</p><p>唯一不变的估计是人吗？</p>]]></content>
    
    
    <summary type="html">这几天陆续宣布的疫情相关的政策，行程码也宣布下线等等</summary>
    
    
    
    <category term="杂记" scheme="https://www.pswen.cn/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
    <category term="疫情" scheme="https://www.pswen.cn/tags/%E7%96%AB%E6%83%85/"/>
    
  </entry>
  
  <entry>
    <title>被围绕的区域——LeetCode130</title>
    <link href="https://www.pswen.cn/p/52a5c0f5/"/>
    <id>https://www.pswen.cn/p/52a5c0f5/</id>
    <published>2022-02-08T11:56:55.000Z</published>
    <updated>2023-02-23T15:19:10.439Z</updated>
    
    <content type="html"><![CDATA[<p>给你一个  <code>m x n</code>  的矩阵  <code>board</code>  ，由若干字符  <code>'X'</code>  和  <code>'O'</code>  ，找到所有被  <code>'X'</code>  围绕的区域，并将这些区域里所有的  <code>'O'</code>  用  <code>'X'</code>  填充。</p><p><img src="/p/52a5c0f5/xogrid.jpg" alt="img"></p><span id="more"></span><p>示例 1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;O&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;O&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;X&quot;,&quot;X&quot;]]</span><br><span class="line">输出：[[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;X&quot;,&quot;X&quot;]]</span><br><span class="line">解释：被围绕的区间不会存在于边界上，换句话说，任何边界上的 &#x27;O&#x27; 都不会被填充为 &#x27;X&#x27;。 任何不在边界上，或不与边界上的 &#x27;O&#x27; 相连的 &#x27;O&#x27; 最终都会被填充为 &#x27;X&#x27;。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。</span><br></pre></td></tr></table></figure><p>示例 2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[&quot;X&quot;]]</span><br><span class="line">输出：[[&quot;X&quot;]]</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m == board.length</span><br><span class="line">n == board[i].length</span><br><span class="line">1 &lt;= m, n &lt;= 200</span><br><span class="line">board[i][j] 为 &#x27;X&#x27; 或 &#x27;O&#x27;</span><br></pre></td></tr></table></figure><h3 id="解题"><a class="markdownIt-Anchor" href="#解题">#</a> 解题</h3><p>写在前面<br>本题给定的矩阵中有三种元素：</p><ul><li><p>字母 X；</p></li><li><p>被字母 X 包围的字母 O；</p></li><li><p>没有被字母 X 包围的字母 O。</p></li></ul><p>本题要求将所有被字母 X 包围的字母 O 都变为字母 X ，但很难判断哪些 O 是被包围的，哪些 O 不是被包围的。</p><p>注意到题目解释中提到： <code>任何边界上的 O 都不会被填充为 X</code> 。 我们可以想到，所有的不被包围的 O 都直接或间接与边界上的 O 相连。我们可以利用这个性质判断 O 是否在边界上，具体地说：</p><ul><li>对于每一个边界上的 O，我们以它为起点，标记所有与它直接或间接相连的字母 O；<br>最后我们遍历这个矩阵，对于每一个字母：</li><li>如果该字母被标记过，则该字母为没有被字母 X 包围的字母 O，我们将其还原为字母 O；<br>如果该字母没有被标记过，则该字母为被字母 X 包围的字母 O，我们将其修改为字母 X。</li></ul><h3 id="方法一深度优先搜索"><a class="markdownIt-Anchor" href="#方法一深度优先搜索">#</a> 方法一：深度优先搜索</h3><h4 id="思路及解法"><a class="markdownIt-Anchor" href="#思路及解法">#</a> 思路及解法</h4><p>我们可以使用深度优先搜索实现标记操作。在下面的代码中，我们把标记过的字母 O 修改为字母 A。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">        n = board.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dfs(board, i, <span class="number">0</span>);</span><br><span class="line">            dfs(board, i, m - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            dfs(board, <span class="number">0</span>, i);</span><br><span class="line">            dfs(board, n - <span class="number">1</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;A&#x27;</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= n || y &lt; <span class="number">0</span> || y &gt;= m || board[x][y] != <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        board[x][y] = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        dfs(board, x + <span class="number">1</span>, y);</span><br><span class="line">        dfs(board, x - <span class="number">1</span>, y);</span><br><span class="line">        dfs(board, x, y + <span class="number">1</span>);</span><br><span class="line">        dfs(board, x, y - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a class="markdownIt-Anchor" href="#复杂度分析">#</a> 复杂度分析</h4><ul><li><p>时间复杂度： <code>O(n×m)</code> ，其中  <code>n</code>  和  <code>m </code> 分别为矩阵的行数和列数。深度优先搜索过程中，每一个点至多只会被标记一次。</p></li><li><p>空间复杂度： <code>O(n×m)</code> ，其中  <code>n</code>  和  <code>m</code>  分别为矩阵的行数和列数。主要为深度优先搜索的栈的开销。</p></li></ul><h3 id="方法二广度优先搜索"><a class="markdownIt-Anchor" href="#方法二广度优先搜索">#</a> 方法二：广度优先搜索</h3><h4 id="思路及解法-2"><a class="markdownIt-Anchor" href="#思路及解法-2">#</a> 思路及解法</h4><p>我们可以使用广度优先搜索实现标记操作。在下面的代码中，我们把标记过的字母  <code>O</code>  修改为字母  <code>A</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] dx = &#123;<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span>[] dy = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> board.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> board[<span class="number">0</span>].length;</span><br><span class="line">        Queue&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;<span class="type">int</span>[]&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][<span class="number">0</span>] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i, <span class="number">0</span>&#125;);</span><br><span class="line">                board[i][<span class="number">0</span>] = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (board[i][m - <span class="number">1</span>] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i, m - <span class="number">1</span>&#125;);</span><br><span class="line">                board[i][m - <span class="number">1</span>] = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[<span class="number">0</span>][i] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>, i&#125;);</span><br><span class="line">                board[<span class="number">0</span>][i] = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (board[n - <span class="number">1</span>][i] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;n - <span class="number">1</span>, i&#125;);</span><br><span class="line">                board[n - <span class="number">1</span>][i] = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span>[] cell = queue.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> cell[<span class="number">0</span>], y = cell[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">mx</span> <span class="operator">=</span> x + dx[i], my = y + dy[i];</span><br><span class="line">                <span class="keyword">if</span> (mx &lt; <span class="number">0</span> || my &lt; <span class="number">0</span> || mx &gt;= n || my &gt;= m || board[mx][my] != <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;mx, my&#125;);</span><br><span class="line">                board[mx][my] = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;A&#x27;</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析-2"><a class="markdownIt-Anchor" href="#复杂度分析-2">#</a> 复杂度分析</h4><ul><li><p>时间复杂度： <code>O(n×m)</code> ，其中  <code>n</code>  和  <code>m</code>  分别为矩阵的行数和列数。广度优先搜索过程中，每一个点至多只会被标记一次。</p></li><li><p>空间复杂度： <code>O(n×m)</code> ，其中  <code>n</code>  和  <code>m</code>  分别为矩阵的行数和列数。主要为广度优先搜索的队列的开销。</p></li></ul>]]></content>
    
    
    <summary type="html">给你一个 m x n 的矩阵 board ，由若干字符 &#39;X&#39; 和 &#39;O&#39; ，找到所有被 &#39;X&#39; 围绕的区域，并将这些区域里所有的 &#39;O&#39; 用 &#39;X&#39; 填充。</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.pswen.cn/categories/LeetCode/"/>
    
    <category term="算法" scheme="https://www.pswen.cn/categories/LeetCode/%E7%AE%97%E6%B3%95/"/>
    
    <category term="java" scheme="https://www.pswen.cn/categories/LeetCode/%E7%AE%97%E6%B3%95/java/"/>
    
    
    <category term="矩阵" scheme="https://www.pswen.cn/tags/%E7%9F%A9%E9%98%B5/"/>
    
    <category term="深度遍历" scheme="https://www.pswen.cn/tags/%E6%B7%B1%E5%BA%A6%E9%81%8D%E5%8E%86/"/>
    
    <category term="广度遍历" scheme="https://www.pswen.cn/tags/%E5%B9%BF%E5%BA%A6%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>JVM调优——X参数,方法内联</title>
    <link href="https://www.pswen.cn/p/638c83fa/"/>
    <id>https://www.pswen.cn/p/638c83fa/</id>
    <published>2022-01-12T15:06:08.000Z</published>
    <updated>2023-02-23T15:19:10.379Z</updated>
    
    <content type="html"><![CDATA[<p>JVM 的 <code>-X</code>  参数是非标准参数，在不同版本的 JVM 中，参数可能会有所不同，可以通过 <code>java -X</code>  查看非标准参数</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">&gt; java -X</span><br><span class="line"></span><br><span class="line">    -Xbatch           禁用后台编译</span><br><span class="line">    -Xbootclasspath/a:&lt;以 : 分隔的目录和 zip/jar 文件&gt;</span><br><span class="line">                      附加在引导类路径末尾</span><br><span class="line">    -Xcheck:jni       对 JNI 函数执行其他检查</span><br><span class="line">    -Xcomp            强制在首次调用时编译方法</span><br><span class="line">    -Xdebug           不执行任何操作。为实现向后兼容而提供。</span><br><span class="line">    -Xdiag            显示附加诊断消息</span><br><span class="line">    -Xfuture          启用最严格的检查，预期将来的默认值。</span><br><span class="line">                      此选项已过时，可能会在</span><br><span class="line">                      未来发行版中删除。</span><br><span class="line">    -Xint             仅解释模式执行</span><br><span class="line">    -Xinternalversion</span><br><span class="line">                      显示比 -version 选项更详细的</span><br><span class="line">                      JVM 版本信息</span><br><span class="line">    -Xlog:&lt;opts&gt;      配置或启用采用 Java 虚拟</span><br><span class="line">                      机 (Java Virtual Machine, JVM) 统一记录框架进行事件记录。使用 -Xlog:help</span><br><span class="line">                      可了解详细信息。</span><br><span class="line">    -Xloggc:&lt;file&gt;    将 GC 状态记录在文件中（带时间戳）。</span><br><span class="line">                      此选项已过时，可能会在</span><br><span class="line">                      将来的发行版中删除。它将替换为 -Xlog:gc:&lt;file&gt;。</span><br><span class="line">    -Xmixed           混合模式执行（默认值）</span><br><span class="line">    -Xmn&lt;size&gt;        为年轻代（新生代）设置初始和最大堆大小</span><br><span class="line">                      （以字节为单位）</span><br><span class="line">    -Xms&lt;size&gt;        设置初始 Java 堆大小</span><br><span class="line">    -Xmx&lt;size&gt;        设置最大 Java 堆大小</span><br><span class="line">    -Xnoclassgc       禁用类垃圾收集</span><br><span class="line">    -Xrs              减少 Java/VM 对操作系统信号的使用（请参见文档）</span><br><span class="line">    -Xshare:auto      在可能的情况下使用共享类数据（默认值）</span><br><span class="line">    -Xshare:off       不尝试使用共享类数据</span><br><span class="line">    -Xshare:on        要求使用共享类数据，否则将失败。</span><br><span class="line">                      这是一个测试选项，可能导致间歇性</span><br><span class="line">                      故障。不应在生产环境中使用它。</span><br><span class="line">    -XshowSettings    显示所有设置并继续</span><br><span class="line">    -XshowSettings:all</span><br><span class="line">                      显示所有设置并继续</span><br><span class="line">    -XshowSettings:locale</span><br><span class="line">                      显示所有与区域设置相关的设置并继续</span><br><span class="line">    -XshowSettings:properties</span><br><span class="line">                      显示所有属性设置并继续</span><br><span class="line">    -XshowSettings:vm</span><br><span class="line">                      显示所有与 vm 相关的设置并继续</span><br><span class="line">    -XshowSettings:system</span><br><span class="line">                      （仅 Linux）显示主机系统或容器</span><br><span class="line">                      配置并继续</span><br><span class="line">    -Xss&lt;size&gt;        设置 Java 线程堆栈大小</span><br><span class="line">    -Xverify          设置字节码验证器的模式</span><br><span class="line">                      请注意，选项 -Xverify:none 已过时，</span><br><span class="line">                      可能会在未来发行版中删除。</span><br><span class="line">    --add-reads &lt;module&gt;=&lt;target-module&gt;(,&lt;target-module&gt;)*</span><br><span class="line">                      更新 &lt;module&gt; 以读取 &lt;target-module&gt;，而无论</span><br><span class="line">                      模块如何声明。</span><br><span class="line">                      &lt;target-module&gt; 可以是 ALL-UNNAMED，将读取所有未命名</span><br><span class="line">                      模块。</span><br><span class="line">    --add-exports &lt;module&gt;/&lt;package&gt;=&lt;target-module&gt;(,&lt;target-module&gt;)*</span><br><span class="line">                      更新 &lt;module&gt; 以将 &lt;package&gt; 导出到 &lt;target-module&gt;，</span><br><span class="line">                      而无论模块如何声明。</span><br><span class="line">                      &lt;target-module&gt; 可以是 ALL-UNNAMED，将导出到所有</span><br><span class="line">                      未命名模块。</span><br><span class="line">    --add-opens &lt;module&gt;/&lt;package&gt;=&lt;target-module&gt;(,&lt;target-module&gt;)*</span><br><span class="line">                      更新 &lt;module&gt; 以在 &lt;target-module&gt; 中打开</span><br><span class="line">                      &lt;package&gt;，而无论模块如何声明。</span><br><span class="line">    --illegal-access=&lt;value&gt;</span><br><span class="line">                      允许或拒绝通过未命名模块中的代码对命名模块中的</span><br><span class="line">                      类型成员进行访问。</span><br><span class="line">                      &lt;value&gt; 为 &quot;deny&quot;、&quot;permit&quot;、&quot;warn&quot; 或 &quot;debug&quot; 之一</span><br><span class="line">                      此选项将在未来发行版中删除。</span><br><span class="line">    --limit-modules &lt;module name&gt;[,&lt;module name&gt;...]</span><br><span class="line">                      限制可观察模块的领域</span><br><span class="line">    --patch-module &lt;module&gt;=&lt;file&gt;(:&lt;file&gt;)*</span><br><span class="line">                      使用 JAR 文件或目录中的类和资源</span><br><span class="line">                      覆盖或增强模块。</span><br><span class="line">    --source &lt;version&gt;</span><br><span class="line">                      设置源文件模式中源的版本。</span><br><span class="line"></span><br><span class="line">这些额外选项如有更改, 恕不另行通知。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">以下选项是特定于 macOS 的选项：</span><br><span class="line">    -XstartOnFirstThread</span><br><span class="line">                      在第一个 (AppKit) 线程上运行 main() 方法</span><br><span class="line">    -Xdock:name=&lt;application name&gt;</span><br><span class="line">                      覆盖停靠栏中显示的默认应用程序名称</span><br><span class="line">    -Xdock:icon=&lt;path to icon file&gt;</span><br><span class="line">                     覆盖停靠栏中显示的默认图标</span><br></pre></td></tr></table></figure><h2 id="-xint-xcomp与-xmixed参数"><a class="markdownIt-Anchor" href="#-xint-xcomp与-xmixed参数">#</a> -Xint、-Xcomp 与 - Xmixed 参数</h2><h3 id="-xint参数"><a class="markdownIt-Anchor" href="#-xint参数">#</a> -Xint 参数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在解释模式（interpreted mode）下，-Xint标记会强制JVM执行所有的字节码，这当然会降低运行速度，通常低10倍或更多。</span><br></pre></td></tr></table></figure><p><img src="/p/638c83fa/20190729122640228.png" alt="interpreted-mode"></p><h3 id="-xcomp参数"><a class="markdownIt-Anchor" href="#-xcomp参数">#</a> -Xcomp 参数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xcomp参数与-Xint正好相反，JVM在第一次使用时会把所有的字节码编译成本地代码，从而带来最大程度的优化。</span><br></pre></td></tr></table></figure><p><img src="/p/638c83fa/20190729122919297.png" alt="compiled-mode"></p><p>然而，很多应用在使用 - Xcomp 也会有一些性能损失，当然这笔 - Xint 损失的少，原因是 - Xcomp 没有让 JVM 启用 JIT 编译器的全部功能。JIT 编译器可以对是否需要编译做出判断。如果所有代码都需要进行编译的话，对于一些只执行一次的代码就没有意义了。</p><h3 id="-xmixed参数"><a class="markdownIt-Anchor" href="#-xmixed参数">#</a> -Xmixed 参数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xmixed是混合模式，将解释模式和变异模式进行混合使用，有JVM自己决定，这是JVM的默认模式，也是推荐模式</span><br></pre></td></tr></table></figure><p><img src="/p/638c83fa/2019072913573773.png" alt="mixed-model"></p><h2 id="jvm方法内联优化"><a class="markdownIt-Anchor" href="#jvm方法内联优化">#</a> JVM 方法内联优化</h2><h3 id="前言"><a class="markdownIt-Anchor" href="#前言">#</a> 前言</h3><p>在日常中工作中，我们时不时会代码进行一些优化，比如用新的算法，简化计算逻辑，减少计算量等。对于 java 程序来说，除了开发者本身对代码优化之外，还有一个 &quot;人&quot; 也在背后默默的优化我们的代码，这个 &quot;人&quot; 就是 jvm。jvm 会帮我们分析出热点代码，优化代码逻辑。其中 jvm 最常做的优化之一就是：方法内联优化。</p><h3 id="方法内联"><a class="markdownIt-Anchor" href="#方法内联">#</a> 方法内联</h3><p>什么是方法内联？又可以叫做函数内联，java 中方法可等同于其它语言中的函数。关于方法内联维基百科上面解释是：</p><blockquote><p>在计算机科学中，内联函数（有时称作在线函数或编译时期展开函数）是一种编程语言结构，用来建议编译器对一些特殊函数进行内联扩展（有时称作在线扩展）；也就是说<strong>建议编译器将指定的函数体插入并取代每一处调用该函数的地方（上下文），从而节省了每次调用函数带来的额外时间开支。</strong></p></blockquote><p>简单通俗的讲就是把方法内部调用的其它方法的逻辑，嵌入到自身的方法中去，变成自身的一部分，之后不再调用该方法，从而节省调用函数带来的额外开支。</p><h3 id="函数调用开销"><a class="markdownIt-Anchor" href="#函数调用开销">#</a> 函数调用开销</h3><p>之所以出现方法内联是因为函数调用除了执行自身逻辑的开销外，还有一些不为人知的额外开销。这部分额外的开销主要来自方法栈帧的生成、参数字段的压入、栈帧的弹出、还有指令执行地址的跳转。比如有下面这样代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">function_A</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">    function_B(a,b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">function_B</span><span class="params">(<span class="type">int</span> c, <span class="type">int</span> d)</span>&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">     function_A(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>则代码的执行过程如下：</p><p><img src="/p/638c83fa/247487dfbaf1ec956441e9e5e2f85817_1440w.jpg" alt="img"></p><p>所以如果 java 中方法调用嵌套过多或者方法过多，这种额外的开销就越多。</p><p>试想一下想 get/set 这种方法调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getI</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setI</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.i = i;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>很可能自身执行逻辑的开销还比不上为了调用这个方法的额外开锁。如果类似的方法被频繁的调用，则真正相对执行效率就会很低，虽然这类方法的执行时间很短。这也是为什么 jvm 会在热点代码中执行方法内联的原因，这样的话就可以省去调用调用函数带来的额外开支。</p><p>这里举个内联的可能形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>  <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b , <span class="type">int</span> c, <span class="type">int</span> d)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> add(a, b) + add(c, d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内联之后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>  <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b , <span class="type">int</span> c, <span class="type">int</span> d)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> a + b + c + d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样除了本身的相加逻辑的开销，比内联前减少了二次调用函数带来的额外开销。</p><h3 id="内联条件"><a class="markdownIt-Anchor" href="#内联条件">#</a> 内联条件</h3><p>一个方法如果满足以下条件就很可能被 jvm 内联。</p><p>1、热点代码： 如果一个方法的执行频率很高就表示优化的潜在价值就越大。那代码执行多少次才能确定为热点代码？这是根据编译器的编译模式来决定的。如果是客户端编译模式则次数是 1500，服务端编译模式是 10000。次数的大小可以通过 - XX:CompileThreshold 来调整。</p><p>2、方法体不能太大：jvm 中被内联的方法会编译成机器码放在 code cache 中。如果方法体太大，则能缓存热点方法就少，反而会影响性能。</p><p>3、如果希望方法被内联，尽量用 private、static、final 修饰，这样 jvm 可以直接内联。如果是 public、protected 修饰方法 jvm 则需要进行类型判断，因为这些方法可以被子类继承和覆盖，jvm 需要判断内联究竟内联是父类还是其中某个子类的方法。</p><blockquote><p>所以了解 jvm 方法内联机制之后，会有助于我们工作中写出能让 jvm 更容易优化的代码，有助于提升程序的性能。</p></blockquote>]]></content>
    
    
    <summary type="html">jvm相关启动参数可以用来控制模式</summary>
    
    
    
    <category term="java" scheme="https://www.pswen.cn/categories/java/"/>
    
    
    <category term="jvm调优" scheme="https://www.pswen.cn/tags/jvm%E8%B0%83%E4%BC%98/"/>
    
    <category term="混合模式" scheme="https://www.pswen.cn/tags/%E6%B7%B7%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="解释模式" scheme="https://www.pswen.cn/tags/%E8%A7%A3%E9%87%8A%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="纯编译模式" scheme="https://www.pswen.cn/tags/%E7%BA%AF%E7%BC%96%E8%AF%91%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>巧妙使用正则——去除小数点后多余的零</title>
    <link href="https://www.pswen.cn/p/9195a466/"/>
    <id>https://www.pswen.cn/p/9195a466/</id>
    <published>2022-01-10T13:51:44.000Z</published>
    <updated>2023-02-23T15:19:10.379Z</updated>
    
    <content type="html"><![CDATA[<p>直接上代码</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr=[<span class="string">&#x27;1200.00100&#x27;</span>,<span class="string">&#x27;1200.00000&#x27;</span>,<span class="string">&#x27;1200.&#x27;</span>,<span class="string">&#x27;1200&#x27;</span>,<span class="string">&#x27;1200.10000&#x27;</span>,<span class="string">&#x27;0.120010000&#x27;</span>,<span class="string">&#x27;0.000011111&#x27;</span>]</span><br><span class="line"><span class="keyword">const</span> regexp=<span class="regexp">/(?:\.0*|(\.\d+?)0+)$/</span></span><br><span class="line">arr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item.<span class="title function_">replace</span>(regexp,<span class="string">&#x27;$1&#x27;</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// &gt; 1200.001</span></span><br><span class="line"><span class="comment">// &gt; 1200</span></span><br><span class="line"><span class="comment">// &gt; 1200</span></span><br><span class="line"><span class="comment">// &gt; 1200</span></span><br><span class="line"><span class="comment">// &gt; 1200.1</span></span><br><span class="line"><span class="comment">// &gt; 0.12001</span></span><br><span class="line"><span class="comment">// &gt; 0.000011111</span></span><br></pre></td></tr></table></figure><span id="more"></span><p>正则可视化：</p><p><img src="/p/9195a466/image.svg" alt="image"></p><p>推荐个可视化网址：<a href="https://regexper.com/">https://regexper.com/</a></p><!-- more --><p>再解释下正则的意思 <code>(?:.0*|(.\d+?)0+)$</code></p><p>先分解成 4 部分</p><ol><li><code>(?:reg1|reg2)</code>  - 它是一个正则分组非捕获组，要么匹配 reg1，要么匹配 reg2，优先匹配 reg1，加上？: 不对捕获组记录</li><li><code>.0*</code>  - 表示匹配一个。开头，后边跟着 0 或 0 个以上数量的 0，且不进行捕获，所以在填充 $1 时，就是个空值</li><li><code>(.\d+?)0+</code>  - 它是一个捕获组，匹配一个。开头后边跟着非贪婪（懒惰）匹配任意数字，接着在末尾尽可能多的匹配 0 这个字符，匹配完成后，生成一个捕获组内容</li><li><code>$</code>  - 表示匹配结果需要以 0 作为结尾</li></ol><h2 id="正则分组"><a class="markdownIt-Anchor" href="#正则分组">#</a> 正则分组</h2><ul><li><p>普通捕获组</p><p>从正则表达式左侧开始，每出现一个左括号 &quot;(&quot; 记做一个分组，分组编号从 1 开始。0 代表整个表达式。</p><p>对于时间字符串：2017-04-25，表达式如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(\\d&#123;<span class="number">4</span>&#125;)-((\\d&#123;<span class="number">2</span>&#125;)-(\\d&#123;<span class="number">2</span>&#125;))</span><br></pre></td></tr></table></figure><p>有 4 个左括号，所以有 4 个分组:</p><table><thead><tr><th style="text-align:left">编号</th><th style="text-align:left">捕获组</th><th style="text-align:left">匹配</th></tr></thead><tbody><tr><td style="text-align:left">0</td><td style="text-align:left">(\d{4})-((\d{2})-(\d{2}))</td><td style="text-align:left">2017-04-25</td></tr><tr><td style="text-align:left">1</td><td style="text-align:left">(\d{4})</td><td style="text-align:left">2017</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">((\d{2})-(\d{2}))</td><td style="text-align:left">04-25</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">(\d{2})</td><td style="text-align:left">04</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">(\d{2})</td><td style="text-align:left">25</td></tr></tbody></table></li><li><p>命名捕获组</p><p>每个以左括号开始的捕获组，都紧跟着 <strong>?</strong>，而后才是正则表达式。</p><p>对于时间字符串：2017-04-25，表达式如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(?&lt;year&gt;\\d&#123;<span class="number">4</span>&#125;)-(?&lt;md&gt;(?&lt;month&gt;\\d&#123;<span class="number">2</span>&#125;)-(?&lt;date&gt;\\d&#123;<span class="number">2</span>&#125;))</span><br></pre></td></tr></table></figure><p>有 4 个命名的捕获组，分别是:</p><table><thead><tr><th style="text-align:left">编号</th><th style="text-align:left">名称</th><th style="text-align:left">捕获组</th><th style="text-align:left">匹配</th></tr></thead><tbody><tr><td style="text-align:left">0</td><td style="text-align:left">0</td><td style="text-align:left">(?\d{4})-(?(?\d{2})-(?\d{2}))</td><td style="text-align:left">2017-04-25</td></tr><tr><td style="text-align:left">1</td><td style="text-align:left">year</td><td style="text-align:left">(?\d{4})-</td><td style="text-align:left">2017</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">md</td><td style="text-align:left">(?(?\d{2})-(?\d{2}))</td><td style="text-align:left">04-25</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">month</td><td style="text-align:left">(?\d{2})</td><td style="text-align:left">04</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">date</td><td style="text-align:left">(?\d{2})</td><td style="text-align:left">25</td></tr></tbody></table><p>命名的捕获组同样也可以使用编号获取相应值。</p></li></ul><h2 id="非捕获组"><a class="markdownIt-Anchor" href="#非捕获组">#</a> 非捕获组</h2><p>在左括号后紧跟  <code>?:</code> ，而后再加上正则表达式，构成非捕获组 <strong>(?:Expression)</strong>。</p><p>对于时间字符串：2017-04-25，表达式如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(?:\\d&#123;<span class="number">4</span>&#125;)-((\\d&#123;<span class="number">2</span>&#125;)-(\\d&#123;<span class="number">2</span>&#125;))</span><br></pre></td></tr></table></figure><p>这个正则表达式虽然有四个左括号，理论上有 4 个捕获组。但是第一组 <strong>(?:\d{4})</strong>，其实是被忽略的。当使用 matcher.group (4) 时，系统会报错。</p><table><thead><tr><th style="text-align:left">编号</th><th style="text-align:left">捕获组</th><th style="text-align:left">匹配</th></tr></thead><tbody><tr><td style="text-align:left">0</td><td style="text-align:left">(\d{4})-((\d{2})-(\d{2}))</td><td style="text-align:left">2017-04-25</td></tr><tr><td style="text-align:left">1</td><td style="text-align:left">((\d{2})-(\d{2}))</td><td style="text-align:left">04-25</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">(\d{2})</td><td style="text-align:left">04</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">(\d{2})</td><td style="text-align:left">25</td></tr></tbody></table><h2 id="非贪婪懒惰匹配"><a class="markdownIt-Anchor" href="#非贪婪懒惰匹配">#</a> 非贪婪 (懒惰) 匹配</h2><p>** 贪婪匹配:** 正则表达式一般趋向于最大长度匹配，也就是所谓的贪婪匹配。如上面使用模式 p 匹配字符串 str，结果就是匹配到：<strong>abcaxc</strong>(ab*c)。</p><p><strong>非贪婪匹配</strong>：就是匹配到结果就好，就少的匹配字符。如上面使用模式 p 匹配字符串 str，结果就是匹配到：<strong>abc</strong>(ab*c)。</p><p>问号可以表示重复前面内容的 0 次或一次，也就是要么不出现，要么出现一次</p><p>示例 1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">string</span> <span class="variable">pattern1</span> <span class="operator">=</span> @<span class="string">&quot;a.*?c&quot;</span>;   <span class="comment">// non-greedy match </span></span><br><span class="line"><span class="type">Regex</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Regex</span>(pattern1);</span><br><span class="line">regex.Match(<span class="string">&quot;abcabc&quot;</span>); <span class="comment">// return &quot;abc&quot;</span></span><br><span class="line"></span><br><span class="line">## 结果：abc</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">s=<span class="string">&#x27;hello 1234567 world&#x27;</span></span><br><span class="line">res = re.<span class="keyword">match</span>(<span class="string">&#x27;he.*?(\d).*rld$&#x27;</span>,s)</span><br><span class="line"><span class="built_in">print</span>(res.group(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">## 结果：123456</span></span><br></pre></td></tr></table></figure><p>常用非贪婪表达式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*? 重复任意次，但尽可能少重复</span><br><span class="line">+? 重复1次或更多次，但尽可能少重复</span><br><span class="line">?? 重复0次或1次，但尽可能少重复</span><br><span class="line">&#123;n,m&#125;? 重复n到m次，但尽可能少重复</span><br><span class="line">&#123;n,&#125;? 重复n次以上，但尽可能少重复</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">直接上代码

1
2
3
4
5
6
7
8
9
10
11
12
13


const arr=[&#39;1200.00100&#39;,&#39;1200.00000&#39;,&#39;1200.&#39;,&#39;1200&#39;,&#39;1200.10000&#39;,&#39;0.120010000&#39;,&#39;0.000011111&#39;]
const regexp=/(?:\.0*|(\.\d+?)0+)$/
arr.forEach((item)=&gt;{
    console.log(item.replace(regexp,&#39;$1&#39;))
})

// &gt; 1200.001
// &gt; 1200
// &gt; 1200
// &gt; 1200
// &gt; 1200.1
// &gt; 0.12001
// &gt; 0.000011111</summary>
    
    
    
    <category term="前端" scheme="https://www.pswen.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="正则" scheme="https://www.pswen.cn/tags/%E6%AD%A3%E5%88%99/"/>
    
    <category term="js" scheme="https://www.pswen.cn/tags/js/"/>
    
    <category term="去除零" scheme="https://www.pswen.cn/tags/%E5%8E%BB%E9%99%A4%E9%9B%B6/"/>
    
  </entry>
  
  <entry>
    <title>单词接龙——leetcode127</title>
    <link href="https://www.pswen.cn/p/fbb9fe6d/"/>
    <id>https://www.pswen.cn/p/fbb9fe6d/</id>
    <published>2022-01-09T10:38:08.000Z</published>
    <updated>2023-02-23T15:19:10.459Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述">#</a> 题目描述</h1><p>字典 wordList 中从单词 beginWord 和 endWord 的 转换序列 是一个按下述规格形成的序列：<br>序列中第一个单词是  <code>beginWord</code>  。<br>序列中最后一个单词是  <code>endWord</code> 。<br>每次转换只能改变一个字母。<br>转换过程中的中间单词必须是字典  <code>wordList</code>  中的单词。<br>给你两个单词  <code>beginWord</code>  和  <code>endWord</code>  和一个字典  <code>wordList</code>  ，找到从  <code>beginWord </code> 到  <code>endWord</code>  的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回  <code>0</code> 。</p><span id="more"></span><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line">输出：5</span><br><span class="line">解释：一个最短转换序列是 &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;, 返回它的长度 5。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class="line">输出：0</span><br><span class="line">解释：endWord &quot;cog&quot; 不在字典中，所以无法进行转换。</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= beginWord.length &lt;= 10</span><br><span class="line">endWord.length == beginWord.length</span><br><span class="line">1 &lt;= wordList.length &lt;= 5000</span><br><span class="line">wordList[i].length == beginWord.length</span><br><span class="line">beginWord、endWord 和 wordList[i] 由小写英文字母组成</span><br><span class="line">beginWord != endWord</span><br><span class="line">wordList 中的所有字符串 互不相同</span><br></pre></td></tr></table></figure><h1 id="解题"><a class="markdownIt-Anchor" href="#解题">#</a> 解题</h1><h3 id="方法一广度优先搜索-优化建图"><a class="markdownIt-Anchor" href="#方法一广度优先搜索-优化建图">#</a> 方法一：广度优先搜索 + 优化建图</h3><h4 id="思路"><a class="markdownIt-Anchor" href="#思路">#</a> 思路</h4><p>本题要求的是最短转换序列的长度，看到最短首先想到的就是广度优先搜索。想到广度优先搜索自然而然的就能想到图，但是本题并没有直截了当的给出图的模型，因此我们需要把它抽象成图的模型。</p><p>我们可以把每个单词都抽象为一个点，如果两个单词可以只改变一个字母进行转换，那么说明他们之间有一条双向边。因此我们只需要把满足转换条件的点相连，就形成了一张图。</p><p>基于该图，我们以 beginWord 为图的起点，以 endWord 为终点进行广度优先搜索，寻找 beginWord 到 endWord 的最短路径。</p><h4 id="算法"><a class="markdownIt-Anchor" href="#算法">#</a> 算法</h4><p>基于上面的思路我们考虑如何编程实现。</p><p>首先为了方便表示，我们先给每一个单词标号，即给每个单词分配一个 id。创建一个由单词 word 到 id 对应的映射 wordId，并将 beginWord 与 wordList 中所有的单词都加入这个映射中。之后我们检查 endWord 是否在该映射内，若不存在，则输入无解。我们可以使用哈希表实现上面的映射关系。</p><p>然后我们需要建图，依据朴素的思路，我们可以枚举每一对单词的组合，判断它们是否恰好相差一个字符，以判断这两个单词对应的节点是否能够相连。但是这样效率太低，我们可以优化建图。</p><p>具体地，我们可以创建虚拟节点。对于单词 hit，我们创建三个虚拟节点 <em>it、h</em>t、hi*，并让 hit 向这三个虚拟节点分别连一条边即可。如果一个单词能够转化为 hit，那么该单词必然会连接到这三个虚拟节点之一。对于每一个单词，我们枚举它连接到的虚拟节点，把该单词对应的 id 与这些虚拟节点对应的 id 相连即可。</p><p>最后我们将起点加入队列开始广度优先搜索，当搜索到终点时，我们就找到了最短路径的长度。注意因为添加了虚拟节点，所以我们得到的距离为实际最短路径长度的两倍。同时我们并未计算起点对答案的贡献，所以我们应当返回距离的一半再加一的结果。</p><h4 id="代码"><a class="markdownIt-Anchor" href="#代码">#</a> 代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Map&lt;String, Integer&gt; wordId = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Integer&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; edge = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">nodeNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (String word : wordList) &#123;</span><br><span class="line">            addEdge(word);</span><br><span class="line">        &#125;</span><br><span class="line">        addEdge(beginWord);</span><br><span class="line">        <span class="keyword">if</span> (!wordId.containsKey(endWord)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] dis = <span class="keyword">new</span> <span class="title class_">int</span>[nodeNum];</span><br><span class="line">        Arrays.fill(dis, Integer.MAX_VALUE);</span><br><span class="line">        <span class="type">int</span> <span class="variable">beginId</span> <span class="operator">=</span> wordId.get(beginWord), endId = wordId.get(endWord);</span><br><span class="line">        dis[beginId] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        Queue&lt;Integer&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        que.offer(beginId);</span><br><span class="line">        <span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> que.poll();</span><br><span class="line">            <span class="keyword">if</span> (x == endId) &#123;</span><br><span class="line">                <span class="keyword">return</span> dis[endId] / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> it : edge.get(x)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dis[it] == Integer.MAX_VALUE) &#123;</span><br><span class="line">                    dis[it] = dis[x] + <span class="number">1</span>;</span><br><span class="line">                    que.offer(it);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        addWord(word);</span><br><span class="line">        <span class="type">int</span> <span class="variable">id1</span> <span class="operator">=</span> wordId.get(word);</span><br><span class="line">        <span class="type">char</span>[] array = word.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> array.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> array[i];</span><br><span class="line">            array[i] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">newWord</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(array);</span><br><span class="line">            addWord(newWord);</span><br><span class="line">            <span class="type">int</span> <span class="variable">id2</span> <span class="operator">=</span> wordId.get(newWord);</span><br><span class="line">            edge.get(id1).add(id2);</span><br><span class="line">            edge.get(id2).add(id1);</span><br><span class="line">            array[i] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addWord</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!wordId.containsKey(word)) &#123;</span><br><span class="line">            wordId.put(word, nodeNum++);</span><br><span class="line">            edge.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a class="markdownIt-Anchor" href="#复杂度分析">#</a> 复杂度分析</h4><ul><li>时间复杂度： <code>O(N×C2)</code> 。其中  N 为 wordList 的长度， C 为列表中单词的长度。</li></ul><p>建图过程中，对于每一个单词，我们需要枚举它连接到的所有虚拟节点，时间复杂度为   <code>O(C)</code> ，将这些单词加入到哈希表中，时间复杂度为  <code>O(N×C)</code> ，因此总时间复杂度为  <code>O(N×C)</code> 。</p><p>广度优先搜索的时间复杂度最坏情况下是 O (N \times C) O (N×C)。每一个单词需要拓展出 O©O© 个虚拟节点，因此节点数 O (N \times C) O (N×C)。</p><ul><li>空间复杂度： <code>O(N×C2)</code> 。其中 N 为 wordList 的长度，C 为列表中单词的长度。哈希表中包含  <code>O(N×C)</code>  个节点，每个节点占用空间  <code>O(C)</code> ，因此总的空间复杂度为  <code>O(N×C^2)</code> 。</li></ul>]]></content>
    
    
    <summary type="html"># 题目描述
字典 wordList 中从单词 beginWord 和 endWord 的 转换序列 是一个按下述规格形成的序列：
序列中第一个单词是 beginWord 。
序列中最后一个单词是 endWord 。
每次转换只能改变一个字母。
转换过程中的中间单词必须是字典 wordList 中的单词。
给你两个单词 beginWord 和 endWord 和一个字典 wordList ，找到从 beginWord 到 endWord 的 最短转换序列 中的
单词数目 。如果不存在这样的转换序列，返回 0 。</summary>
    
    
    
    <category term="算法" scheme="https://www.pswen.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="leetcode" scheme="https://www.pswen.cn/tags/leetcode/"/>
    
    <category term="算法" scheme="https://www.pswen.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="单词接龙" scheme="https://www.pswen.cn/tags/%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99/"/>
    
  </entry>
  
  <entry>
    <title>买卖股票的最佳时机 II——LeetCode122</title>
    <link href="https://www.pswen.cn/p/f883163f/"/>
    <id>https://www.pswen.cn/p/f883163f/</id>
    <published>2022-01-06T15:28:13.000Z</published>
    <updated>2023-02-23T15:19:10.375Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述">#</a> 题目描述</h1><p>给定一个数组 prices ，其中 prices [i] 是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><span id="more"></span><p>示例 1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: prices = [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br></pre></td></tr></table></figure><p>解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出，这笔交易所能获得利润 = 5-1 = 4 。<br>随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，这笔交易所能获得利润 = 6-3 = 3 。<br> <br>示例 2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: prices = [1,2,3,4,5]</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p>解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出，这笔交易所能获得利润 = 5-1 = 4 。<br>注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</p><p>示例 3:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: prices = [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><p>解释：在这种情况下，没有交易完成，所以最大利润为 0。</p><p>提示：<br>]<br>1 &lt;= prices.length &lt;= 3 * 10^4<br>0 &lt;= prices[i] &lt;= 10^4</p><h1 id="解题"><a class="markdownIt-Anchor" href="#解题">#</a> 解题</h1><h2 id="解法一动态规划"><a class="markdownIt-Anchor" href="#解法一动态规划">#</a> 解法一：动态规划</h2><h3 id="思路"><a class="markdownIt-Anchor" href="#思路">#</a> 思路</h3><p>虑到「不能同时参与多笔交易」，因此每天交易结束后只可能存在手里有一支股票或者没有股票的状态。</p><p>定义状态 <code>dp[i][0]</code>  表示第 i 天交易完后手里没有股票的最大利润， <code>dp[i][1]</code>  表示第 i 天交易完后手里持有一支股票的最大利润（i 从 0 开始）。(<strong>定义状态</strong>)</p><p>考虑 <code>dp[i][0]</code>  的转移方程，如果这一天交易完后手里没有股票，那么可能的转移状态为前一天已经没有股票，即  <code>dp[i−1][0]</code> ，或者前一天结束的时候手里持有一支股票，即  <code>dp[i−1][1]</code> ，这时候我们要将其卖出，并获得  <code>prices[i]</code>  的收益。因此为了收益最大化，我们列出如下的转移方程：</p><p><code>dp[i][0] = max&#123; dp[i−1][0] , dp[i−1][1] + prices[i]&#125;</code></p><p>再来考虑 <code>dp[i][1]</code> ，按照同样的方式考虑转移状态，那么可能的转移状态为前一天已经持有一支股票，即 <code>dp[i−1][1]</code> ，或者前一天结束时还没有股票，即  <code>dp[i−1][0]</code> ，这时候我们要将其买入，并减少 <code>prices[i]</code>  的收益。可以列出如下的转移方程：</p><p><code>dp[i][1] = max&#123; dp[i−1][1], dp[i−1][0]−prices[i] &#125;</code></p><p>对于初始状态，根据状态定义我们可以知道第 00 天交易结束的时候  <code>dp[0][0]=0</code> ， <code>dp[0][1]=−prices[0]</code> 。</p><p>因此，我们只要从前往后依次计算状态即可。由于全部交易结束后，持有股票的收益一定低于不持有股票的收益，因此这时候  <code>dp[n−1][0]</code>  的收益必然是大于 <code>dp[n−1][1]</code>  的，最后的答案即为  <code>dp[n−1][0]</code> 。</p><h3 id="解题-2"><a class="markdownIt-Anchor" href="#解题-2">#</a> 解题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="comment">// 状态定义 x为天数  y为0为当天不持有 1为当天持有</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 定义起始状态</span></span><br><span class="line">        <span class="comment">// 第一天 不持有，不花钱 收益为0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 第一天 持有，花钱 收益为当天买股票的钱</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = - prices[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 从第二天开始递推哈</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">1</span>; d &lt; n; d++) &#123;</span><br><span class="line">            <span class="comment">// 第二天不持有股票：</span></span><br><span class="line">            <span class="comment">// 第一天不持有股票的收益 + （没买）0  |  第一天持有股票 + （卖出）第二天价格 ；</span></span><br><span class="line">            dp[d][<span class="number">0</span>] = Math.max(dp[d-<span class="number">1</span>][<span class="number">0</span>], dp[d-<span class="number">1</span>][<span class="number">1</span>] + prices[d]);</span><br><span class="line">            <span class="comment">// 第二天持有股票：</span></span><br><span class="line">            <span class="comment">// 第一天不持有股票的收益 + 买入第二天价格  |  第一天持有股票 + 没买也没卖 ；</span></span><br><span class="line">            dp[d][<span class="number">1</span>] = Math.max(dp[d-<span class="number">1</span>][<span class="number">0</span>] - prices[d], dp[d-<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 持有股票的收益必定小于不持有股票</span></span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到上面的状态转移方程中，每一天的状态只与前一天的状态有关，而与更早的状态都无关，因此我们不必存储这些无关的状态，只需要将 <code>dp[i−1][0] </code> 和 <code>dp[i−1][1]</code>  存放在两个变量中，通过它们计算出 <code>dp[i][0]</code>  和 <code>dp[i][1]</code>  并存回对应的变量，以便于第 <code>i+1</code>  天的状态转移即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">dp0</span> <span class="operator">=</span> <span class="number">0</span>, dp1 = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">newDp0</span> <span class="operator">=</span> Math.max(dp0, dp1 + prices[i]);</span><br><span class="line">            <span class="type">int</span> <span class="variable">newDp1</span> <span class="operator">=</span> Math.max(dp1, dp0 - prices[i]);</span><br><span class="line">            dp0 = newDp0;</span><br><span class="line">            dp1 = newDp1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析"><a class="markdownIt-Anchor" href="#复杂度分析">#</a> 复杂度分析</h3><ul><li><p>时间复杂度： <code>O(n)</code> ，其中 n 为数组的长度。一共有 2n 个状态，每次状态转移的时间复杂度为  <code>O(1)</code> ，因此时间复杂度为 <code>O(2n)=O(n)</code> 。</p></li><li><p>空间复杂度： <code>O(n)</code> 。我们需要开辟 <code>O(n)</code>  空间存储动态规划中的所有状态。如果使用空间优化，空间复杂度可以优化至  <code>O(1)</code> 。</p></li></ul><h2 id="解法二贪心"><a class="markdownIt-Anchor" href="#解法二贪心">#</a> 解法二：贪心</h2><h3 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2">#</a> 思路</h3><h3 id="解题-3"><a class="markdownIt-Anchor" href="#解题-3">#</a> 解题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ans += Math.max(<span class="number">0</span>, prices[i] - prices[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度分析-2"><a class="markdownIt-Anchor" href="#复杂度分析-2">#</a> 复杂度分析</h3>]]></content>
    
    
    <summary type="html"># 题目描述
给定一个数组 prices ，其中 prices [i] 是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</summary>
    
    
    
    <category term="java" scheme="https://www.pswen.cn/categories/java/"/>
    
    
    <category term="leetcode" scheme="https://www.pswen.cn/tags/leetcode/"/>
    
    <category term="算法" scheme="https://www.pswen.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="贪心" scheme="https://www.pswen.cn/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="动态规划" scheme="https://www.pswen.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>路径总和 II——LeetCode113</title>
    <link href="https://www.pswen.cn/p/7d31a8bc/"/>
    <id>https://www.pswen.cn/p/7d31a8bc/</id>
    <published>2022-01-05T14:27:28.000Z</published>
    <updated>2023-02-23T15:19:10.391Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述">#</a> 题目描述</h1><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p><p>叶子节点 是指没有子节点的节点。</p><span id="more"></span><p>示例 1：</p><p><img src="/p/7d31a8bc/pathsumii1.jpg" alt></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22</span><br><span class="line">输出：[[5,4,11,2],[5,8,4,5]]</span><br></pre></td></tr></table></figure><p>示例 2：</p><p><img src="/p/7d31a8bc/pathsum2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,3], targetSum = 5</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2], targetSum = 0</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p>提示：</p><p>树中节点总数在范围 [0, 5000] 内<br> - 1000 &lt;= Node.val &lt;= 1000<br>-1000 &lt;= targetSum &lt;= 1000</p><h1 id="解题"><a class="markdownIt-Anchor" href="#解题">#</a> 解题</h1><h2 id="dfs解法"><a class="markdownIt-Anchor" href="#dfs解法">#</a> dfs 解法</h2><ul><li><p>前言<br>注意到本题的要求是，找到所有满足从「根节点」到某个「叶子节点」经过的路径上的节点之和等于目标和的路径。核心思想是对树进行一次遍历，在遍历时记录从根节点到当前节点的路径和，以防止重复计算。</p></li><li><p>思路及算法</p><p>我们可以采用深度优先搜索的方式，枚举每一条从根节点到叶子节点的路径。当我们遍历到叶子节点，且此时路径和恰为目标和时，我们就找到了一条满足条件的路径。</p></li><li><p>代码实现</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    Deque&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        dfs(root, targetSum);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path.offerLast(root.val);</span><br><span class="line">        targetSum -= root.val;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span> &amp;&amp; targetSum == <span class="number">0</span>) &#123;</span><br><span class="line">            ret.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;(path));</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.left, targetSum);</span><br><span class="line">        dfs(root.right, targetSum);</span><br><span class="line">        path.pollLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>复杂度分析</li></ul><p>复杂度分析</p><p>时间复杂度： <code>O(N^2)</code> ・，其中 N 是树的节点数。在最坏情况下，树的上半部分为链状，下半部分为完全二叉树，并且从根节点到每一个叶子节点的路径都符合题目要求。此时，路径的数目为  <code>O(N)</code> ，并且每一条路径的节点个数也为 O (N) O (N)，因此要将这些路径全部添加进答案中，时间复杂度为  <code>O(N^2)</code></p><p>空间复杂度： <code>O(N)</code> ，其中 N 是树的节点数。空间复杂度主要取决于栈空间的开销，栈中的元素个数不会超过树的节点数。</p><h2 id="bfs解法"><a class="markdownIt-Anchor" href="#bfs解法">#</a> bfs 解法</h2><ul><li>思路及算法</li></ul><p>我们也可以采用广度优先搜索的方式，遍历这棵树。当我们遍历到叶子节点，且此时路径和恰为目标和时，我们就找到了一条满足条件的路径。</p><p>为了节省空间，我们使用哈希表记录树中的每一个节点的父节点。每次找到一个满足条件的节点，我们就从该节点出发不断向父节点迭代，即可还原出从根节点到当前节点的路径。</p><ul><li>代码实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    Map&lt;TreeNode, TreeNode&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;TreeNode, TreeNode&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queueNode = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; queueSum = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        queueNode.offer(root);</span><br><span class="line">        queueSum.offer(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queueNode.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queueNode.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">rec</span> <span class="operator">=</span> queueSum.poll() + node.val;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rec == targetSum) &#123;</span><br><span class="line">                    getPath(node);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    map.put(node.left, node);</span><br><span class="line">                    queueNode.offer(node.left);</span><br><span class="line">                    queueSum.offer(rec);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    map.put(node.right, node);</span><br><span class="line">                    queueNode.offer(node.right);</span><br><span class="line">                    queueSum.offer(rec);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getPath</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            temp.add(node.val);</span><br><span class="line">            node = map.get(node);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(temp);</span><br><span class="line">        ret.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;(temp));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>复杂度分析</li></ul><p>时间复杂度： <code>O(N^2)</code> ，其中 NN 是树的节点数。分析思路与方法一相同。</p><p>空间复杂度： <code>O(N)</code> ，其中 NN 是树的节点数。空间复杂度主要取决于哈希表和队列空间的开销，哈希表需要存储除根节点外的每个节点的父节点，队列中的元素个数不会超过树的节点数</p>]]></content>
    
    
    <summary type="html"># 题目描述
给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。

叶子节点 是指没有子节点的节点。</summary>
    
    
    
    <category term="java" scheme="https://www.pswen.cn/categories/java/"/>
    
    
    <category term="leetcode" scheme="https://www.pswen.cn/tags/leetcode/"/>
    
    <category term="树" scheme="https://www.pswen.cn/tags/%E6%A0%91/"/>
    
    <category term="dfs" scheme="https://www.pswen.cn/tags/dfs/"/>
    
    <category term="bfs" scheme="https://www.pswen.cn/tags/bfs/"/>
    
  </entry>
  
  <entry>
    <title>复原IP地址——LeetCode93</title>
    <link href="https://www.pswen.cn/p/ab179abd/"/>
    <id>https://www.pswen.cn/p/ab179abd/</id>
    <published>2022-01-04T13:58:27.000Z</published>
    <updated>2023-02-23T15:19:10.439Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述">#</a> 题目描述</h1><p>有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。</p><p>例如：“0.1.2.201” 和 “192.168.1.1” 是 有效 IP 地址，但是 “0.011.255.245”、“192.168.1.312” 和 “192.168@1.1” 是 无效 IP 地址。<br>给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 ‘.’ 来形成。你不能重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。</p><span id="more"></span><h2 id="用例"><a class="markdownIt-Anchor" href="#用例">#</a> 用例</h2><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;25525511135&quot;</span><br><span class="line">输出：[&quot;255.255.11.135&quot;,&quot;255.255.111.35&quot;]</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;0000&quot;</span><br><span class="line">输出：[&quot;0.0.0.0&quot;]</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;1111&quot;</span><br><span class="line">输出：[&quot;1.1.1.1&quot;]</span><br></pre></td></tr></table></figure><p>示例 4：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;010010&quot;</span><br><span class="line">输出：[&quot;0.10.0.10&quot;,&quot;0.100.1.0&quot;]</span><br></pre></td></tr></table></figure><p>示例 5：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;101023&quot;</span><br><span class="line">输出：[&quot;1.0.10.23&quot;,&quot;1.0.102.3&quot;,&quot;10.1.0.23&quot;,&quot;10.10.2.3&quot;,&quot;101.0.2.3&quot;]</span><br></pre></td></tr></table></figure><p>提示：</p><p>0 &lt;= s.length &lt;= 20<br>s 仅由数字组成</p><h1 id="解题"><a class="markdownIt-Anchor" href="#解题">#</a> 解题</h1><h2 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路">#</a> 解题思路</h2><p>由于我们需要找出所有可能复原出的 IP 地址，因此可以考虑使用<strong>回溯</strong>的方法，对<strong>所有可能的字符串分隔方式</strong>进行搜索，并筛选出满足要求的作为答案。</p><p>设题目中给出的字符串为 s。我们用递归函数  <code>dfs(segId,segStart)</code>  表示我们正在从 <code>s[segStart] </code> 的位置开始，搜索 IP 地址中的第 segId 段，其中 <code>segId∈&#123;0,1,2,3&#125;</code> 。由于 IP 地址的每一段必须是  <code>[0, 255] </code> 中的整数，因此我们从 segStart 开始，从小到大依次枚举当前这一段 IP 地址的结束位置 segEnd。如果满足要求，就递归地进行下一段搜索，调用递归函数 <code>dfs(segId+1,segEnd+1)</code> 。</p><p>特别地，由于 IP 地址的每一段不能有前导零，因此如果  <code>s[segStart]</code>  等于字符 0，那么 IP 地址的第 segId 段只能为 0，需要作为特殊情况进行考虑。</p><p>在搜索的过程中，如果我们已经得到了全部的 4 段 IP 地址（即 segId=4），并且遍历完了整个字符串（即  <code>segStart=∣s∣</code> ，其中  <code>|s|</code>  表示字符串 s 的长度），那么就复原出了一种满足题目要求的 IP 地址，我们将其加入答案。在其它的时刻，如果提前遍历完了整个字符串，那么我们需要结束搜索，回溯到上一步。</p><h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现">#</a> 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SEG_COUNT</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">    List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    <span class="type">int</span>[] segments = <span class="keyword">new</span> <span class="title class_">int</span>[SEG_COUNT];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">restoreIpAddresses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        segments = <span class="keyword">new</span> <span class="title class_">int</span>[SEG_COUNT];</span><br><span class="line">        dfs(s, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(String s, <span class="type">int</span> segId, <span class="type">int</span> segStart)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果找到了 4 段 IP 地址并且遍历完了字符串，那么就是一种答案</span></span><br><span class="line">        <span class="keyword">if</span> (segId == SEG_COUNT) &#123;</span><br><span class="line">            <span class="keyword">if</span> (segStart == s.length()) &#123;</span><br><span class="line">                <span class="type">StringBuffer</span> <span class="variable">ipAddr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; SEG_COUNT; ++i) &#123;</span><br><span class="line">                    ipAddr.append(segments[i]);</span><br><span class="line">                    <span class="keyword">if</span> (i != SEG_COUNT - <span class="number">1</span>) &#123;</span><br><span class="line">                        ipAddr.append(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ans.add(ipAddr.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果还没有找到 4 段 IP 地址就已经遍历完了字符串，那么提前回溯</span></span><br><span class="line">        <span class="keyword">if</span> (segStart == s.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由于不能有前导零，如果当前数字为 0，那么这一段 IP 地址只能为 0</span></span><br><span class="line">        <span class="keyword">if</span> (s.charAt(segStart) == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            segments[segId] = <span class="number">0</span>;</span><br><span class="line">            dfs(s, segId + <span class="number">1</span>, segStart + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一般情况，枚举每一种可能性并递归</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">addr</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">segEnd</span> <span class="operator">=</span> segStart; segEnd &lt; s.length(); ++segEnd) &#123;</span><br><span class="line">            addr = addr * <span class="number">10</span> + (s.charAt(segEnd) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (addr &gt; <span class="number">0</span> &amp;&amp; addr &lt;= <span class="number">0xFF</span>) &#123;</span><br><span class="line">                segments[segId] = addr;</span><br><span class="line">                dfs(s, segId + <span class="number">1</span>, segEnd + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a class="markdownIt-Anchor" href="#复杂度分析">#</a> 复杂度分析</h2><p>复杂度分析</p><p>我们用 SEG_COUNT=4 表示 IP 地址的段数。</p><p>时间复杂度： <code>O(3^SEG_COUNT × ∣s∣)</code> 。由于 IP 地址的每一段的位数不会超过 3，因此在递归的每一层，我们最多只会深入到下一层的 33 种情况。由于 SEG_COUNT=4，对应着递归的最大层数。如果我们复原出了一种满足题目要求的 IP 地址，那么需要  <code>O(∣s∣) </code> 的时间将其加入答案数组中，因此总时间复杂度为 <code>O(3 ^SEG_COUNT ×∣s∣)</code> 。</p><p>空间复杂度： <code>O(SEG_COUNT)</code> ，这里只计入除了用来存储答案数组以外的额外空间复杂度。递归使用的空间与递归的最大深度 \text {SEG_COUNT} SEG_COUNT 成正比。并且在上面的代码中，我们只额外使用了长度为  <code>SEG_COUNT</code>  的数组  <code>segments</code>  存储已经搜索过的 IP 地址，因此空间复杂度为 <code>O(SEG_COUNT)</code> 。</p>]]></content>
    
    
    <summary type="html"># 题目描述
有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。

例如：“0.1.2.201” 和 “192.168.1.1” 是 有效 IP 地址，但是 “0.011.255.245”、“192.168.1.312” 和
“192.168@1.1” 是 无效 IP 地址。
给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 ‘.’ 来形成。你不能重新排序或删除
s 中的任何数字。你可以按 任何 顺序返回答案。</summary>
    
    
    
    <category term="java" scheme="https://www.pswen.cn/categories/java/"/>
    
    
    <category term="leetcode" scheme="https://www.pswen.cn/tags/leetcode/"/>
    
    <category term="算法" scheme="https://www.pswen.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="回溯" scheme="https://www.pswen.cn/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>最长回文子串——Leetcode5</title>
    <link href="https://www.pswen.cn/p/dfd6ab93/"/>
    <id>https://www.pswen.cn/p/dfd6ab93/</id>
    <published>2022-01-03T06:28:19.000Z</published>
    <updated>2023-02-23T15:19:10.379Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述">#</a> 题目描述</h1><p>给你一个字符串 s，找到 s 中最长的回文子串。</p><span id="more"></span><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;babad&quot;</span><br><span class="line">输出：&quot;bab&quot;</span><br><span class="line">解释：&quot;aba&quot; 同样是符合题意的答案。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;cbbd&quot;</span><br><span class="line">输出：&quot;bb&quot;</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;a&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure><p>示例 4：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;ac&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure><p>提示：</p><p><code>1 &lt;= s.length &lt;= 1000</code> <br>s 仅由数字和英文字母（大写和 / 或小写）组成</p><h1 id="解题"><a class="markdownIt-Anchor" href="#解题">#</a> 解题</h1><h2 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路">#</a> 解题思路</h2><p>对于一个子串而言，如果它是回文串，并且长度大于 22，那么将它首尾的两个字母去除之后，它仍然是个回文串。例如对于字符串 “ababa”，如果我们已经知道 “bab” 是回文串，那么 “ababa” 一定是回文串，这是因为它的首尾两个字母都是 “a”。</p><p>根据这样的思路，我们就可以用动态规划的方法解决本题。我们用  <code>P(i,j) </code> 表示字符串 s 的第 i 到 j 个字母组成的串（下文表示成  <code>s[i:j]</code> ）是否为回文串：如果字符串 s 从 i 到 j 是回文串，那么 <code>P(i,j)= true</code> ，否则为 <code>P(i,j)= true</code> ；</p><p>这里的「否」包含两种可能性：</p><ul><li><p><code>s[i,j]</code>  本身不是一个回文串；</p></li><li><p><code>i&gt;j</code> ，此时  <code>s[i,j]</code>  本身不合法。</p></li></ul><p>那么我们就可以写出动态规划的状态转移方程：</p><p><img src="/p/dfd6ab93/image-20220104210656306.png" alt="状态转移方程"></p><p>也就是说，只有  <code>s[i+1:j−1] </code> 是回文串，并且  <code>s</code>  的第 <code>i</code>  和  <code>j</code>  个字母相同时， <code>s[i:j]</code>  才会是回文串。</p><p>上文的所有讨论是建立在子串长度大于 2 的前提之上的，我们还需要考虑动态规划中的<strong>边界条件</strong>，即子串的长度为 1 或 2。</p><ul><li><p>对于长度为 1 的子串，它显然是个回文串；</p></li><li><p>对于长度为 2 的子串，只要它的两个字母相同，它就是一个回文串。</p></li></ul><p>因此我们就可以写出动态规划的边界条件：</p><p><img src="/p/dfd6ab93/image-20220104210730308.png" alt="边界条件"></p><p>根据这个思路，我们就可以完成动态规划了，最终的答案即为所有 <code> P(i, j) = true</code>  中  <code>j−i+1</code> （即子串长度）的最大值。注意：在状态转移方程中，我们是从长度较短的字符串向长度较长的字符串进行转移的，因此一定要注意动态规划的循环顺序。</p><h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现">#</a> 代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// dp[i][j] 表示 s[i..j] 是否是回文串</span></span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[len][len];</span><br><span class="line">        <span class="comment">// 初始化：所有长度为 1 的子串都是回文串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>[] charArray = s.toCharArray();</span><br><span class="line">        <span class="comment">// 递推开始</span></span><br><span class="line">        <span class="comment">// 先枚举子串长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> <span class="number">2</span>; L &lt;= len; L++) &#123;</span><br><span class="line">            <span class="comment">// 枚举左边界，左边界的上限设置可以宽松一些</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                <span class="comment">// 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> L + i - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 如果右边界越界，就可以退出当前循环</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt;= len) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (charArray[i] != charArray[j]) &#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j - i &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置</span></span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; maxLen) &#123;</span><br><span class="line">                    maxLen = j - i + <span class="number">1</span>;</span><br><span class="line">                    begin = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(begin, begin + maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a class="markdownIt-Anchor" href="#复杂度分析">#</a> 复杂度分析</h2><p>时间复杂度： <code>O(n^2) </code> 其中 n 是字符串的长度。动态规划的状态总数为  <code>O(n^2)</code>  对于每个状态，我们需要转移的时间为  <code>O(1)</code> 。</p><p>空间复杂度： <code>O(n^2)</code> ，即存储动态规划状态需要的空间。</p>]]></content>
    
    
    <summary type="html">给你一个字符串 s，找到 s 中最长的回文子串。</summary>
    
    
    
    <category term="java" scheme="https://www.pswen.cn/categories/java/"/>
    
    
    <category term="leetcode" scheme="https://www.pswen.cn/tags/leetcode/"/>
    
    <category term="算法" scheme="https://www.pswen.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="动态规划" scheme="https://www.pswen.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>linux生产免费的域名证书</title>
    <link href="https://www.pswen.cn/p/4425fc35/"/>
    <id>https://www.pswen.cn/p/4425fc35/</id>
    <published>2021-12-29T13:59:07.000Z</published>
    <updated>2023-02-23T15:19:10.375Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://xn--acme-kt0gs67hmo3a2r1a.sh">简单来说 acme.sh</a> 实现了 acme 协议，可以从 let‘s encrypt 生成免费的证书。<br><a href="http://acme.sh">acme.sh</a> 有以下特点：<br>一个纯粹用 Shell（Unix shell）语言编写的 ACME 协议客户端。<br>完整的 ACME 协议实施。 支持 ACME v1 和 ACME v2 支持 ACME v2 通配符证书<br>简单，功能强大且易于使用。你只需要 3 分钟就可以学习它。<br>Let’s Encrypt 免费证书客户端最简单的 shell 脚本。<br>纯粹用 Shell 编写，不依赖于 python 或官方的 Let’s Encrypt 客户端。<br>只需一个脚本即可自动颁发，续订和安装证书。 不需要 root/sudoer 访问权限。<br>支持在 Docker 内使用，支持 IPv6</p><span id="more"></span><p><strong>安装环境：</strong><br><strong>操作系统：centos 7 X64</strong><br><strong>SSL 证书来源：Let’s Encrypt</strong><br><strong> 安装用脚本：<a href="http://acme.sh">acme.sh</a></strong><br><strong> 服务器：nginx</strong><br><strong> 域名：<a href="http://epoint.pswen.cn">epoint.pswen.cn</a></strong></p><p><a href="http://1.xn--acme-ke9g492u.sh">1. 安装 acme.sh</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://get.acme.sh | sh</span><br></pre></td></tr></table></figure><p>2. 安装后的配置<br>把 <a href="http://acme.sh">acme.sh</a> 安装到你的 home 目录下:~/.acme.sh/ 并创建 一个 bash 的 alias, 方便你的使用:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alias acme.sh=~/.acme.sh/acme.sh</span><br><span class="line">echo &#x27;alias acme.sh=~/.acme.sh/acme.sh&#x27; &gt;&gt;/etc/profile</span><br></pre></td></tr></table></figure><p>3. 申请证书<br><a href="http://acme.sh"> acme.sh</a> 实现了 acme 协议支持的所有验证协议。一般有两种方式验证: http 和 dns 验证（本文不提供 dns 方式申请，dns 手动模式，不能自动更新证书。在续订证书时，您必须手动向域中添加新的 txt 记录。）</p><p>HTTP 方式方法如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acme.sh --issue -d epoint.pswen.cn --webroot /nginx网站根目录</span><br></pre></td></tr></table></figure><p>只需要指定域名，并指定域名所在的网站根目录【命令中根目录路径】. <a href="http://acme.sh">acme.sh</a> 会全自动的生成验证文件，并放到网站的根目录，然后自动完成验证。最后会聪明的删除验证文件。整个过程没有任何副作用.</p><p>4. 证书的安装<br>注意，默认生成的证书都放在安装目录下: ~/.acme.sh/, 请不要直接使用此目录下的文件，<br> 例如：不要直接让 nginx/apache 的配置文件使用这下面的文件.<br> 这里面的文件都是内部使用，而且目录结构可能会变化.</p><p>正确的使用方法是使用 --installcert 命令，并指定目标位置，然后证书文件会被 copy 到相应的位置，</p><p>Nginx 服务： <code>service nginx force-reload</code> 。(centos6)</p><p>Nginx 服务： <code>systemctl restart nginx </code> 。(centos7)</p><p>nginx 示例 1:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acme.sh --installcert -d epoint.pswen.cn --key-file /usr/local/nginx/ssl_cert/epoint.pswen.cn.key --fullchain-file /usr/local/nginx/ssl_cert/epoint.pswen.cn.cer --reloadcmd &quot;service nginx force-reload&quot;</span><br></pre></td></tr></table></figure><p>nginx 示例 2：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">acme.sh --install-cert -d chandao.test.com \</span><br><span class="line">--key-file /usr/local/nginx/ssl_cert/test.com/chandao.test.com.key \</span><br><span class="line">--fullchain-file /usr/local/nginx/ssl_cert/test.com/chandao.test.com.cer \</span><br><span class="line">--reloadcmd      <span class="string">&quot;service nginx force-reload&quot;</span></span><br></pre></td></tr></table></figure><p>附带完成前面 1-4 步骤的截图：</p><p><img src="/p/4425fc35/867078-20190326175923357-720763416.png" alt="img"></p><ol start="5"><li>Nginx 服务器安装 SSL 证书</li></ol><p>Nginx 配置 Http 和 Https 共存</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">listen 80; #如果硬性要求全部走https协议，这一行去除</span><br><span class="line">listen 443 ssl http2; #如果硬性要求全部走https协议，这里去除ssl</span><br><span class="line">server_name chandao.test.com;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ssl on; <span class="comment">#如果硬性要求全部走https协议，这里开启ssl on</span></span></span><br><span class="line">ssl_certificate /usr/local/nginx/ssl_cert/test.com/chandao.test.com.cer;</span><br><span class="line">ssl_certificate_key /usr/local/nginx/ssl_cert/test.com/chandao.test.com.key;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ssl性能调优</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">nginx 1.13.0支持了TLSv1.3,TLSv1.3相比之前的TLSv1.2、TLSv1.1等性能大幅提升</span></span><br><span class="line">ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">ssl_ciphers EECDH+CHACHA20:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5;</span><br><span class="line">ssl_prefer_server_ciphers on;</span><br><span class="line">ssl_session_timeout 10m;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用ssl_session_cache优化https下Nginx的性能</span></span><br><span class="line">ssl_session_cache builtin:1000 shared:SSL:10m;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">OCSP Stapling 开启。OCSP是用于在线查询证书吊销情况的服务，使用OCSP Stapling能将证书有效状态的信息缓存到服务器，提高 TLS 握手速度</span></span><br><span class="line">ssl_stapling on;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">OCSP Stapling 验证开启</span></span><br><span class="line">ssl_stapling_verify on; </span><br></pre></td></tr></table></figure><p>完整例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 80;  #如果硬性要求全部走https协议，这一行去除</span><br><span class="line">  listen       443 ssl http2;    #如果硬性要求全部走https协议，这里去除ssl</span><br><span class="line">  server_name chandao.test.com;</span><br><span class="line">  access_log off;</span><br><span class="line">  index index.html index.htm index.php;</span><br><span class="line">  root /data/wwwroot/chandao;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">ssl on;   <span class="comment">#如果硬性要求全部走https协议，这里开启ssl on</span></span></span><br><span class="line">  ssl_certificate   /usr/local/nginx/ssl_cert/test.com/chandao.test.com.cer;</span><br><span class="line">  ssl_certificate_key  /usr/local/nginx/ssl_cert/test.com/chandao.test.com.key;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">ssl性能调优</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">nginx 1.13.0支持了TLSv1.3,TLSv1.3相比之前的TLSv1.2、TLSv1.1等性能大幅提升</span></span><br><span class="line">  ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">  ssl_ciphers EECDH+CHACHA20:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5;</span><br><span class="line">  ssl_prefer_server_ciphers on;</span><br><span class="line">  ssl_session_timeout 10m;</span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">使用ssl_session_cache优化https下Nginx的性能</span></span><br><span class="line">  ssl_session_cache builtin:1000 shared:SSL:10m;</span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">OCSP Stapling 开启。OCSP是用于在线查询证书吊销情况的服务，使用OCSP Stapling能将证书有效状态的信息缓存到服务器，提高 TLS 握手速度</span></span><br><span class="line">  ssl_stapling on;</span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">OCSP Stapling 验证开启</span></span><br><span class="line">  ssl_stapling_verify on; </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">error_page 404 /404.html;</span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash">error_page 502 /502.html;</span></span><br><span class="line"></span><br><span class="line">  location ~ [^/]\.php(/|$) &#123;</span><br><span class="line">    #fastcgi_pass remote_php_ip:9000;</span><br><span class="line">    fastcgi_pass unix:/dev/shm/php-cgi.sock;</span><br><span class="line">    fastcgi_index index.php;</span><br><span class="line">    include fastcgi.conf;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  location ~ .*\.(gif|jpg|jpeg|png|bmp|swf|flv|mp4|ico)$ &#123;</span><br><span class="line">    expires 30d;</span><br><span class="line">    access_log off;</span><br><span class="line">  &#125;</span><br><span class="line">  location ~ .*\.(js|css)?$ &#123;</span><br><span class="line">    expires 7d;</span><br><span class="line">    access_log off;</span><br><span class="line">  &#125;</span><br><span class="line">  location ~ /\.ht &#123;</span><br><span class="line">    deny all;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6. 重启 nginx<br> 保存退出后，通过 nginx -t 来检查配置文件是否正确，有错误的话改之即可。配置文件检测正确之后，通过 service nginx force-reload 来重载配置文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nginx -t</span><br><span class="line">systemctl restart nginx</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Linux下使用acme.sh 配置https 免费证书</summary>
    
    
    
    
    <category term="linux" scheme="https://www.pswen.cn/tags/linux/"/>
    
    <category term="acmesh" scheme="https://www.pswen.cn/tags/acmesh/"/>
    
    <category term="域名证书" scheme="https://www.pswen.cn/tags/%E5%9F%9F%E5%90%8D%E8%AF%81%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>Java位运算原理及使用讲解</title>
    <link href="https://www.pswen.cn/p/7670a0f/"/>
    <id>https://www.pswen.cn/p/7670a0f/</id>
    <published>2021-12-29T12:02:53.000Z</published>
    <updated>2023-02-23T15:19:10.375Z</updated>
    
    <content type="html"><![CDATA[<p>日常开发中位运算不是很常用，但是巧妙的使用位运算可以大量减少运行开销，优化算法。举个例子，翻转操作比较常见，比如初始值为 1，操作一次变为 0，再操作一次变为 1。可能的做法是使用三木运算符，判断原始值为 1 还是 0，如果是 1，设置为 0，否则设置为 0. 但是使用位运算，不用判断原始值，直接改变值就可以： <code>1^num </code> ,num 为原始值。当然，一条语句可能对代码没什么影响，但是在高重复，大数据量的情况下将会节省很多开销。</p><span id="more"></span><h1 id="1-位运算符"><a class="markdownIt-Anchor" href="#1-位运算符">#</a> 1. 位运算符</h1><h2 id="11-java支持的位运算符"><a class="markdownIt-Anchor" href="#11-java支持的位运算符">#</a> 1.1 java 支持的位运算符：</h2><p>&amp;：按位与。</p><p>|：按位或。</p><p>~：按位非。</p><p>^：按位异或。</p><p>&lt;&lt;：左位移运算符。</p><p>&gt;&gt;：右位移运算符。</p><p>&lt;&lt;&lt;：无符号右移运算符。</p><p>位运 算 符 中，除 ～ 以 外，其余 均 为 二 元 运 算 符 。 操 作 数 只 能 为 整 型 和字 符 型 数 据 。</p><p>Java 使用 补 码 来 表 示 二 进 制 数，在补 码 表 示 中，最高 位 为 符号 位，正数 的 符 号 位 为 0, 负数 为 1。补 码 的 规 定 如 下 :</p><p>对 正 数 来 说，最高位为 0, 其余 各 位 代 表 数 值 本 身 (以二 进制 表 示), 如 +42 的补码 为 00101010。</p><p>对 负 数 而 言，把该 数 绝 对 值 的 补 码 按 位 取 反，然后 对 整 个数 加 1, 即得 该 数的 补 码 。 如 -1 的补 码 为 11111111111111111111111111111111 (00000000000000000000000000000001 按 位 取 反 11111111111111111111111111111110+1=11111111111111111111111111111111)。为何有那么多 0、1，java 中 int 是 32 位的。</p><h2 id="12-按位与"><a class="markdownIt-Anchor" href="#12-按位与">#</a> 1.2  按位与（&amp;）</h2><p>按位与的运算规则</p><table><thead><tr><th>操作数 1</th><th>0</th><th>0</th><th>1</th><th>1</th></tr></thead><tbody><tr><td>操作数 2</td><td>0</td><td>1</td><td>0</td><td>1</td></tr><tr><td>按位与</td><td>0</td><td>0</td><td>0</td><td>1</td></tr></tbody></table><p>规则总结：只有两个操作数对应位同为 1 时，结果为 1，其余全为 0. （或者是只要有一个操作数为 0，结果就为 0）。</p><p>举例：</p><p><img src="/p/7670a0f/Center.png" alt="img"></p><p><img src="/p/7670a0f/Center-20211229200705116.png" alt="img"></p><p><img src="/p/7670a0f/Center-20211229200704972.png" alt="img"></p><h2 id="13-按位或"><a class="markdownIt-Anchor" href="#13-按位或">#</a> 1.3 按位或（|）</h2><p>按位或的运算规则</p><table><thead><tr><th>操作数 1</th><th>0</th><th>0</th><th>1</th><th>1</th></tr></thead><tbody><tr><td>操作数 2</td><td>0</td><td>1</td><td>0</td><td>1</td></tr><tr><td>按位或</td><td>0</td><td>1</td><td>1</td><td>1</td></tr></tbody></table><p>规则总结：只有两个操作数对应位同为 0 时，结果为 0，其余全为 1.（或者是只要有一个操作数为 1，结果就为 1）。</p><h2 id="14按位非~"><a class="markdownIt-Anchor" href="#14按位非~">#</a> 1.4 按位非（~）</h2><p>按位非的运算规则</p><table><thead><tr><th>操作数</th><th>0</th><th>1</th></tr></thead><tbody><tr><td>按位或</td><td>1</td><td>0</td></tr></tbody></table><p>在求负数的源码中使用过。</p><h2 id="15-按位异或"><a class="markdownIt-Anchor" href="#15-按位异或">#</a> 1.5 按位异或（^）</h2><p>按位异或的运算规则</p><table><thead><tr><th>操作数 1</th><th>0</th><th>0</th><th>1</th><th>1</th></tr></thead><tbody><tr><td>操作数 2</td><td>0</td><td>1</td><td>0</td><td>1</td></tr><tr><td>按位异或</td><td>0</td><td>1</td><td>1</td><td>0</td></tr></tbody></table><p>规则总结：异：1.</p><h2 id="16-左位移"><a class="markdownIt-Anchor" href="#16-左位移">#</a> 1.6 左位移（&lt;&lt;）</h2><p>算术右移（&gt;&gt;）: 符号位不变，低位补 0。如：2&lt;&lt;2 结果为 8。</p><p><img src="/p/7670a0f/Center-20211229200705119.png" alt="img"></p><p>当移动的位数超过数字本身的位数时，那么不就都需要补 0 操作，实际上不是的，java 不可能做那么浪费资源的事情。在真正执行位移前，其对要移动的位数做了一些预处理，比如 32 处理为 0，-1 处理为 31.</p><h2 id="17-右位移"><a class="markdownIt-Anchor" href="#17-右位移">#</a> 1.7 右位移（&gt;&gt;）</h2><p>低位溢出，符号位不变，并用符号位补溢出的高位。如：-6&gt;&gt;2 结果为 - 2。</p><p><img src="/p/7670a0f/Center-20211229200705083.png" alt="img"></p><h2 id="18-无符号右移"><a class="markdownIt-Anchor" href="#18-无符号右移">#</a> 1.8 无符号右移（&gt;&gt;&gt;）</h2><p>低位溢出，高位补 0。注意，无符号右移（&gt;&gt;&gt;）中的符号位（最高位）也跟着变，无符号的意思是将符号位当作数字位看待。如：-1&gt;&gt;&gt;1 结果为 2147483647。这个数字应该比较熟悉，看两个输出语句就知道是什么了：</p><p><code>System.out.println(Integer.toBinaryString(-1&gt;&gt;&gt;1));</code></p><p><code>System.out.println(Integer.toBinaryString(Integer.MAX_VALUE));</code></p><p>输出结果为：</p><p>1111111111111111111111111111111</p><p>1111111111111111111111111111111</p><p>-1&gt;&gt;&gt;1 竟然得到了 int 所能表示的最大整数，精彩。</p><p><img src="/p/7670a0f/Center-20211229200704949.png" alt="img"></p><p>除了使用 - 1&gt;&gt;&gt;1 能得到 Integer.MAX_VALUE，以下的也能得到同样的结果：</p><p>​    //maxInt</p><p>​    System.<em>out</em>.println(~(1 &lt;&lt; 31));</p><p>​    System.<em>out</em>.println((1 &lt;&lt; -1)-1);</p><p>​    System.<em>out</em>.println(~(1 &lt;&lt; -1));</p><p>使用位运算往往能很巧妙的实现某些算法完成一些复杂的功能。</p><h1 id="常见使用"><a class="markdownIt-Anchor" href="#常见使用">#</a> 常见使用</h1><h2 id="1-m2n"><a class="markdownIt-Anchor" href="#1-m2n">#</a> 1.   m*2^n</h2><p>可以使用 m&lt;&lt;n 求得结果，如：</p><p>​    System.<em>out</em>.println(“2^3=” + (1&lt;&lt;3));//2^3=8</p><p>​    System.<em>out</em>.println(&quot;3<em>2^3=&quot; + (3&lt;&lt;3));//3</em>2^3=24</p><p>计算结果是不是很正确呢？如果非要说 2&lt;&lt;-1 为什么不等于 0.5，前面说过，位运算的操作数只能是整型和字符型。在求 int 所能表示的最小值时，可以使用</p><p>//minInt</p><p>System.<em>out</em>.println(1 &lt;&lt; 31);</p><p>System.<em>out</em>.println(1 &lt;&lt; -1);</p><p>可以发现左移 31 位和 - 1 位所得的结果是一样的，同理，左移 30 位和左移 - 2 所得的结果也是一样的。移动一个负数位，是不是等同于右移该负数的绝对值位呢？输出一下就能发现不是的。java 中 int 所能表示的最大数值是 31 位，加上符号位共 32 位。在这里可以有这样的位移法则：</p><p>法则一：任何数左移（右移）32 的倍数位等于该数本身。</p><p>法则二：在位移运算 m&lt;&lt;n 的计算中，若 n 为正数，则实际移动的位数为 n%32，若 n 为负数，则实际移动的位数为 (32+n%32)，右移，同理。</p><p>左移是乘以 2 的幂，对应着右移则是除以 2 的幂。</p><h2 id="2-判断一个数n的奇偶性"><a class="markdownIt-Anchor" href="#2-判断一个数n的奇偶性">#</a> 2.   判断一个数 n 的奇偶性</h2><p>n&amp;1 == 1?” 奇数”:” 偶数”</p><p>为什么与 1 能判断奇偶？所谓的二进制就是满 2 进 1，那么好了，偶数的最低位肯定是 0（恰好满 2，对不对？），同理，奇数的最低位肯定是 1.int 类型的 1，前 31 位都是 0，无论是 1&amp;0 还是 0&amp;0 结果都是 0，那么有区别的就是 1 的最低位上的 1 了，若 n 的二进制最低位是 1（奇数）与上 1，结果为 1，反则结果为 0.</p><h2 id="3-不用临时变量交换两个数"><a class="markdownIt-Anchor" href="#3-不用临时变量交换两个数">#</a> 3.   不用临时变量交换两个数</h2><p>在 int [] 数组首尾互换中，是不看到过这样的代码：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure><ol><li><code>public static int[] reverse(int[] nums)&#123;</code></li><li><code>int i = 0;</code></li><li><code>int j = nums.length-1;</code></li><li><code>while(j&gt;i)&#123;</code></li><li><code>nums[i]= nums[i]^nums[j];</code></li><li><code>nums[j] = nums[j]^nums[i];</code></li><li><code>nums[i] = nums[i]^nums[j];</code></li><li><code>j--;</code></li><li><code>i++;</code></li><li><code>&#125;</code></li><li><code>return nums;</code></li><li><code>&#125;</code></li></ol><p>连续三次使用异或，并没有临时变量就完成了两个数字交换，怎么实现的呢？</p><p><img src="/p/7670a0f/Center-20211229200705072.png" alt="img"></p><p>上面的计算主要遵循了一个计算公式：b<sup>(a</sup>b)=a。</p><p>我们可以对以上公式做如下的推导：</p><p>任何数异或本身结果为 0. 且有定理 a<sup>b=b</sup>a。异或是一个无顺序的运算符，则 b<sup>a</sup>b=b<sup>b</sup>a，结果为 0^a。</p><p>再次列出异或的计算表:</p><table><thead><tr><th>操作数 1</th><th>0</th><th>0</th><th>1</th><th>1</th></tr></thead><tbody><tr><td>操作数 2</td><td>0</td><td>1</td><td>0</td><td>1</td></tr><tr><td>按位异或</td><td>0</td><td>1</td><td>1</td><td>0</td></tr></tbody></table><p>可以发现，异或 0 具有保持的特点，而异或 1 具有翻转的特点。使用这些特点可以进行取数的操作。</p><p>​     那么 0^a，使用异或 0 具有保持的特点，最终结果就是 a。</p><p>其实 java 中的异或运算法则完全遵守数学中的计算法则：</p><p>①  a ^ a =0</p><p>②  a ^ b =b ^ a</p><p>③  a ^b ^ c = a ^ (b ^ c) = (a ^ b) ^ c;</p><p>④  d = a ^b ^ c 可以推出 a = d ^ b ^ c.</p><p>⑤  a ^ b ^a = b.</p><h2 id="4-取绝对值"><a class="markdownIt-Anchor" href="#4-取绝对值">#</a> 4.   取绝对值</h2><p>(a^(a&gt;&gt;31))-(a&gt;&gt;31)</p><p>先整理一下使用位运算取绝对值的思路：若 a 为正数，则不变，需要用异或 0 保持的特点；若 a 为负数，则其补码为源码翻转每一位后 + 1，先求其源码，补码 - 1 后再翻转每一位，此时需要使用异或 1 具有翻转的特点。</p><p>任何正数右移 31 后只剩符号位 0，最终结果为 0，任何负数右移 31 后也只剩符号位 1，溢出的 31 位截断，空出的 31 位补符号位 1，最终结果为 - 1. 右移 31 操作可以取得任何整数的符号位。</p><p>那么综合上面的步骤，可得到公式。a&gt;&gt;31 取得 a 的符号，若 a 为正数，a&gt;&gt;31 等于 0，a^0=a，不变；若 a 为负数，a&gt;&gt;31 等于 - 1 ，a^-1 翻转每一位.</p>]]></content>
    
    
    <summary type="html">此篇教程主要用来详细介绍位运算相关知识</summary>
    
    
    
    
    <category term="Java" scheme="https://www.pswen.cn/tags/Java/"/>
    
    <category term="位运算" scheme="https://www.pswen.cn/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>夜中云谷</title>
    <link href="https://www.pswen.cn/p/b10a7a0e/"/>
    <id>https://www.pswen.cn/p/b10a7a0e/</id>
    <published>2021-12-18T13:06:30.000Z</published>
    <updated>2023-02-23T15:19:10.439Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/p/b10a7a0e/IMG_0119.jpg" alt="IMG_0119"></p>]]></content>
    
    
    <summary type="html">夜景下的天安云谷</summary>
    
    
    
    
    <category term="夜景" scheme="https://www.pswen.cn/tags/%E5%A4%9C%E6%99%AF/"/>
    
    <category term="图记" scheme="https://www.pswen.cn/tags/%E5%9B%BE%E8%AE%B0/"/>
    
    <category term="天安云谷" scheme="https://www.pswen.cn/tags/%E5%A4%A9%E5%AE%89%E4%BA%91%E8%B0%B7/"/>
    
  </entry>
  
  <entry>
    <title>gulp-imagemin在压缩图片</title>
    <link href="https://www.pswen.cn/p/1009bbf4/"/>
    <id>https://www.pswen.cn/p/1009bbf4/</id>
    <published>2021-11-16T14:35:58.000Z</published>
    <updated>2023-02-23T15:19:10.375Z</updated>
    
    <content type="html"><![CDATA[<p>经过各种研（bai）究（du），找到了一种方案：采用 <code>gulp + gulp-imagemin</code> ，对图片进行压缩，结合 hexo 进行对应图片压缩。</p><span id="more"></span><h3 id="安装"><a class="markdownIt-Anchor" href="#安装">#</a> 安装</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install gulp --save-dev</span><br><span class="line">npm install gulp-imagemin --save-dev</span><br><span class="line">npm install imagemin-pngquant --save-dev</span><br><span class="line"><span class="comment"># 当然也可以--save  记得要给gulp全局安装下，npm命令不行，就是用cnpm</span></span><br><span class="line">npm install gulp -g <span class="comment"># 只有gulp要全局安装下</span></span><br></pre></td></tr></table></figure><h3 id="gulpfile"><a class="markdownIt-Anchor" href="#gulpfile">#</a> gulpfile</h3><p>在 package.json 同名目录下，增加 gulpfile.js 对应的入口 js 文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gulp <span class="keyword">from</span> <span class="string">&#x27;gulp&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> imagemin <span class="keyword">from</span> <span class="string">&#x27;gulp-imagemin&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> pngquant <span class="keyword">from</span> <span class="string">&#x27;imagemin-pngquant&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个任务 第一个参数为名称，后面时要执行的动作</span></span><br><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&#x27;minify-images&#x27;</span>, <span class="keyword">function</span> (<span class="params">done</span>) &#123;</span><br><span class="line">    gulp.<span class="title function_">src</span>(<span class="string">&#x27;public/p/**/*.&#123;JPG,jpg,PNG,png,GIF,gif,SVG,svg,JPEG,jpeg&#125;&#x27;</span>)</span><br><span class="line">.<span class="title function_">pipe</span>(<span class="title function_">imagemin</span>(&#123;</span><br><span class="line"><span class="attr">optimizationLevel</span>: <span class="number">3</span>,</span><br><span class="line"><span class="attr">progressive</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="attr">usa</span>:[<span class="title function_">pngquant</span>()]</span><br><span class="line">&#125;))</span><br><span class="line">.<span class="title function_">pipe</span>(gulp.<span class="title function_">dest</span>(<span class="string">&#x27;public/p/&#x27;</span>))</span><br><span class="line">    <span class="title function_">done</span>();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 定义default ，后面将多个任务序列化并行执行，我们只有一个</span></span><br><span class="line">gulp.<span class="title function_">task</span>(<span class="string">&#x27;default&#x27;</span>, gulp.<span class="title function_">series</span>(gulp.<span class="title function_">parallel</span>(<span class="string">&#x27;minify-images&#x27;</span>)), <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">&quot;----------gulp Finished----------&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>执行命令 <code>gulp</code>  默认情况下，代表 <code>gulp default</code>  就执行你上面的 default 任务</p><p>当然你也可以制定任务名称： <code>gulp minify-images</code>  执行指定 task</p><p>然后再 hexo 状态下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hexo clean </span><br><span class="line">hexo g</span><br><span class="line">gulp</span><br><span class="line"><span class="comment"># 输出如下：</span></span><br><span class="line">[22:46:42] Using gulpfile ~/Desktop/blogfile/gulpfile.js</span><br><span class="line">[22:46:42] Starting <span class="string">&#x27;default&#x27;</span>...</span><br><span class="line">[22:46:42] Starting <span class="string">&#x27;minify-images&#x27;</span>...</span><br><span class="line">[22:46:42] Finished <span class="string">&#x27;minify-images&#x27;</span> after 74 ms</span><br><span class="line">[22:46:42] Finished <span class="string">&#x27;default&#x27;</span> after 99 ms</span><br></pre></td></tr></table></figure><p>那说明成功了</p><h3 id="遇到的坑"><a class="markdownIt-Anchor" href="#遇到的坑">#</a> 遇到的坑</h3><ul><li>引入语法问题，插件需要使用 es6 语法，故此你的 package.json 需要增加一个参数 <code>  &quot;type&quot;: &quot;module&quot;</code>  如此你可以再 gulpfile.js 中使用 es6 的 import 语法</li></ul>]]></content>
    
    
    <summary type="html">使用gulp进行图片压缩，借助gulp-imagemin插件</summary>
    
    
    
    
    <category term="gulp" scheme="https://www.pswen.cn/tags/gulp/"/>
    
    <category term="压缩图片" scheme="https://www.pswen.cn/tags/%E5%8E%8B%E7%BC%A9%E5%9B%BE%E7%89%87/"/>
    
    <category term="gulp-imagemin" scheme="https://www.pswen.cn/tags/gulp-imagemin/"/>
    
  </entry>
  
  <entry>
    <title>图记——今日午餐</title>
    <link href="https://www.pswen.cn/p/dbbc4a4a/"/>
    <id>https://www.pswen.cn/p/dbbc4a4a/</id>
    <published>2021-11-14T04:29:41.000Z</published>
    <updated>2023-02-23T15:19:10.443Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/p/dbbc4a4a/IMG_0073.JPG" alt="今日午餐"></p>]]></content>
    
    
    <summary type="html">今天兴致突来，做了一顿午饭</summary>
    
    
    
    
    <category term="图记" scheme="https://www.pswen.cn/tags/%E5%9B%BE%E8%AE%B0/"/>
    
    <category term="生活" scheme="https://www.pswen.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="午餐" scheme="https://www.pswen.cn/tags/%E5%8D%88%E9%A4%90/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机类加载机制-类加载时机</title>
    <link href="https://www.pswen.cn/p/8239/"/>
    <id>https://www.pswen.cn/p/8239/</id>
    <published>2021-11-12T14:55:27.000Z</published>
    <updated>2023-02-23T15:19:10.379Z</updated>
    
    <content type="html"><![CDATA[<p>在 Java 语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略虽然会令类加载时稍微增加一些性能开销，但是会为 Java 应用程序提供高度的灵活性，Java 里天生可以动态扩展的语言特性就是依赖于运行期动态加载和动态连接这个特点实现的。</p><span id="more"></span><p>例如，如果编写一个面向接口的应用程序，可以等到运行时再指定其实际的实现类；用户可以通过 Java 预定义的和自定义类加载器，让一个本地的应用程序可以在运行时从网络或其他地方加载一个二进制流作为程序代码的一部分，这种组装应用程序的方式目前已广泛应用于 Java 程序之中。从最基础的 Applet、JSP 到相对复杂的 OSGI 技术，都使用了 Java 语言运行期类加载的特性。</p><h2 id="类加载机制"><a class="markdownIt-Anchor" href="#类加载机制">#</a> 类加载机制</h2><p>生命周期：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialzation）、使用（Using）和卸载（Unloading）7 个阶段。</p><p><img src="/p/8239/20160719124551909.jpeg" alt="生命周期"></p><p>什么情况下需要开始进行类加载过程的第一阶段呢？没有明确约束，虚拟机自由把握；</p><p>而初始化阶段有严格规范，以下五种情况必须理解对类进行初始化。</p><ol><li>遇到 new（new 关键词实例化），getstatic（读取类的 static 字段），putstatic（设置类的 static 字段，被 final 修饰、已在编译期就把结果放入了常量池的字段除外），invokestatic（调用一个类的静态方法）</li><li>使用 <code>java.lang.reflect</code>  包的方法对类进行反射调用</li><li>初始化一个类，会先初始化它的父类</li><li>虚拟机启动时，会先初始化执行的主类（main 方法）</li><li>JDK1.7 的 <code>java.lang.invoke.MethodHandle</code>  的方法去获取句柄</li></ol><p><em><strong>有且仅有</strong></em>这五种情况，除此之外都是被动引用，不会触发初始化，举 3 个例子</p><ul><li>对于静态字段，只有定义这个字段的类才会被初始化，例如父类定义的静态字段，通过子类去使用父类的静态字段，那么只有父类会初始化，子类不会</li><li>数组类型定义使用时，类似 <code>SubClass[]</code>  不会进行初始化</li><li>被 finla 修饰的静态字段，会进行常量传播优化，实际上这个字段已经和这个类没啥关系了</li></ul><p>初始化第三种情况下，对于接口有个特例情况：一个类初始化时要求父类全部初始化，而接口，不要求其父接口全部都完成初始化，只有在使用到才会初始化。</p>]]></content>
    
    
    <summary type="html">类型的加载、连接和初始化过程都是在程序运行期间完成的</summary>
    
    
    
    
    <category term="jvm" scheme="https://www.pswen.cn/tags/jvm/"/>
    
    <category term="类加载" scheme="https://www.pswen.cn/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>环形链表——LeetCode141</title>
    <link href="https://www.pswen.cn/p/1426/"/>
    <id>https://www.pswen.cn/p/1426/</id>
    <published>2021-11-12T13:17:10.000Z</published>
    <updated>2023-02-23T15:19:10.379Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个链表，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。<br>如果链表中存在环，则返回 true 。 否则，返回 false 。<br>LeetCode-141 链接：<a href="https://leetcode-cn.com/problems/linked-list-cycle">https://leetcode-cn.com/problems/linked-list-cycle</a></p><span id="more"></span> <p>示例 1：</p><p><img src="/p/1426/circularlinkedlist.png" alt="环形链表-示例1"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">head</span> = [3,2,0,-4], pos = 1</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p>示例 2：</p><p><img src="/p/1426/circularlinkedlist_test2.png" alt="环形链表-示例2"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">head</span> = [1,2], pos = 0</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><p>示例 3：</p><p><img src="/p/1426/circularlinkedlist_test3.png" alt="环形链表-示例3"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：<span class="built_in">head</span> = [1], pos = -1</span><br><span class="line">输出：<span class="literal">false</span></span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">链表中节点的数目范围是 <span class="literal">[<span class="number">0</span>, <span class="number">104</span>]</span></span><br><span class="line">-<span class="number">105</span> &lt;= <span class="module-access"><span class="module"><span class="identifier">Node</span>.</span></span><span class="keyword">val</span> &lt;= <span class="number">105</span></span><br><span class="line">pos 为 -<span class="number">1</span> 或者链表中的一个 有效索引 。</span><br></pre></td></tr></table></figure><h3 id="解题"><a class="markdownIt-Anchor" href="#解题">#</a> 解题</h3><ol><li>Hash 表</li></ol><p>最容易想到的方法是遍历所有节点，每次遍历到一个节点时，判断该节点此前是否被访问过。</p><p>具体地，我们可以使用哈希表来存储所有已经访问过的节点。每次我们到达一个节点，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。重复这一过程，直到我们遍历完整个链表即可。</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        Set&lt;ListNode&gt; seen = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;ListNode&gt;();</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!seen.add(head)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析</p><p>时间复杂度： <code>O(N)</code> ，其中  <code>N </code> 是链表中的节点数。最坏情况下我们需要遍历每个节点一次。<br>空间复杂度： <code>O(N)</code> ，其中 <code>N </code> 是链表中的节点数。主要为哈希表的开销，最坏情况下我们需要将每个节点插入到哈希表中一次。</p><ol start="2"><li>快慢指针</li></ol><p>方法需要读者对「Floyd 判圈算法」（又称龟兔赛跑算法）有所了解。</p><p>假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。</p><p>我们可以根据上述思路来解决本题。具体地，我们定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。</p><p><img src="/p/1426/2.png" alt="龟兔赛跑"></p><blockquote><p>为什么我们要规定初始时慢指针在位置 head，快指针在位置 head.next，而不是两个指针都在位置 head（即与「乌龟」和「兔子」中的叙述相同）？</p></blockquote><ul><li>观察下面的代码，我们使用的是 while 循环，循环条件先于循环体。由于循环条件一定是判断快慢指针是否重合，如果我们将两个指针初始都置于 head，那么 while 循环就不会执行。因此，我们可以假想一个在 head 之前的虚拟节点，慢指针从虚拟节点移动一步到达 head，快指针从虚拟节点移动两步到达 head.next，这样我们就可以使用 while 循环了。</li><li>当然，我们也可以使用 do-while 循环。此时，我们就可以把快慢指针的初始值都置为 head。</li></ul><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="literal">null</span> || fast.next == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析</p><p>时间复杂度： <code>O(N)</code> ，其中  <code>N</code>  是链表中的节点数。<br>当链表中不存在环时，快指针将先于慢指针到达链表尾部，链表中每个节点至多被访问两次。<br>当链表中存在环时，每一轮移动后，快慢指针的距离将减小一。而初始距离为环的长度，因此至多移动<br> <code>N</code>  轮。<br>空间复杂度： <code>O(1)</code> 。我们只使用了两个指针的额外空间。</p>]]></content>
    
    
    <summary type="html">给定链表，用快慢指针的方式进行判断是否有环</summary>
    
    
    
    
    <category term="算法" scheme="https://www.pswen.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="快慢指针" scheme="https://www.pswen.cn/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"/>
    
    <category term="环形链表" scheme="https://www.pswen.cn/tags/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>寻找重复数——LeetCode287</title>
    <link href="https://www.pswen.cn/p/44752/"/>
    <id>https://www.pswen.cn/p/44752/</id>
    <published>2021-11-11T13:02:11.000Z</published>
    <updated>2023-02-23T15:19:10.375Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个包含 n + 1 个整数的数组 nums ，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。<br>假设 nums 只有 一个重复的整数 ，找出 这个重复的数 。<br>你设计的解决方案必须不修改数组 nums 且只用常量级 O (1) 的额外空间。<br>Leetcode-287 链接：<a href="https://leetcode-cn.com/problems/find-the-duplicate-number">https://leetcode-cn.com/problems/find-the-duplicate-number</a></p><span id="more"></span><p>示例 1：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,3,4,2,2]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,1,3,4,2]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p>示例 4：</p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">输入：nums </span>=<span class="string"> [1,1,2]</span></span><br><span class="line"><span class="string">输出：1</span></span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= n &lt;= 105</span><br><span class="line">nums.length == n + 1</span><br><span class="line">1 &lt;= nums[i] &lt;= n</span><br></pre></td></tr></table></figure><p>nums 中 只有一个整数 出现 两次或多次 ，其余整数均只出现 一次</p><h3 id="解题"><a class="markdownIt-Anchor" href="#解题">#</a> 解题</h3><ol><li>二分法</li></ol><p>针对用例 <code>[1,3,4,2,2]</code></p><p>定义一个 <code>cnt</code>  数组用来存储小于等于 索引  <code>i</code>  的总数</p><p>如果知道 cnt 数组随数字 index 逐渐增大具有单调性，那么当 num [index] 那么我们就可以直接利用二分查找来找到重复的数</p><table><thead><tr><th style="text-align:center">nums</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th></tr></thead><tbody><tr><td style="text-align:center">cnt</td><td style="text-align:center">1</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">5</td></tr></tbody></table><p>小于等于 1 的一个</p><p>小于等于 2 的三个</p><p>小于等于 3 的四个</p><p>小于等于 4 的五个</p><p>由此可见：我们的目标是 2，target 满足: target 前面的  <code>cnt[i] &lt;=  i</code> , 目标值 target 之后的  <code>cnt[i] &gt; i</code></p><p>实际上可以归纳为：</p><ul><li><p>如果测试用例的数组中  <code>target</code>  出现了两次，其余的数各出现了一次，这个时候肯定满足上文提及的性质，因为小于  <code>target</code>  的数 i 满足  <code>cnt[i]=i</code> ，大于等于  <code>target</code>  的数  <code>j</code>  满足  <code>cnt[j]=j+1</code> 。</p></li><li><p>如果测试用例的数组中 <code>target </code> 出现了三次及以上，那么必然有一些数不在  <code>nums</code>  数组中了，这个时候相当于我们用 <code>target</code>  去替换了这些数，我们考虑替换的时候对 <code>cnt[] </code> 数组的影响。如果替换的数 <code>i</code>  小于  <code>target</code>  ，那么在数 <code>i</code>  到 <code>target</code>  区间的值，均减一，其他不变，满足条件。如果替换的数  <code>j</code>  大于等于  <code>target</code> ，那么 <code>target</code>  到 数 <code>j</code>  区间内值均加一，其他不变，亦满足条件。</p></li></ul><p>因此不管多个重复还是两个重复，数组都满足那个性质。</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">1</span>, r = n - <span class="number">1</span>, ans = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">           # 右移动一位，相关于除以<span class="number">2</span>，取中间值</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">              # 将小于等于中间值都加起来  </span><br><span class="line">              <span class="keyword">if</span> (nums[i] &lt;= mid) &#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">           # 如果此时的cnt总数小于等于mid，那说明不在mid左边</span><br><span class="line">            <span class="keyword">if</span> (cnt &lt;= mid) &#123;</span><br><span class="line">               # 把左边拉到中间</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                # 否则把右边拉到中间</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">                # 记录答案</span><br><span class="line">                ans = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析</p><p>时间复杂度： <code>O(n * logn)</code> ，其中 n 为 nums 数组的长度。二分查找最多需要二分 <code>O(logn) </code> 次，每次判断的时候需要 <code>O(n)</code>  遍历 nums 数组求解小于等于 mid 的数的个数，因此总时间复杂度为 <code>O(n * logn)</code> 。</p><p>空间复杂度： <code>O(1)</code> 。我们只需要常数空间存放若干变量。</p><ol start="2"><li>快慢指针</li></ol><p>我们对 nums 数组建图，每个位置  <code>i</code>  连一条  <code>i→nums[i]</code>  的边。由于存在的重复的数字<br> <code>target</code>  因此  <code>target </code> 这个位置一定有起码两条指向它的边，因此整张图一定存在环，且我们要找到的<br> <code>target</code>  就是这个环的入口.</p><p>我们先设置慢指针 <code>slow 和快指针</code>   <code>fast</code>  ，慢指针每次走一步，快指针每次走两步，根据「Floyd 判圈算法」两个指针在有环的情况下一定会相遇，此时我们再将  <code>slow</code>  放置起点 <code>0</code> ，两个指针每次同时移动一步，相遇的点就是答案。</p><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">      # 找环的入口</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">        &#125; <span class="keyword">while</span> (slow != fast);</span><br><span class="line">        # 重置slow为起点</span><br><span class="line">        slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        # 再次相遇 就是环入口</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度分析</p><p>时间复杂度： <code>O(n)</code> 。「Floyd 判圈算法」时间复杂度为线性的时间复杂度。<br>空间复杂度： <code>O(1)</code> 。我们只需要常数空间存放若干变量。</p>]]></content>
    
    
    <summary type="html">使用二分法解决寻找重复数，练习二分法使用</summary>
    
    
    
    
    <category term="leetcode" scheme="https://www.pswen.cn/tags/leetcode/"/>
    
    <category term="算法" scheme="https://www.pswen.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="二分法" scheme="https://www.pswen.cn/tags/%E4%BA%8C%E5%88%86%E6%B3%95/"/>
    
    <category term="快慢指针" scheme="https://www.pswen.cn/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>图记——晚霞的尾巴</title>
    <link href="https://www.pswen.cn/p/4ee64d66/"/>
    <id>https://www.pswen.cn/p/4ee64d66/</id>
    <published>2021-08-27T10:50:09.000Z</published>
    <updated>2023-02-23T15:19:10.423Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/p/4ee64d66/IMG_0027.jpg" alt="晚霞的尾巴"></p>]]></content>
    
    
    <summary type="html">在下班吃晚饭，与晚霞错过</summary>
    
    
    
    
    <category term="晚霞" scheme="https://www.pswen.cn/tags/%E6%99%9A%E9%9C%9E/"/>
    
    <category term="云谷" scheme="https://www.pswen.cn/tags/%E4%BA%91%E8%B0%B7/"/>
    
  </entry>
  
  <entry>
    <title>图记——武康大楼</title>
    <link href="https://www.pswen.cn/p/9b051724/"/>
    <id>https://www.pswen.cn/p/9b051724/</id>
    <published>2021-05-16T05:50:28.000Z</published>
    <updated>2023-02-23T15:19:10.391Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/p/9b051724/IMG_4609.jpg" alt="武康大楼"></p>]]></content>
    
    
    <summary type="html">在武康大楼的留念</summary>
    
    
    
    
    <category term="武康大楼" scheme="https://www.pswen.cn/tags/%E6%AD%A6%E5%BA%B7%E5%A4%A7%E6%A5%BC/"/>
    
    <category term="上海" scheme="https://www.pswen.cn/tags/%E4%B8%8A%E6%B5%B7/"/>
    
  </entry>
  
  <entry>
    <title>往昔时光-我们</title>
    <link href="https://www.pswen.cn/p/51719/"/>
    <id>https://www.pswen.cn/p/51719/</id>
    <published>2021-02-12T05:43:18.000Z</published>
    <updated>2023-02-23T15:19:10.391Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/p/51719/IMG_4766.JPG" alt="今夕"></p><p>小时候我们唯一的合照</p>]]></content>
    
    
    <summary type="html">年轻的我们和年幼的我们</summary>
    
    
    
    
    <category term="我们" scheme="https://www.pswen.cn/tags/%E6%88%91%E4%BB%AC/"/>
    
    <category term="年轻" scheme="https://www.pswen.cn/tags/%E5%B9%B4%E8%BD%BB/"/>
    
    <category term="年幼" scheme="https://www.pswen.cn/tags/%E5%B9%B4%E5%B9%BC/"/>
    
  </entry>
  
  <entry>
    <title>图记——上海外滩</title>
    <link href="https://www.pswen.cn/p/ec5868f5/"/>
    <id>https://www.pswen.cn/p/ec5868f5/</id>
    <published>2020-05-20T13:35:39.000Z</published>
    <updated>2023-02-23T15:19:10.419Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/p/ec5868f5/IMG_4615.JPG" alt="朦胧的外滩"></p>]]></content>
    
    
    <summary type="html">在上海外滩拍照，采用模糊手法，感受不一样的美</summary>
    
    
    
    
    <category term="上海外滩" scheme="https://www.pswen.cn/tags/%E4%B8%8A%E6%B5%B7%E5%A4%96%E6%BB%A9/"/>
    
    <category term="夜景" scheme="https://www.pswen.cn/tags/%E5%A4%9C%E6%99%AF/"/>
    
  </entry>
  
  <entry>
    <title>图记——直插云霄</title>
    <link href="https://www.pswen.cn/p/6617d304/"/>
    <id>https://www.pswen.cn/p/6617d304/</id>
    <published>2019-12-30T11:50:56.000Z</published>
    <updated>2023-02-23T15:19:10.415Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/p/6617d304/IMG_4526.JPG" alt="直插云霄"></p>]]></content>
    
    
    <summary type="html">即将下雨的上海中心大厦三叉戟</summary>
    
    
    
    
    <category term="上海" scheme="https://www.pswen.cn/tags/%E4%B8%8A%E6%B5%B7/"/>
    
    <category term="三叉戟" scheme="https://www.pswen.cn/tags/%E4%B8%89%E5%8F%89%E6%88%9F/"/>
    
  </entry>
  
  <entry>
    <title>图记——大厦</title>
    <link href="https://www.pswen.cn/p/dfa3267e/"/>
    <id>https://www.pswen.cn/p/dfa3267e/</id>
    <published>2019-10-08T10:50:44.000Z</published>
    <updated>2023-02-23T15:19:10.411Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/p/dfa3267e/IMG_4474.JPG" alt="大厦"></p>]]></content>
    
    
    <summary type="html">下班路过十字路口拍摄的</summary>
    
    
    
    
    <category term="上海" scheme="https://www.pswen.cn/tags/%E4%B8%8A%E6%B5%B7/"/>
    
    <category term="陆家嘴" scheme="https://www.pswen.cn/tags/%E9%99%86%E5%AE%B6%E5%98%B4/"/>
    
  </entry>
  
  <entry>
    <title>往昔时光-大学</title>
    <link href="https://www.pswen.cn/p/4166/"/>
    <id>https://www.pswen.cn/p/4166/</id>
    <published>2018-06-23T05:32:35.000Z</published>
    <updated>2023-02-23T15:19:10.383Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/p/4166/IMG_3952.JPG" alt="学位授予"></p><p>梦想的起点</p>]]></content>
    
    
    <summary type="html">大学毕业照</summary>
    
    
    
    
    <category term="往昔时光" scheme="https://www.pswen.cn/tags/%E5%BE%80%E6%98%94%E6%97%B6%E5%85%89/"/>
    
    <category term="大学" scheme="https://www.pswen.cn/tags/%E5%A4%A7%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>往昔时光-可爱的他们</title>
    <link href="https://www.pswen.cn/p/43666/"/>
    <id>https://www.pswen.cn/p/43666/</id>
    <published>2018-02-13T04:36:02.000Z</published>
    <updated>2023-02-23T15:19:10.383Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/p/43666/IMG_3586.JPG" alt="可爱的他们"></p><p>可爱的他们</p>]]></content>
    
    
    <summary type="html">高中在即将奔赴社会或进入研究生阶段的聚餐</summary>
    
    
    
    
    <category term="往昔时光" scheme="https://www.pswen.cn/tags/%E5%BE%80%E6%98%94%E6%97%B6%E5%85%89/"/>
    
    <category term="高中" scheme="https://www.pswen.cn/tags/%E9%AB%98%E4%B8%AD/"/>
    
  </entry>
  
  <entry>
    <title>往昔时光-大学实习</title>
    <link href="https://www.pswen.cn/p/48940/"/>
    <id>https://www.pswen.cn/p/48940/</id>
    <published>2017-06-17T02:39:52.000Z</published>
    <updated>2023-02-23T15:19:10.383Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/p/48940/IMG_2498.JPG" alt="实习"></p><p>参观实习</p><p><img src="/p/48940/IMG_2473.JPG" alt="流体机械"></p>]]></content>
    
    
    <summary type="html">在校期间的专业参观实习</summary>
    
    
    
    
    <category term="大学" scheme="https://www.pswen.cn/tags/%E5%A4%A7%E5%AD%A6/"/>
    
    <category term="往昔" scheme="https://www.pswen.cn/tags/%E5%BE%80%E6%98%94/"/>
    
    <category term="实习" scheme="https://www.pswen.cn/tags/%E5%AE%9E%E4%B9%A0/"/>
    
  </entry>
  
</feed>
