{"title":"环形链表——LeetCode141","slug":"linked-list-cycle","date":"2021-11-12T13:17:10.000Z","updated":"2023-04-30T03:57:46.427Z","comments":true,"path":"api/articles/linked-list-cycle.json","realpath":"/p/1426/","excerpt":"给定一个链表，判断链表中是否有环。如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。<br>如果链表中存在环，则返回 true 。 否则，返回 false 。<br>LeetCode-141 链接：https://leetcode-cn.com/problems/linked-list-cycle","cover":"/p/1426/index.htmlcircularlinkedlist.png","content":"<html><head></head><body><p>给定一个链表，判断链表中是否有环。</p>\n<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。<br>\n如果链表中存在环，则返回 true 。 否则，返回 false 。<br>\nLeetCode-141 链接：<a href=\"https://leetcode-cn.com/problems/linked-list-cycle\">https://leetcode-cn.com/problems/linked-list-cycle</a></p>\n<span id=\"more\"></span> \n<p>示例 1：</p>\n<p><img src=\"/p/1426/index.htmlcircularlinkedlist.png\" alt=\"环形链表-示例1\"></p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"BASH\"><figure class=\"iseeu highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：<span class=\"built_in\">head</span> = [3,2,0,-4], pos = 1</span><br><span class=\"line\">输出：<span class=\"literal\">true</span></span><br><span class=\"line\">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></tbody></table></figure></div>\n<p>示例 2：</p>\n<p><img src=\"/p/1426/index.htmlcircularlinkedlist_test2.png\" alt=\"环形链表-示例2\"></p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"BASH\"><figure class=\"iseeu highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：<span class=\"built_in\">head</span> = [1,2], pos = 0</span><br><span class=\"line\">输出：<span class=\"literal\">true</span></span><br><span class=\"line\">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></tbody></table></figure></div>\n<p>示例 3：</p>\n<p><img src=\"/p/1426/index.htmlcircularlinkedlist_test3.png\" alt=\"环形链表-示例3\"></p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"BASH\"><figure class=\"iseeu highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：<span class=\"built_in\">head</span> = [1], pos = -1</span><br><span class=\"line\">输出：<span class=\"literal\">false</span></span><br><span class=\"line\">解释：链表中没有环。</span><br></pre></td></tr></tbody></table></figure></div>\n<p>提示：</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"REASONML\"><figure class=\"iseeu highlight reasonml\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">链表中节点的数目范围是 <span class=\"literal\">[<span class=\"number\">0</span>, <span class=\"number\">104</span>]</span></span><br><span class=\"line\">-<span class=\"number\">105</span> &lt;= <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Node</span>.</span></span><span class=\"keyword\">val</span> &lt;= <span class=\"number\">105</span></span><br><span class=\"line\">pos 为 -<span class=\"number\">1</span> 或者链表中的一个 有效索引 。</span><br></pre></td></tr></tbody></table></figure></div>\n<h3 id=\"解题\"><a class=\"markdownIt-Anchor\" href=\"#解题\">#</a> 解题</h3>\n<ol>\n<li>Hash 表</li>\n</ol>\n<p>最容易想到的方法是遍历所有节点，每次遍历到一个节点时，判断该节点此前是否被访问过。</p>\n<p>具体地，我们可以使用哈希表来存储所有已经访问过的节点。每次我们到达一个节点，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。重复这一过程，直到我们遍历完整个链表即可。</p>\n<p>代码实现：</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"JAVA\"><figure class=\"iseeu highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> {</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">hasCycle</span><span class=\"params\">(ListNode head)</span> {</span><br><span class=\"line\">        Set&lt;ListNode&gt; seen = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;ListNode&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (head != <span class=\"literal\">null</span>) {</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!seen.add(head)) {</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            }</span><br><span class=\"line\">            head = head.next;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure></div>\n<p>复杂度分析</p>\n<p>时间复杂度： <code>O(N)</code> ，其中  <code>N </code> 是链表中的节点数。最坏情况下我们需要遍历每个节点一次。<br>\n空间复杂度： <code>O(N)</code> ，其中 <code>N </code> 是链表中的节点数。主要为哈希表的开销，最坏情况下我们需要将每个节点插入到哈希表中一次。</p>\n<ol start=\"2\">\n<li>快慢指针</li>\n</ol>\n<p>方法需要读者对「Floyd 判圈算法」（又称龟兔赛跑算法）有所了解。</p>\n<p>假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。</p>\n<p>我们可以根据上述思路来解决本题。具体地，我们定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。</p>\n<p><img src=\"/p/1426/index.html2.png\" alt=\"龟兔赛跑\"></p>\n<blockquote>\n<p>为什么我们要规定初始时慢指针在位置 head，快指针在位置 head.next，而不是两个指针都在位置 head（即与「乌龟」和「兔子」中的叙述相同）？</p>\n</blockquote>\n<ul>\n<li>观察下面的代码，我们使用的是 while 循环，循环条件先于循环体。由于循环条件一定是判断快慢指针是否重合，如果我们将两个指针初始都置于 head，那么 while 循环就不会执行。因此，我们可以假想一个在 head 之前的虚拟节点，慢指针从虚拟节点移动一步到达 head，快指针从虚拟节点移动两步到达 head.next，这样我们就可以使用 while 循环了。</li>\n<li>当然，我们也可以使用 do-while 循环。此时，我们就可以把快慢指针的初始值都置为 head。</li>\n</ul>\n<p>代码实现：</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"JAVA\"><figure class=\"iseeu highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> {</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">hasCycle</span><span class=\"params\">(ListNode head)</span> {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head == <span class=\"literal\">null</span> || head.next == <span class=\"literal\">null</span>) {</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">slow</span> <span class=\"operator\">=</span> head;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">fast</span> <span class=\"operator\">=</span> head.next;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (slow != fast) {</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (fast == <span class=\"literal\">null</span> || fast.next == <span class=\"literal\">null</span>) {</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            }</span><br><span class=\"line\">            slow = slow.next;</span><br><span class=\"line\">            fast = fast.next.next;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure></div>\n<p>复杂度分析</p>\n<p>时间复杂度： <code>O(N)</code> ，其中  <code>N</code>  是链表中的节点数。<br>\n当链表中不存在环时，快指针将先于慢指针到达链表尾部，链表中每个节点至多被访问两次。<br>\n当链表中存在环时，每一轮移动后，快慢指针的距离将减小一。而初始距离为环的长度，因此至多移动<br>\n <code>N</code>  轮。<br>\n空间复杂度： <code>O(1)</code> 。我们只使用了两个指针的额外空间。</p>\n</body></html>","raw":"给定一个链表，判断链表中是否有环。\n\n如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。\n如果链表中存在环，则返回 true 。 否则，返回 false 。\nLeetCode-141 链接：https://leetcode-cn.com/problems/linked-list-cycle\n\n<!-- more --> \n\n示例 1：\n\n![环形链表-示例1](/p/1426/circularlinkedlist.png)\n\n```\n输入：head = [3,2,0,-4], pos = 1\n输出：true\n解释：链表中有一个环，其尾部连接到第二个节点。\n```\n\n示例 2：\n\n![环形链表-示例2](/p/1426/circularlinkedlist_test2.png)\n\n```\n输入：head = [1,2], pos = 0\n输出：true\n解释：链表中有一个环，其尾部连接到第一个节点。\n```\n\n示例 3：\n\n![环形链表-示例3](/p/1426/circularlinkedlist_test3.png)\n\n```\n输入：head = [1], pos = -1\n输出：false\n解释：链表中没有环。\n```\n\n提示：\n\n```\n链表中节点的数目范围是 [0, 104]\n-105 <= Node.val <= 105\npos 为 -1 或者链表中的一个 有效索引 。\n```\n\n### 解题\n\n1. Hash表\n\n最容易想到的方法是遍历所有节点，每次遍历到一个节点时，判断该节点此前是否被访问过。\n\n具体地，我们可以使用哈希表来存储所有已经访问过的节点。每次我们到达一个节点，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。重复这一过程，直到我们遍历完整个链表即可。\n\n代码实现：\n\n```java\npublic class Solution {\n    public boolean hasCycle(ListNode head) {\n        Set<ListNode> seen = new HashSet<ListNode>();\n        while (head != null) {\n            if (!seen.add(head)) {\n                return true;\n            }\n            head = head.next;\n        }\n        return false;\n    }\n}\n```\n\n复杂度分析\n\n时间复杂度：`O(N)`，其中 `N `是链表中的节点数。最坏情况下我们需要遍历每个节点一次。\n空间复杂度：`O(N)`，其中`N `是链表中的节点数。主要为哈希表的开销，最坏情况下我们需要将每个节点插入到哈希表中一次。\n\n2. 快慢指针\n\n方法需要读者对「Floyd 判圈算法」（又称龟兔赛跑算法）有所了解。\n\n假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。\n\n我们可以根据上述思路来解决本题。具体地，我们定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。\n\n![龟兔赛跑](/p/1426/2.png)\n\n> 为什么我们要规定初始时慢指针在位置 head，快指针在位置 head.next，而不是两个指针都在位置 head（即与「乌龟」和「兔子」中的叙述相同）？\n\n- 观察下面的代码，我们使用的是 while 循环，循环条件先于循环体。由于循环条件一定是判断快慢指针是否重合，如果我们将两个指针初始都置于 head，那么 while 循环就不会执行。因此，我们可以假想一个在 head 之前的虚拟节点，慢指针从虚拟节点移动一步到达 head，快指针从虚拟节点移动两步到达 head.next，这样我们就可以使用 while 循环了。\n- 当然，我们也可以使用 do-while 循环。此时，我们就可以把快慢指针的初始值都置为 head。\n\n代码实现：\n\n```java\npublic class Solution {\n    public boolean hasCycle(ListNode head) {\n        if (head == null || head.next == null) {\n            return false;\n        }\n        ListNode slow = head;\n        ListNode fast = head.next;\n        while (slow != fast) {\n            if (fast == null || fast.next == null) {\n                return false;\n            }\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return true;\n    }\n}\n```\n\n复杂度分析\n\n时间复杂度：`O(N)`，其中 `N` 是链表中的节点数。\n当链表中不存在环时，快指针将先于慢指针到达链表尾部，链表中每个节点至多被访问两次。\n当链表中存在环时，每一轮移动后，快慢指针的距离将减小一。而初始距离为环的长度，因此至多移动 \n`N`轮。\n空间复杂度：`O(1)`。我们只使用了两个指针的额外空间。\n","more":"<html><head></head><body><p>示例 1：</p>\n<p><img src=\"/p/1426/index.htmlcircularlinkedlist.png\" alt=\"环形链表-示例1\"></p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：<span class=\"built_in\">head</span> = [3,2,0,-4], pos = 1</span><br><span class=\"line\">输出：<span class=\"literal\">true</span></span><br><span class=\"line\">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></tbody></table></figure>\n<p>示例 2：</p>\n<p><img src=\"/p/1426/index.htmlcircularlinkedlist_test2.png\" alt=\"环形链表-示例2\"></p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：<span class=\"built_in\">head</span> = [1,2], pos = 0</span><br><span class=\"line\">输出：<span class=\"literal\">true</span></span><br><span class=\"line\">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></tbody></table></figure>\n<p>示例 3：</p>\n<p><img src=\"/p/1426/index.htmlcircularlinkedlist_test3.png\" alt=\"环形链表-示例3\"></p>\n<figure class=\"highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：<span class=\"built_in\">head</span> = [1], pos = -1</span><br><span class=\"line\">输出：<span class=\"literal\">false</span></span><br><span class=\"line\">解释：链表中没有环。</span><br></pre></td></tr></tbody></table></figure>\n<p>提示：</p>\n<figure class=\"highlight reasonml\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">链表中节点的数目范围是 <span class=\"literal\">[<span class=\"number\">0</span>, <span class=\"number\">104</span>]</span></span><br><span class=\"line\">-<span class=\"number\">105</span> &lt;= <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Node</span>.</span></span><span class=\"keyword\">val</span> &lt;= <span class=\"number\">105</span></span><br><span class=\"line\">pos 为 -<span class=\"number\">1</span> 或者链表中的一个 有效索引 。</span><br></pre></td></tr></tbody></table></figure>\n<h3 id=\"解题\"><a class=\"markdownIt-Anchor\" href=\"#解题\">#</a> 解题</h3>\n<ol>\n<li>Hash 表</li>\n</ol>\n<p>最容易想到的方法是遍历所有节点，每次遍历到一个节点时，判断该节点此前是否被访问过。</p>\n<p>具体地，我们可以使用哈希表来存储所有已经访问过的节点。每次我们到达一个节点，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。重复这一过程，直到我们遍历完整个链表即可。</p>\n<p>代码实现：</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> {</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">hasCycle</span><span class=\"params\">(ListNode head)</span> {</span><br><span class=\"line\">        Set&lt;ListNode&gt; seen = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;ListNode&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (head != <span class=\"literal\">null</span>) {</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!seen.add(head)) {</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            }</span><br><span class=\"line\">            head = head.next;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>复杂度分析</p>\n<p>时间复杂度： <code>O(N)</code> ，其中  <code>N </code> 是链表中的节点数。最坏情况下我们需要遍历每个节点一次。<br>\n空间复杂度： <code>O(N)</code> ，其中 <code>N </code> 是链表中的节点数。主要为哈希表的开销，最坏情况下我们需要将每个节点插入到哈希表中一次。</p>\n<ol start=\"2\">\n<li>快慢指针</li>\n</ol>\n<p>方法需要读者对「Floyd 判圈算法」（又称龟兔赛跑算法）有所了解。</p>\n<p>假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。</p>\n<p>我们可以根据上述思路来解决本题。具体地，我们定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。</p>\n<p><img src=\"/p/1426/index.html2.png\" alt=\"龟兔赛跑\"></p>\n<blockquote>\n<p>为什么我们要规定初始时慢指针在位置 head，快指针在位置 head.next，而不是两个指针都在位置 head（即与「乌龟」和「兔子」中的叙述相同）？</p>\n</blockquote>\n<ul>\n<li>观察下面的代码，我们使用的是 while 循环，循环条件先于循环体。由于循环条件一定是判断快慢指针是否重合，如果我们将两个指针初始都置于 head，那么 while 循环就不会执行。因此，我们可以假想一个在 head 之前的虚拟节点，慢指针从虚拟节点移动一步到达 head，快指针从虚拟节点移动两步到达 head.next，这样我们就可以使用 while 循环了。</li>\n<li>当然，我们也可以使用 do-while 循环。此时，我们就可以把快慢指针的初始值都置为 head。</li>\n</ul>\n<p>代码实现：</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> {</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">hasCycle</span><span class=\"params\">(ListNode head)</span> {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head == <span class=\"literal\">null</span> || head.next == <span class=\"literal\">null</span>) {</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">slow</span> <span class=\"operator\">=</span> head;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">fast</span> <span class=\"operator\">=</span> head.next;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (slow != fast) {</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (fast == <span class=\"literal\">null</span> || fast.next == <span class=\"literal\">null</span>) {</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            }</span><br><span class=\"line\">            slow = slow.next;</span><br><span class=\"line\">            fast = fast.next.next;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>复杂度分析</p>\n<p>时间复杂度： <code>O(N)</code> ，其中  <code>N</code>  是链表中的节点数。<br>\n当链表中不存在环时，快指针将先于慢指针到达链表尾部，链表中每个节点至多被访问两次。<br>\n当链表中存在环时，每一轮移动后，快慢指针的距离将减小一。而初始距离为环的长度，因此至多移动<br>\n <code>N</code>  轮。<br>\n空间复杂度： <code>O(1)</code> 。我们只使用了两个指针的额外空间。</p></body></html>","categories":[],"tags":[{"name":"算法","path":"api/tags/算法.json"},{"name":"快慢指针","path":"api/tags/快慢指针.json"},{"name":"环形链表","path":"api/tags/环形链表.json"}]}