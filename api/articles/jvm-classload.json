{"title":"虚拟机类加载机制-类加载时机","slug":"jvm-classload","date":"2021-11-12T14:55:27.000Z","updated":"2023-02-04T06:19:42.852Z","comments":true,"path":"api/articles/jvm-classload.json","realpath":"/p/8239/","excerpt":"在 Java 语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略虽然会令类加载时稍微增加一些性能开销，但是会为 Java 应用程序提供高度的灵活性，Java 里天生可以动态扩展的语言特性就是依赖于运行期动态加载和动态连接这个特点实现的。","cover":"/p/8239/20160719124551909.jpeg","content":"<p>在 Java 语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略虽然会令类加载时稍微增加一些性能开销，但是会为 Java 应用程序提供高度的灵活性，Java 里天生可以动态扩展的语言特性就是依赖于运行期动态加载和动态连接这个特点实现的。</p>\n<span id=\"more\"></span>\n<p>例如，如果编写一个面向接口的应用程序，可以等到运行时再指定其实际的实现类；用户可以通过 Java 预定义的和自定义类加载器，让一个本地的应用程序可以在运行时从网络或其他地方加载一个二进制流作为程序代码的一部分，这种组装应用程序的方式目前已广泛应用于 Java 程序之中。从最基础的 Applet、JSP 到相对复杂的 OSGI 技术，都使用了 Java 语言运行期类加载的特性。</p>\n<h2 id=\"类加载机制\"><a class=\"markdownIt-Anchor\" href=\"#类加载机制\">#</a> 类加载机制</h2>\n<p>生命周期：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialzation）、使用（Using）和卸载（Unloading）7 个阶段。</p>\n<p><img src=\"/p/8239/20160719124551909.jpeg\" alt=\"生命周期\"></p>\n<p>什么情况下需要开始进行类加载过程的第一阶段呢？没有明确约束，虚拟机自由把握；</p>\n<p>而初始化阶段有严格规范，以下五种情况必须理解对类进行初始化。</p>\n<ol>\n<li>遇到 new（new 关键词实例化），getstatic（读取类的 static 字段），putstatic（设置类的 static 字段，被 final 修饰、已在编译期就把结果放入了常量池的字段除外），invokestatic（调用一个类的静态方法）</li>\n<li>使用 <code>java.lang.reflect</code>  包的方法对类进行反射调用</li>\n<li>初始化一个类，会先初始化它的父类</li>\n<li>虚拟机启动时，会先初始化执行的主类（main 方法）</li>\n<li>JDK1.7 的 <code>java.lang.invoke.MethodHandle</code>  的方法去获取句柄</li>\n</ol>\n<p><em><strong>有且仅有</strong></em>这五种情况，除此之外都是被动引用，不会触发初始化，举 3 个例子</p>\n<ul>\n<li>对于静态字段，只有定义这个字段的类才会被初始化，例如父类定义的静态字段，通过子类去使用父类的静态字段，那么只有父类会初始化，子类不会</li>\n<li>数组类型定义使用时，类似 <code>SubClass[]</code>  不会进行初始化</li>\n<li>被 finla 修饰的静态字段，会进行常量传播优化，实际上这个字段已经和这个类没啥关系了</li>\n</ul>\n<p>初始化第三种情况下，对于接口有个特例情况：一个类初始化时要求父类全部初始化，而接口，不要求其父接口全部都完成初始化，只有在使用到才会初始化。</p>\n","raw":"在 Java 语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略虽然会令类加载时稍微增加一些性能开销，但是会为 Java 应用程序提供高度的灵活性，Java 里天生可以动态扩展的语言特性就是依赖于运行期动态加载和动态连接这个特点实现的。\n\n<!-- more -->\n\n例如，如果编写一个面向接口的应用程序，可以等到运行时再指定其实际的实现类；用户可以通过 Java 预定义的和自定义类加载器，让一个本地的应用程序可以在运行时从网络或其他地方加载一个二进制流作为程序代码的一部分，这种组装应用程序的方式目前已广泛应用于 Java 程序之中。从最基础的 Applet、JSP 到相对复杂的 OSGI 技术，都使用了 Java 语言运行期类加载的特性。\n\n## 类加载机制\n\n生命周期：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialzation）、使用（Using）和卸载（Unloading）7 个阶段。\n\n![生命周期](/p/8239/20160719124551909.jpeg)\n\n什么情况下需要开始进行类加载过程的第一阶段呢？没有明确约束，虚拟机自由把握；\n\n而初始化阶段有严格规范，以下五种情况必须理解对类进行初始化。\n\n1. 遇到new（new关键词实例化），getstatic（读取类的static字段），putstatic（设置类的static字段，被final修饰、已在编译期就把结果放入了常量池的字段除外），invokestatic（调用一个类的静态方法）\n2. 使用`java.lang.reflect`包的方法对类进行反射调用\n3. 初始化一个类，会先初始化它的父类\n4. 虚拟机启动时，会先初始化执行的主类（main方法）\n5. JDK1.7的`java.lang.invoke.MethodHandle`的方法去获取句柄\n\n***有且仅有***这五种情况，除此之外都是被动引用，不会触发初始化，举3个例子\n\n- 对于静态字段，只有定义这个字段的类才会被初始化，例如父类定义的静态字段，通过子类去使用父类的静态字段，那么只有父类会初始化，子类不会\n- 数组类型定义使用时，类似`SubClass[]`不会进行初始化\n- 被finla修饰的静态字段，会进行常量传播优化，实际上这个字段已经和这个类没啥关系了\n\n初始化第三种情况下，对于接口有个特例情况：一个类初始化时要求父类全部初始化，而接口，不要求其父接口全部都完成初始化，只有在使用到才会初始化。\n\n","more":"<p>例如，如果编写一个面向接口的应用程序，可以等到运行时再指定其实际的实现类；用户可以通过 Java 预定义的和自定义类加载器，让一个本地的应用程序可以在运行时从网络或其他地方加载一个二进制流作为程序代码的一部分，这种组装应用程序的方式目前已广泛应用于 Java 程序之中。从最基础的 Applet、JSP 到相对复杂的 OSGI 技术，都使用了 Java 语言运行期类加载的特性。</p>\n<h2 id=\"类加载机制\"><a class=\"markdownIt-Anchor\" href=\"#类加载机制\">#</a> 类加载机制</h2>\n<p>生命周期：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialzation）、使用（Using）和卸载（Unloading）7 个阶段。</p>\n<p><img src=\"/p/8239/20160719124551909.jpeg\" alt=\"生命周期\"></p>\n<p>什么情况下需要开始进行类加载过程的第一阶段呢？没有明确约束，虚拟机自由把握；</p>\n<p>而初始化阶段有严格规范，以下五种情况必须理解对类进行初始化。</p>\n<ol>\n<li>遇到 new（new 关键词实例化），getstatic（读取类的 static 字段），putstatic（设置类的 static 字段，被 final 修饰、已在编译期就把结果放入了常量池的字段除外），invokestatic（调用一个类的静态方法）</li>\n<li>使用 <code>java.lang.reflect</code>  包的方法对类进行反射调用</li>\n<li>初始化一个类，会先初始化它的父类</li>\n<li>虚拟机启动时，会先初始化执行的主类（main 方法）</li>\n<li>JDK1.7 的 <code>java.lang.invoke.MethodHandle</code>  的方法去获取句柄</li>\n</ol>\n<p><em><strong>有且仅有</strong></em>这五种情况，除此之外都是被动引用，不会触发初始化，举 3 个例子</p>\n<ul>\n<li>对于静态字段，只有定义这个字段的类才会被初始化，例如父类定义的静态字段，通过子类去使用父类的静态字段，那么只有父类会初始化，子类不会</li>\n<li>数组类型定义使用时，类似 <code>SubClass[]</code>  不会进行初始化</li>\n<li>被 finla 修饰的静态字段，会进行常量传播优化，实际上这个字段已经和这个类没啥关系了</li>\n</ul>\n<p>初始化第三种情况下，对于接口有个特例情况：一个类初始化时要求父类全部初始化，而接口，不要求其父接口全部都完成初始化，只有在使用到才会初始化。</p>","categories":[],"tags":[{"name":"jvm","path":"api/tags/jvm.json"},{"name":"类加载","path":"api/tags/类加载.json"}]}