{"title":"从Apollo动态配置原理学Spring(二)","slug":"20230226","date":"2023-02-26T12:39:24.000Z","updated":"2023-04-30T03:57:46.039Z","comments":true,"path":"api/articles/20230226.json","realpath":"/p/4c633c0c/","excerpt":"Apollo 动态配置其实本质就是利用 Spring Bean 的生命周期的扩展点，这个扩展点超级多，不可能全部列出来，只说核心的扩展点。这也就是为什么 Spring 的扩展性很好的原因，开了很多的口子，尽可能让某个功能高内聚松耦合，用户需要哪个功能就用哪个，而不是直接来一个大而全的东西。我们先通过学习核心的，然后后续对照 Apollo 用到了哪些再对照，就会发现很多地方就能理解的很好了","cover":"/p/4c633c0c/index.html20210707002134280.png","content":"<html><head></head><body><blockquote>\n<p>Apollo 动态配置其实本质就是利用 Spring Bean 的生命周期的扩展点，这个扩展点超级多，不可能全部列出来，只说核心的扩展点。这也就是为什么 Spring 的扩展性很好的原因，开了很多的口子，尽可能让某个功能高内聚松耦合，用户需要哪个功能就用哪个，而不是直接来一个大而全的东西。</p>\n</blockquote>\n<p>我们先通过学习核心的，然后后续对照 Apollo 用到了哪些再对照，就会发现很多地方就能理解的很好了</p>\n<span id=\"more\"></span>\n<p><strong>什么是 Spring Bean 的生命周期</strong></p>\n<p>对于普通的 Java 对象，当 new 的时候创建对象，然后该对象就能够使用了。一旦该对象不再被使用，则由 Java 自动进行垃圾回收。</p>\n<p>而 Spring 中的对象是 bean，bean 和普通的 Java 对象没啥大的区别，只不过 Spring 不再自己去 new 对象了，而是由 IoC 容器去帮助我们实例化对象并且管理它，我们需要哪个对象，去问 IoC 容器要即可。IoC 其实就是解决对象之间的耦合问题，Spring Bean 的生命周期完全由容器控制。</p>\n<h2 id=\"spring-bean-的生命周期\"><a class=\"markdownIt-Anchor\" href=\"#spring-bean-的生命周期\">#</a> Spring Bean 的生命周期</h2>\n<p>这里要提一下，这里我们说的 Spring Bean 的生命周期主要指的是 singleton bean，对于 prototype 的 bean ，Spring 在创建好交给使用者之后则不会再管理后续的生命周期。</p>\n<p>我们也来复习下 Spring 中的 bean 的作用域有哪些？</p>\n<ul>\n<li><code>singleton</code>  : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。</li>\n<li><code>prototype</code>  : 每次请求都会创建一个新的 bean 实例。</li>\n<li><code>request</code>  : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。</li>\n<li><code>session</code>  : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。</li>\n<li><code>global-session</code> ： 全局 session 作用域，仅仅在基于 Portlet 的 web 应用中才有意义，Spring5 已经没有了。Portlet 是能够生成语义代码（例如：HTML）片段的小型 Java Web 插件。它们基于 portlet 容器，可以像 servlet 一样处理 HTTP 请求。但是，与 servlet 不同，每个 portlet 都有不同的会话。</li>\n</ul>\n<p>我们知道对于普通的 Java 对象来说，它们的生命周期就是：</p>\n<ul>\n<li>实例化</li>\n<li>该对象不再被使用时通过垃圾回收机制进行回收</li>\n</ul>\n<p>而对于 Spring Bean 的生命周期来说：</p>\n<ul>\n<li>实例化 Instantiation</li>\n<li>属性赋值 Populate</li>\n<li>初始化 Initialization</li>\n<li>销毁 Destruction</li>\n</ul>\n<p>实例化 -&gt; 属性赋值 -&gt; 初始化 -&gt; 销毁</p>\n<p>只有四个步骤，这样拆解的话是不是感觉也不难？不像其他人写的那样直接一上来就各种 BeanPostProcessor、BeanFactoryPostProcessor 全部怼进流程里去，别说读者看着头大，自己写的可能短时间内还记得流程，隔个一段时间，你可能都不知道自己写了个啥。</p>\n<p>通过 Bean 创建流程入口 <code>AbstractApplicationContext#refresh()</code>  方法的  <code>finishBeanFactoryInitialization(beanFactory)</code>  处带大家跟一下源码，想了想还是不带入过多的代码进来，直接给到最终的主要逻辑。</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"JAVA\"><figure class=\"iseeu highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> Object <span class=\"title function_\">doCreateBean</span><span class=\"params\">(String beanName, RootBeanDefinition mbd, <span class=\"meta\">@Nullable</span> Object[] args)</span> <span class=\"keyword\">throws</span> BeanCreationException {</span><br><span class=\"line\">    <span class=\"type\">BeanWrapper</span> <span class=\"variable\">instanceWrapper</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mbd.isSingleton()) {</span><br><span class=\"line\">        instanceWrapper = (BeanWrapper)<span class=\"built_in\">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instanceWrapper == <span class=\"literal\">null</span>) {</span><br><span class=\"line\">    \t<span class=\"comment\">// 实例化阶段</span></span><br><span class=\"line\">        instanceWrapper = <span class=\"built_in\">this</span>.createBeanInstance(beanName, mbd, args);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"type\">Object</span> <span class=\"variable\">exposedObject</span> <span class=\"operator\">=</span> bean;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> {</span><br><span class=\"line\">    \t<span class=\"comment\">// 属性赋值阶段</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.populateBean(beanName, mbd, instanceWrapper);</span><br><span class=\"line\">        <span class=\"comment\">// 初始化阶段</span></span><br><span class=\"line\">        exposedObject = <span class=\"built_in\">this</span>.initializeBean(beanName, exposedObject, mbd);</span><br><span class=\"line\">    } <span class=\"keyword\">catch</span> (Throwable var18) {</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    }</span><br><span class=\"line\">    ...</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure></div>\n<p>至于销毁，是在容器关闭时调用的，详见  <code>ConfigurableApplicationContext#close()</code></p>\n<p>是不是很清爽了？至于 BeanPostProcessor、BeanFactoryPostProcessor 以及其他的类，只不过是对主流程四个步骤的一系列扩展点而已。</p>\n<h2 id=\"spring-bean-的生命周期的扩展点\"><a class=\"markdownIt-Anchor\" href=\"#spring-bean-的生命周期的扩展点\">#</a> Spring Bean 的生命周期的扩展点</h2>\n<p>Spring Bean 的生命周期的扩展点超级多，老周这里不可能全部列出来，只说核心的扩展点。这也就是为什么 Spring 的扩展性很好的原因，开了很多的口子，尽可能让某个功能高内聚松耦合，用户需要哪个功能就用哪个，而不是直接来一个大而全的东西。</p>\n<p><strong>Bean 自身的方法</strong></p>\n<p>比如构造函数、getter/setter 以及 init-method 和 destory-method 所指定的方法等，也就对应着上文说的实例化 -&gt; 属性赋值 -&gt; 初始化 -&gt; 销毁四个阶段。</p>\n<p><img src=\"/p/4c633c0c/index.html20210707002134280.png\" alt=\"阶段示意图\"></p>\n<p><strong>容器级的方法（BeanPostProcessor 一系列接口）</strong></p>\n<p>主要是后处理器方法，比如下图的  <code>InstantiationAwareBeanPostProcessor</code> 、 <code>BeanPostProcessor</code>  接口方法。这些接口的实现类是独立于 Bean 的，并且会注册到 Spring 容器中。在 Spring 容器创建任何 Bean 的时候，这些后处理器都会发生作用。</p>\n<p><img src=\"/p/4c633c0c/index.html20210707225212729.png\" alt=\"扩展点\"></p>\n<p><strong>InstantiationAwareBeanPostProcessor 源码分析</strong></p>\n<p>我们翻一下源码发现 InstantiationAwareBeanPostProcessor 是继承了 BeanPostProcessor</p>\n<p><img src=\"/p/4c633c0c/index.html20210707230505579.png\" alt=\"InstantiationAwareBeanPostProcessor \"></p>\n<p><img src=\"/p/4c633c0c/index.html20210707230919307.png\" alt=\"BeanPostProcessor\"></p>\n<ul>\n<li><code>InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation</code>  调用点</li>\n</ul>\n<blockquote>\n<p>Object postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName)<br>\n 返回值：如果返回的不为 null，那么后续的 Bean 的创建流程【实例化、初始化 afterProperties】都不会执行，而是直接使用返回的快捷 Bean，此时的正常执行顺序如下：<br>\nInstantiationAwareBeanPostProcessor 接口中的 postProcessBeforeInstantiation，在实例化之前调用。<br>\nBeanPostProcessor 接口中的 postProcessAfterInitialization，在实例化之后调用。</p>\n</blockquote>\n<p><img src=\"https://img-blog.csdnimg.cn/20210707233026943.png\" alt=\"createbean\"></p>\n<p><img src=\"/p/4c633c0c/index.html20210707235533784.png\" alt=\"resolveBeforeInstantiation\"></p>\n<p><img src=\"/p/4c633c0c/index.html20210708000228655.png\" alt=\"applyBean\"></p>\n<p>总之，postProcessBeforeInstantiation 在 doCreateBean 之前调用，也就是在 bean 实例化之前调用的，英文源码注释解释道该方法的返回值会替换原本的 Bean 作为代理，这也是 <a href=\"https://so.csdn.net/so/search?q=AOP&amp;spm=1001.2101.3001.7020\">AOP</a> 等功能实现的关键点。</p>\n<ul>\n<li><code>InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation</code>  调用点</li>\n</ul>\n<blockquote>\n<p>boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException<br>\n 正常情况下在实例化之后在执行 populateBean 之前调用<br>\n返回值：如果有指定的 bean 的时候返回 false，那么后续的属性填充和属性依赖注入【populateBean】将不会执行，同时后续的 postProcessPropertyValues 将不会执行，但是初始化和 BeanPostProcessor 的仍然会执行。</p>\n</blockquote>\n<p><img src=\"/p/4c633c0c/index.html20210708005050274.png\" alt=\"populateBean\"></p>\n<p>public PropertyValues postProcessPropertyValues(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)<br>\n 实例化之后调用，在方法 applyPropertyValues【属性填充】之前<br>\n返回值：如果返回 null，那么将不会进行后续的属性填充，比如依赖注入等，如果返回的 pvs 额外的添加了属性，那么后续会填充到该类对应的属性中。<br>\npvs：PropertyValues 对象，用于封装指定类的对象，简单来说就是 PropertyValue 的集合，里面相当于以 key-value 形式存放类的属性和值。<br>\npds：PropertyDescriptor 对象数组，PropertyDescriptor 相当于存储类的属性，不过可以调用 set，get 方法设置和获取对应属性的值。</p>\n<p><img src=\"/p/4c633c0c/index.html20210708010057366.png\" alt=\"postProcessPropertyValues\"></p>\n<p><strong>BeanPostProcessor 源码分析</strong></p>\n<blockquote>\n<p>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#doCreateBean</p>\n</blockquote>\n<p><img src=\"/p/4c633c0c/index.html20210708232740951.png\" alt=\"在这里插入图片描述\"><br>\n进入初始化接口：</p>\n<p><img src=\"/p/4c633c0c/index.html20210708233139731.png\" alt=\"在这里插入图片描述\"><br>\n我们先来看</p>\n<blockquote>\n<p>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#applyBeanPostProcessorsBeforeInitialization</p>\n</blockquote>\n<p><img src=\"/p/4c633c0c/index.html20210708233742525.png\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li>首先获取到所有的后置处理器 getBeanPostProcessors ()</li>\n<li>在 for 循环中依次调用后置处理器的方法  <code>processor.postProcessBeforeInitialization(result, beanName);</code></li>\n<li>进入 postProcessBeforeInitialization 方法</li>\n</ul>\n<blockquote>\n<p>org.springframework.context.support.ApplicationContextAwareProcessor#postProcessBeforeInitialization</p>\n</blockquote>\n<p><img src=\"/p/4c633c0c/index.html20210708234443215.png\" alt=\"在这里插入图片描述\"></p>\n<p>进入  <code>invokeAwareInterfaces(bean);</code>  方法，当前 bean 实现了 ApplicationContextAware 接口。</p>\n<p><img src=\"/p/4c633c0c/index.html20210708234639952.png\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li><code>ApplicationContextAwareProcessor#postProcessBeforeInitialization</code>  首先判断此 bean 是不是各种的 Aware，如果是它列举的那几个 Aware 就获取 Bean 工厂的权限，可以向容器中导入相关的上下文环境，目的是为了 Bean 实例能够获取到相关的上下文，如果不是它列举的几个 Aware，那就调用  <code>invokeAwareInterfaces(bean)</code> ，向容器中添加相关接口的上下文环境。</li>\n</ul>\n<p><strong>3.3 工厂后处理器方法（BeanFactoryProcessor 一系列接口）</strong></p>\n<p>包括  <code>AspectJWeavingEnabler</code> 、 <code>CustomAutowireConfigurer</code> 、 <code>ConfigurationClassPostProcessor</code>  等。这些都是 Spring 框架中已经实现好的 BeanFactoryPostProcessor，用来实现某些特定的功能。</p>\n<p>我们知道 Spring IoC 容器初始化的关键环节就在  <code>org.springframework.context.support.AbstractApplicationContext#refresh</code>  方法中 ，容器创建的主体流程都在这个方法里面，这个方法是真的重要！！！</p>\n<p>对于工厂后处理器方法老周这里直接带你看  <code>invokeBeanFactoryPostProcessors(beanFactory);</code>  方法，这个方法处理的是  <code>BeanFactoryPostProcessor</code>  接口的 Bean。调用方法如下：</p>\n<p><img src=\"/p/4c633c0c/index.html20210709231013239.png\" alt=\"在这里插入图片描述\"><br>\n跟到最重要的方法里去，代码虽长，但逻辑中规中矩。</p>\n<p><code>BeanFactoryPostProcessor</code> ：一切处理 BeanFactory 的父接口<br>\n <code>BeanDefinitionRegistryPostProcessor</code> ：实现了 BeanFactoryPostProcessor 接口的接口</p>\n<p><img src=\"/p/4c633c0c/index.html20210709233225102.png\" alt=\"在这里插入图片描述\"><br>\n流程说明：</p>\n<ul>\n<li>调用 BeanDefinitionRegistryPostProcessor#postProcessBeanDefinitionRegistry (registry) 方法。参数 beanFactoryPostProcessors 传入的优先处理掉。然后获取容器注册的，对于这些 Bean 按照 PriorityOrdered 接口、Ordered、没有排序接口的实例分别进行处理。</li>\n<li>调用 BeanFactoryPostProcessor#postProcessBeanFactory (beanFactory) 方法。备注：BeanDefinitionRegistryPostProcessor 属于 BeanFactoryPostProcessor 子接口。先处理属于 BeanDefinitionRegistryPostProcessor 接口实例的 postProcessBeanFactory (beanFactory) 方法，然后获取容器注册的。对于这些 Bean 按照 PriorityOrdered 接口、Ordered、没有排序接口的实例分别进行处理。</li>\n</ul>\n</body></html>","raw":"> Apollo动态配置其实本质就是利用Spring Bean 的生命周期的扩展点，这个扩展点超级多，不可能全部列出来，只说核心的扩展点。这也就是为什么 Spring 的扩展性很好的原因，开了很多的口子，尽可能让某个功能高内聚松耦合，用户需要哪个功能就用哪个，而不是直接来一个大而全的东西。\n\n我们先通过学习核心的，然后后续对照Apollo用到了哪些再对照，就会发现很多地方就能理解的很好了\n\n<!-- more -->\n\n**什么是 Spring Bean 的生命周期**\n\n对于普通的 Java 对象，当 new 的时候创建对象，然后该对象就能够使用了。一旦该对象不再被使用，则由 Java 自动进行垃圾回收。\n\n而 Spring 中的对象是 bean，bean 和普通的 Java 对象没啥大的区别，只不过 Spring 不再自己去 new 对象了，而是由 IoC 容器去帮助我们实例化对象并且管理它，我们需要哪个对象，去问 IoC 容器要即可。IoC 其实就是解决对象之间的耦合问题，Spring Bean 的生命周期完全由容器控制。\n\n## Spring Bean 的生命周期\n\n这里要提一下，这里我们说的 Spring Bean 的生命周期主要指的是 singleton bean，对于 prototype 的 bean ，Spring 在创建好交给使用者之后则不会再管理后续的生命周期。\n\n我们也来复习下 Spring 中的 bean 的作用域有哪些?\n\n- `singleton` : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。\n- `prototype` : 每次请求都会创建一个新的 bean 实例。\n- `request` : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。\n- `session` : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。\n- `global-session`： 全局 session 作用域，仅仅在基于 Portlet 的 web 应用中才有意义，Spring5 已经没有了。Portlet 是能够生成语义代码（例如：HTML）片段的小型 Java Web 插件。它们基于 portlet 容器，可以像 servlet 一样处理 HTTP 请求。但是，与 servlet 不同，每个 portlet 都有不同的会话。\n\n我们知道对于普通的 Java 对象来说，它们的生命周期就是：\n\n- 实例化\n- 该对象不再被使用时通过垃圾回收机制进行回收\n\n而对于 Spring Bean 的生命周期来说：\n\n- 实例化 Instantiation\n- 属性赋值 Populate\n- 初始化 Initialization\n- 销毁 Destruction\n\n实例化 -> 属性赋值 -> 初始化 -> 销毁\n\n只有四个步骤，这样拆解的话是不是感觉也不难？不像其他人写的那样直接一上来就各种 BeanPostProcessor、BeanFactoryPostProcessor 全部怼进流程里去，别说读者看着头大，自己写的可能短时间内还记得流程，隔个一段时间，你可能都不知道自己写了个啥。\n\n通过 Bean 创建流程入口`AbstractApplicationContext#refresh()` 方法的 `finishBeanFactoryInitialization(beanFactory)` 处带大家跟一下源码，想了想还是不带入过多的代码进来，直接给到最终的主要逻辑。\n\n```java\nprotected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException {\n    BeanWrapper instanceWrapper = null;\n    if (mbd.isSingleton()) {\n        instanceWrapper = (BeanWrapper)this.factoryBeanInstanceCache.remove(beanName);\n    }\n    if (instanceWrapper == null) {\n    \t// 实例化阶段\n        instanceWrapper = this.createBeanInstance(beanName, mbd, args);\n    }\n    ...\n    Object exposedObject = bean;\n\n    try {\n    \t// 属性赋值阶段\n        this.populateBean(beanName, mbd, instanceWrapper);\n        // 初始化阶段\n        exposedObject = this.initializeBean(beanName, exposedObject, mbd);\n    } catch (Throwable var18) {\n        ...\n    }\n    ...\n}\n```\n\n至于销毁，是在容器关闭时调用的，详见 `ConfigurableApplicationContext#close()`\n\n是不是很清爽了？至于 BeanPostProcessor、BeanFactoryPostProcessor 以及其他的类，只不过是对主流程四个步骤的一系列扩展点而已。\n\n## Spring Bean 的生命周期的扩展点\n\nSpring Bean 的生命周期的扩展点超级多，老周这里不可能全部列出来，只说核心的扩展点。这也就是为什么 Spring 的扩展性很好的原因，开了很多的口子，尽可能让某个功能高内聚松耦合，用户需要哪个功能就用哪个，而不是直接来一个大而全的东西。\n\n**Bean 自身的方法**\n\n比如构造函数、getter/setter 以及 init-method 和 destory-method 所指定的方法等，也就对应着上文说的实例化 -> 属性赋值 -> 初始化 -> 销毁四个阶段。\n\n![阶段示意图](/p/4c633c0c/20210707002134280.png)\n\n**容器级的方法（BeanPostProcessor 一系列接口）**\n\n主要是后处理器方法，比如下图的 `InstantiationAwareBeanPostProcessor`、`BeanPostProcessor` 接口方法。这些接口的实现类是独立于 Bean 的，并且会注册到 Spring 容器中。在 Spring 容器创建任何 Bean 的时候，这些后处理器都会发生作用。\n\n![扩展点](/p/4c633c0c/20210707225212729.png)\n\n **InstantiationAwareBeanPostProcessor 源码分析**\n\n我们翻一下源码发现 InstantiationAwareBeanPostProcessor 是继承了 BeanPostProcessor\n\n![InstantiationAwareBeanPostProcessor ](/p/4c633c0c/20210707230505579.png)\n\n![BeanPostProcessor](/p/4c633c0c/20210707230919307.png)\n\n- `InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation` 调用点\n\n> Object postProcessBeforeInstantiation(Class<?> beanClass, String beanName)\n> 返回值：如果返回的不为null，那么后续的Bean的创建流程【实例化、初始化afterProperties】都不会执行，而是直接使用返回的快捷Bean，此时的正常执行顺序如下：\n> InstantiationAwareBeanPostProcessor接口中的postProcessBeforeInstantiation，在实例化之前调用。\n> BeanPostProcessor接口中的postProcessAfterInitialization，在实例化之后调用。\n\n![createbean](/p/4c633c0c//img-blog.csdnimg.cn/20210707233026943.png)\n\n![resolveBeforeInstantiation](/p/4c633c0c/20210707235533784.png)\n\n![applyBean](/p/4c633c0c/20210708000228655.png)\n\n总之，postProcessBeforeInstantiation 在 doCreateBean 之前调用，也就是在 bean 实例化之前调用的，英文源码注释解释道该方法的返回值会替换原本的 Bean 作为代理，这也是 [AOP](https://so.csdn.net/so/search?q=AOP&spm=1001.2101.3001.7020) 等功能实现的关键点。\n\n- `InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation` 调用点\n\n> boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException\n> 正常情况下在实例化之后在执行populateBean之前调用\n> 返回值：如果有指定的bean的时候返回false，那么后续的属性填充和属性依赖注入【populateBean】将不会执行，同时后续的postProcessPropertyValues将不会执行,但是初始化和BeanPostProcessor的仍然会执行。\n\n![populateBean](/p/4c633c0c/20210708005050274.png)\n\npublic PropertyValues postProcessPropertyValues(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)\n实例化之后调用，在方法applyPropertyValues【属性填充】之前\n返回值：如果返回null，那么将不会进行后续的属性填充，比如依赖注入等，如果返回的pvs额外的添加了属性，那么后续会填充到该类对应的属性中。\npvs：PropertyValues对象，用于封装指定类的对象，简单来说就是PropertyValue的集合，里面相当于以key-value形式存放类的属性和值。\npds：PropertyDescriptor对象数组，PropertyDescriptor相当于存储类的属性，不过可以调用set，get方法设置和获取对应属性的值。\n\n![postProcessPropertyValues](/p/4c633c0c/20210708010057366.png)\n\n**BeanPostProcessor 源码分析**\n\n> org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#doCreateBean\n\n![在这里插入图片描述](/p/4c633c0c/20210708232740951.png)\n进入初始化接口：\n\n![在这里插入图片描述](/p/4c633c0c/20210708233139731.png)\n我们先来看\n\n> org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#applyBeanPostProcessorsBeforeInitialization\n\n![在这里插入图片描述](/p/4c633c0c/20210708233742525.png)\n\n- 首先获取到所有的后置处理器 getBeanPostProcessors()\n- 在 for 循环中依次调用后置处理器的方法 `processor.postProcessBeforeInitialization(result, beanName);`\n- 进入 postProcessBeforeInitialization 方法\n\n> org.springframework.context.support.ApplicationContextAwareProcessor#postProcessBeforeInitialization\n\n![在这里插入图片描述](/p/4c633c0c/20210708234443215.png)\n\n进入 `invokeAwareInterfaces(bean);` 方法，当前 bean 实现了 ApplicationContextAware 接口。\n\n![在这里插入图片描述](/p/4c633c0c/20210708234639952.png)\n\n- `ApplicationContextAwareProcessor#postProcessBeforeInitialization` 首先判断此 bean 是不是各种的Aware，如果是它列举的那几个 Aware 就获取 Bean 工厂的权限，可以向容器中导入相关的上下文环境，目的是为了 Bean 实例能够获取到相关的上下文，如果不是它列举的几个 Aware，那就调用 `invokeAwareInterfaces(bean)`，向容器中添加相关接口的上下文环境。\n\n**3.3 工厂后处理器方法（BeanFactoryProcessor 一系列接口）**\n\n包括 `AspectJWeavingEnabler`、`CustomAutowireConfigurer`、`ConfigurationClassPostProcessor` 等。这些都是 Spring 框架中已经实现好的 BeanFactoryPostProcessor，用来实现某些特定的功能。\n\n我们知道 Spring IoC 容器初始化的关键环节就在 `org.springframework.context.support.AbstractApplicationContext#refresh` 方法中 ，容器创建的主体流程都在这个方法里面，这个方法是真的重要！！！\n\n对于工厂后处理器方法老周这里直接带你看 `invokeBeanFactoryPostProcessors(beanFactory);` 方法，这个方法处理的是 `BeanFactoryPostProcessor` 接口的 Bean。调用方法如下：\n\n![在这里插入图片描述](/p/4c633c0c/20210709231013239.png)\n跟到最重要的方法里去，代码虽长，但逻辑中规中矩。\n\n`BeanFactoryPostProcessor`：一切处理 BeanFactory 的父接口\n`BeanDefinitionRegistryPostProcessor`：实现了 BeanFactoryPostProcessor 接口的接口\n\n![在这里插入图片描述](/p/4c633c0c/20210709233225102.png)\n流程说明：\n\n- 调用 BeanDefinitionRegistryPostProcessor#postProcessBeanDefinitionRegistry(registry) 方法。参数 beanFactoryPostProcessors 传入的优先处理掉。然后获取容器注册的，对于这些 Bean 按照 PriorityOrdered 接口、Ordered、没有排序接口的实例分别进行处理。\n- 调用 BeanFactoryPostProcessor#postProcessBeanFactory(beanFactory) 方法。备注：BeanDefinitionRegistryPostProcessor 属于 BeanFactoryPostProcessor 子接口。先处理属于 BeanDefinitionRegistryPostProcessor 接口实例的 postProcessBeanFactory(beanFactory) 方法，然后获取容器注册的。对于这些 Bean 按照 PriorityOrdered 接口、Ordered、没有排序接口的实例分别进行处理。\n","more":"<html><head></head><body><p><strong>什么是 Spring Bean 的生命周期</strong></p>\n<p>对于普通的 Java 对象，当 new 的时候创建对象，然后该对象就能够使用了。一旦该对象不再被使用，则由 Java 自动进行垃圾回收。</p>\n<p>而 Spring 中的对象是 bean，bean 和普通的 Java 对象没啥大的区别，只不过 Spring 不再自己去 new 对象了，而是由 IoC 容器去帮助我们实例化对象并且管理它，我们需要哪个对象，去问 IoC 容器要即可。IoC 其实就是解决对象之间的耦合问题，Spring Bean 的生命周期完全由容器控制。</p>\n<h2 id=\"spring-bean-的生命周期\"><a class=\"markdownIt-Anchor\" href=\"#spring-bean-的生命周期\">#</a> Spring Bean 的生命周期</h2>\n<p>这里要提一下，这里我们说的 Spring Bean 的生命周期主要指的是 singleton bean，对于 prototype 的 bean ，Spring 在创建好交给使用者之后则不会再管理后续的生命周期。</p>\n<p>我们也来复习下 Spring 中的 bean 的作用域有哪些？</p>\n<ul>\n<li><code>singleton</code>  : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。</li>\n<li><code>prototype</code>  : 每次请求都会创建一个新的 bean 实例。</li>\n<li><code>request</code>  : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。</li>\n<li><code>session</code>  : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。</li>\n<li><code>global-session</code> ： 全局 session 作用域，仅仅在基于 Portlet 的 web 应用中才有意义，Spring5 已经没有了。Portlet 是能够生成语义代码（例如：HTML）片段的小型 Java Web 插件。它们基于 portlet 容器，可以像 servlet 一样处理 HTTP 请求。但是，与 servlet 不同，每个 portlet 都有不同的会话。</li>\n</ul>\n<p>我们知道对于普通的 Java 对象来说，它们的生命周期就是：</p>\n<ul>\n<li>实例化</li>\n<li>该对象不再被使用时通过垃圾回收机制进行回收</li>\n</ul>\n<p>而对于 Spring Bean 的生命周期来说：</p>\n<ul>\n<li>实例化 Instantiation</li>\n<li>属性赋值 Populate</li>\n<li>初始化 Initialization</li>\n<li>销毁 Destruction</li>\n</ul>\n<p>实例化 -&gt; 属性赋值 -&gt; 初始化 -&gt; 销毁</p>\n<p>只有四个步骤，这样拆解的话是不是感觉也不难？不像其他人写的那样直接一上来就各种 BeanPostProcessor、BeanFactoryPostProcessor 全部怼进流程里去，别说读者看着头大，自己写的可能短时间内还记得流程，隔个一段时间，你可能都不知道自己写了个啥。</p>\n<p>通过 Bean 创建流程入口 <code>AbstractApplicationContext#refresh()</code>  方法的  <code>finishBeanFactoryInitialization(beanFactory)</code>  处带大家跟一下源码，想了想还是不带入过多的代码进来，直接给到最终的主要逻辑。</p>\n<figure class=\"highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> Object <span class=\"title function_\">doCreateBean</span><span class=\"params\">(String beanName, RootBeanDefinition mbd, <span class=\"meta\">@Nullable</span> Object[] args)</span> <span class=\"keyword\">throws</span> BeanCreationException {</span><br><span class=\"line\">    <span class=\"type\">BeanWrapper</span> <span class=\"variable\">instanceWrapper</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mbd.isSingleton()) {</span><br><span class=\"line\">        instanceWrapper = (BeanWrapper)<span class=\"built_in\">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instanceWrapper == <span class=\"literal\">null</span>) {</span><br><span class=\"line\">    \t<span class=\"comment\">// 实例化阶段</span></span><br><span class=\"line\">        instanceWrapper = <span class=\"built_in\">this</span>.createBeanInstance(beanName, mbd, args);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"type\">Object</span> <span class=\"variable\">exposedObject</span> <span class=\"operator\">=</span> bean;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> {</span><br><span class=\"line\">    \t<span class=\"comment\">// 属性赋值阶段</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.populateBean(beanName, mbd, instanceWrapper);</span><br><span class=\"line\">        <span class=\"comment\">// 初始化阶段</span></span><br><span class=\"line\">        exposedObject = <span class=\"built_in\">this</span>.initializeBean(beanName, exposedObject, mbd);</span><br><span class=\"line\">    } <span class=\"keyword\">catch</span> (Throwable var18) {</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    }</span><br><span class=\"line\">    ...</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure>\n<p>至于销毁，是在容器关闭时调用的，详见  <code>ConfigurableApplicationContext#close()</code></p>\n<p>是不是很清爽了？至于 BeanPostProcessor、BeanFactoryPostProcessor 以及其他的类，只不过是对主流程四个步骤的一系列扩展点而已。</p>\n<h2 id=\"spring-bean-的生命周期的扩展点\"><a class=\"markdownIt-Anchor\" href=\"#spring-bean-的生命周期的扩展点\">#</a> Spring Bean 的生命周期的扩展点</h2>\n<p>Spring Bean 的生命周期的扩展点超级多，老周这里不可能全部列出来，只说核心的扩展点。这也就是为什么 Spring 的扩展性很好的原因，开了很多的口子，尽可能让某个功能高内聚松耦合，用户需要哪个功能就用哪个，而不是直接来一个大而全的东西。</p>\n<p><strong>Bean 自身的方法</strong></p>\n<p>比如构造函数、getter/setter 以及 init-method 和 destory-method 所指定的方法等，也就对应着上文说的实例化 -&gt; 属性赋值 -&gt; 初始化 -&gt; 销毁四个阶段。</p>\n<p><img src=\"/p/4c633c0c/index.html20210707002134280.png\" alt=\"阶段示意图\"></p>\n<p><strong>容器级的方法（BeanPostProcessor 一系列接口）</strong></p>\n<p>主要是后处理器方法，比如下图的  <code>InstantiationAwareBeanPostProcessor</code> 、 <code>BeanPostProcessor</code>  接口方法。这些接口的实现类是独立于 Bean 的，并且会注册到 Spring 容器中。在 Spring 容器创建任何 Bean 的时候，这些后处理器都会发生作用。</p>\n<p><img src=\"/p/4c633c0c/index.html20210707225212729.png\" alt=\"扩展点\"></p>\n<p><strong>InstantiationAwareBeanPostProcessor 源码分析</strong></p>\n<p>我们翻一下源码发现 InstantiationAwareBeanPostProcessor 是继承了 BeanPostProcessor</p>\n<p><img src=\"/p/4c633c0c/index.html20210707230505579.png\" alt=\"InstantiationAwareBeanPostProcessor \"></p>\n<p><img src=\"/p/4c633c0c/index.html20210707230919307.png\" alt=\"BeanPostProcessor\"></p>\n<ul>\n<li><code>InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation</code>  调用点</li>\n</ul>\n<blockquote>\n<p>Object postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName)<br>\n 返回值：如果返回的不为 null，那么后续的 Bean 的创建流程【实例化、初始化 afterProperties】都不会执行，而是直接使用返回的快捷 Bean，此时的正常执行顺序如下：<br>\nInstantiationAwareBeanPostProcessor 接口中的 postProcessBeforeInstantiation，在实例化之前调用。<br>\nBeanPostProcessor 接口中的 postProcessAfterInitialization，在实例化之后调用。</p>\n</blockquote>\n<p><img src=\"https://img-blog.csdnimg.cn/20210707233026943.png\" alt=\"createbean\"></p>\n<p><img src=\"/p/4c633c0c/index.html20210707235533784.png\" alt=\"resolveBeforeInstantiation\"></p>\n<p><img src=\"/p/4c633c0c/index.html20210708000228655.png\" alt=\"applyBean\"></p>\n<p>总之，postProcessBeforeInstantiation 在 doCreateBean 之前调用，也就是在 bean 实例化之前调用的，英文源码注释解释道该方法的返回值会替换原本的 Bean 作为代理，这也是 <a href=\"https://so.csdn.net/so/search?q=AOP&amp;spm=1001.2101.3001.7020\">AOP</a> 等功能实现的关键点。</p>\n<ul>\n<li><code>InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation</code>  调用点</li>\n</ul>\n<blockquote>\n<p>boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException<br>\n 正常情况下在实例化之后在执行 populateBean 之前调用<br>\n返回值：如果有指定的 bean 的时候返回 false，那么后续的属性填充和属性依赖注入【populateBean】将不会执行，同时后续的 postProcessPropertyValues 将不会执行，但是初始化和 BeanPostProcessor 的仍然会执行。</p>\n</blockquote>\n<p><img src=\"/p/4c633c0c/index.html20210708005050274.png\" alt=\"populateBean\"></p>\n<p>public PropertyValues postProcessPropertyValues(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)<br>\n 实例化之后调用，在方法 applyPropertyValues【属性填充】之前<br>\n返回值：如果返回 null，那么将不会进行后续的属性填充，比如依赖注入等，如果返回的 pvs 额外的添加了属性，那么后续会填充到该类对应的属性中。<br>\npvs：PropertyValues 对象，用于封装指定类的对象，简单来说就是 PropertyValue 的集合，里面相当于以 key-value 形式存放类的属性和值。<br>\npds：PropertyDescriptor 对象数组，PropertyDescriptor 相当于存储类的属性，不过可以调用 set，get 方法设置和获取对应属性的值。</p>\n<p><img src=\"/p/4c633c0c/index.html20210708010057366.png\" alt=\"postProcessPropertyValues\"></p>\n<p><strong>BeanPostProcessor 源码分析</strong></p>\n<blockquote>\n<p>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#doCreateBean</p>\n</blockquote>\n<p><img src=\"/p/4c633c0c/index.html20210708232740951.png\" alt=\"在这里插入图片描述\"><br>\n进入初始化接口：</p>\n<p><img src=\"/p/4c633c0c/index.html20210708233139731.png\" alt=\"在这里插入图片描述\"><br>\n我们先来看</p>\n<blockquote>\n<p>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#applyBeanPostProcessorsBeforeInitialization</p>\n</blockquote>\n<p><img src=\"/p/4c633c0c/index.html20210708233742525.png\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li>首先获取到所有的后置处理器 getBeanPostProcessors ()</li>\n<li>在 for 循环中依次调用后置处理器的方法  <code>processor.postProcessBeforeInitialization(result, beanName);</code></li>\n<li>进入 postProcessBeforeInitialization 方法</li>\n</ul>\n<blockquote>\n<p>org.springframework.context.support.ApplicationContextAwareProcessor#postProcessBeforeInitialization</p>\n</blockquote>\n<p><img src=\"/p/4c633c0c/index.html20210708234443215.png\" alt=\"在这里插入图片描述\"></p>\n<p>进入  <code>invokeAwareInterfaces(bean);</code>  方法，当前 bean 实现了 ApplicationContextAware 接口。</p>\n<p><img src=\"/p/4c633c0c/index.html20210708234639952.png\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li><code>ApplicationContextAwareProcessor#postProcessBeforeInitialization</code>  首先判断此 bean 是不是各种的 Aware，如果是它列举的那几个 Aware 就获取 Bean 工厂的权限，可以向容器中导入相关的上下文环境，目的是为了 Bean 实例能够获取到相关的上下文，如果不是它列举的几个 Aware，那就调用  <code>invokeAwareInterfaces(bean)</code> ，向容器中添加相关接口的上下文环境。</li>\n</ul>\n<p><strong>3.3 工厂后处理器方法（BeanFactoryProcessor 一系列接口）</strong></p>\n<p>包括  <code>AspectJWeavingEnabler</code> 、 <code>CustomAutowireConfigurer</code> 、 <code>ConfigurationClassPostProcessor</code>  等。这些都是 Spring 框架中已经实现好的 BeanFactoryPostProcessor，用来实现某些特定的功能。</p>\n<p>我们知道 Spring IoC 容器初始化的关键环节就在  <code>org.springframework.context.support.AbstractApplicationContext#refresh</code>  方法中 ，容器创建的主体流程都在这个方法里面，这个方法是真的重要！！！</p>\n<p>对于工厂后处理器方法老周这里直接带你看  <code>invokeBeanFactoryPostProcessors(beanFactory);</code>  方法，这个方法处理的是  <code>BeanFactoryPostProcessor</code>  接口的 Bean。调用方法如下：</p>\n<p><img src=\"/p/4c633c0c/index.html20210709231013239.png\" alt=\"在这里插入图片描述\"><br>\n跟到最重要的方法里去，代码虽长，但逻辑中规中矩。</p>\n<p><code>BeanFactoryPostProcessor</code> ：一切处理 BeanFactory 的父接口<br>\n <code>BeanDefinitionRegistryPostProcessor</code> ：实现了 BeanFactoryPostProcessor 接口的接口</p>\n<p><img src=\"/p/4c633c0c/index.html20210709233225102.png\" alt=\"在这里插入图片描述\"><br>\n流程说明：</p>\n<ul>\n<li>调用 BeanDefinitionRegistryPostProcessor#postProcessBeanDefinitionRegistry (registry) 方法。参数 beanFactoryPostProcessors 传入的优先处理掉。然后获取容器注册的，对于这些 Bean 按照 PriorityOrdered 接口、Ordered、没有排序接口的实例分别进行处理。</li>\n<li>调用 BeanFactoryPostProcessor#postProcessBeanFactory (beanFactory) 方法。备注：BeanDefinitionRegistryPostProcessor 属于 BeanFactoryPostProcessor 子接口。先处理属于 BeanDefinitionRegistryPostProcessor 接口实例的 postProcessBeanFactory (beanFactory) 方法，然后获取容器注册的。对于这些 Bean 按照 PriorityOrdered 接口、Ordered、没有排序接口的实例分别进行处理。</li>\n</ul></body></html>","categories":[{"name":"Java","path":"api/categories/Java.json"}],"tags":[{"name":"Apollo","path":"api/tags/Apollo.json"},{"name":"Spring","path":"api/tags/Spring.json"}]}