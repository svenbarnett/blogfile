{"title":"从Apollo动态配置原理学Spring(一)","slug":"20230223","date":"2023-02-23T14:29:54.000Z","updated":"2023-04-30T03:19:29.046Z","comments":true,"path":"api/articles/20230223.json","realpath":"/p/e352a76e/","excerpt":"最近工作碰到需要写一个类似携程 Apollo 的动态配置功能，以此系统学习该原理，熟练掌握下 Spring 的各种机制Apollo 动态配置原理简述Apollo 配置中心动态生效机制，是基于 Http 长轮询请求和 Spring 扩展机制实现的，在 Spring 容器启动过程中，Apollo 通过自定义的 BeanPostProcessor  和 BeanFactoryPostProcessor  將参数中包含 ${…}  占位符和 @Value  注解的 Bean 注册到 Apollo 框架中定义的注册表中。然后通过 Http 长轮询不断的去获取服务端的配置信息，一旦配置发生变化，Apollo 会根据变化的配置的 Key 找到对应的 Bean，然后修改 Bean 的属性，从而实现了配置动态生效的特性。需要注意的是，Apollo 在配置变化后，只能修改 Bean 的属性，例如我们数据源的属性发生变化，新创建的 Connection 对象是没问题的，但是连接池中已经创建的 Connection 对象相关信息是不能动态修改的，所以依然需要重启应用。","cover":"/p/e352a76e/image-20230223224050610.png","content":"<html><head></head><body><blockquote>\n<p>最近工作碰到需要写一个类似携程 Apollo 的动态配置功能，以此系统学习该原理，熟练掌握下 Spring 的各种机制</p>\n</blockquote>\n<p><strong>Apollo 动态配置原理简述</strong></p>\n<p>Apollo 配置中心动态生效机制，是基于 Http 长轮询请求和 Spring 扩展机制实现的，在 Spring 容器启动过程中，Apollo 通过自定义的 <code>BeanPostProcessor</code>  和 <code>BeanFactoryPostProcessor</code>  將参数中包含 <code>${…}</code>  占位符和 <code>@Value</code>  注解的 Bean 注册到 Apollo 框架中定义的注册表中。然后通过 Http 长轮询不断的去获取服务端的配置信息，一旦配置发生变化，Apollo 会根据变化的配置的 Key 找到对应的 Bean，然后修改 Bean 的属性，从而实现了配置动态生效的特性。</p>\n<p>需要注意的是，Apollo 在配置变化后，只能修改 Bean 的属性，例如我们数据源的属性发生变化，新创建的 Connection 对象是没问题的，但是连接池中已经创建的 Connection 对象相关信息是不能动态修改的，所以依然需要重启应用。</p>\n<span id=\"more\"></span>\n<p>其中涉及到的 Spring 的扩展机制有：</p>\n<ul>\n<li>BeanFactoryPostProcessor</li>\n<li>BeanPostProcessor</li>\n<li>BeanDefinitionRegistry</li>\n<li>PropertySource</li>\n<li>ImportBeanDefinitionRegistrar</li>\n<li>PropertySourcesPlaceholderConfigurer</li>\n</ul>\n<p>…</p>\n<p>其中每一个都是非常关键的点，我们后续会一一进行学习。</p>\n<h2 id=\"apollo启动过程\"><a class=\"markdownIt-Anchor\" href=\"#apollo启动过程\">#</a> Apollo 启动过程</h2>\n<p>首先，我们先看一张图：</p>\n<p><img src=\"/p/e352a76e/image-20230223224050610.png\" alt=\"Apollo启动图\"></p>\n<ol>\n<li>\n<p>Spring 启动，扫描 bean，将相关变量参数注册到 Apollo 属性注册表</p>\n</li>\n<li>\n<p>通过 RemoteConfigRepository 获取配置，持久化本地，后续读取从本地读取，通过 <code>PropertySourcesProcessor</code>  执行如下步骤</p>\n</li>\n</ol>\n<p>（1）根据命名空间从配置中心获取配置信息，创建 RemoteConfigRepository 和 LocalFileConfigRepository 对象。RemoteConfigRepository 表示远程配置中心资源，LocalFileConfigRepository 表示本地缓存配置资源。</p>\n<p>（2）LocalFileConfigRepository 对象缓存配置信息到 C:\\opt\\data 或者 /opt/data 目录</p>\n<p>（3）RemoteConfigRepository 开启 HTTP 长轮询请求定时任务，默认 2s 请求一次。</p>\n<p>（4）將本地缓存配置信息转换为 PropertySource 对象（Apollo 自定义了 Spring 的 PropertySource），加载到 Spring 的 Environment 对象中。至此静态配置就已经加入到环境变量中</p>\n<p>（5）將自定义的 ConfigPropertySource 注册为观察者。一旦 RemoteConfigRepository 发现远程配置中心信息发生变化，ConfigPropertySource 对象会得到通知。</p>\n<ol start=\"3\">\n<li>\n<p>通过一个自定义监听器，监听对应事件</p>\n</li>\n<li>\n<p>后续通过长轮询请求监听到配置变化，根据配置读取注册表里面的 key 和对应的 bean，通过反射修改 bean 对应属性值</p>\n</li>\n</ol>\n<h2 id=\"apollo扩展点\"><a class=\"markdownIt-Anchor\" href=\"#apollo扩展点\">#</a> Apollo 扩展点</h2>\n<ol>\n<li><code>PropertySourcesProcessor</code>  初始化 Apollo 配置、接入 Spring environment，初始化 Apollo 监听器</li>\n<li><code>ApolloAnnotationProcessor</code>  提供 Apollo 一些注解支持 <code>@ApolloConfig</code> ， <code>@ApolloConfigChangeListener</code></li>\n<li><code>SpringValueProcessor</code>  提供对 <code>@Value</code>  动态生效能力 针对实例 bean</li>\n<li><code>SpringValueDefinitionProcessor</code>  提供对 <code>@Value</code>  动态生效能力 针对 bean 定义</li>\n<li><code>ApolloJsonValueProcessor</code>  提供对 <code>@ApolloJsonValue</code>  支持</li>\n</ol>\n<p>上述分别对应使用 Spring 的扩展能力 <code>BeanFactoryPostProcessor</code> 、 <code>BeanPostProcessor</code> 、 <code>BeanPostProcessor</code>  和 <code>BeanFactoryPostProcessor</code> 、 <code>BeanDefinitionRegistryPostProcessor</code> 、 <code>BeanPostProcessor</code></p>\n<p>我们这个系列也会对 apollo 基于 spring 提供的扩展点来嵌入自己的能力。主要为 BeanFactoryPostProcessor、BeanPostProcessor 这两个扩展点；先简单说一下：<em><strong>只需要知道，BeanFactoryPostProcessor、BeanDefinitionRegistryPostProcessor 在生成所有 beandefinition 之后调用，而 BeanPostProcessor 在通过 beandefinition 实例化 bean 的过程中调用即可。</strong></em></p>\n<p>那这些实现我们就下篇见了！！！</p>\n</body></html>","raw":"> 最近工作碰到需要写一个类似携程Apollo的动态配置功能，以此系统学习该原理，熟练掌握下Spring的各种机制\n\n**Apollo动态配置原理简述**\n\nApollo配置中心动态生效机制，是基于Http长轮询请求和Spring扩展机制实现的，在Spring容器启动过程中，Apollo通过自定义的`BeanPostProcessor`和`BeanFactoryPostProcessor`將参数中包含`${…}`占位符和`@Value`注解的Bean注册到Apollo框架中定义的注册表中。然后通过Http长轮询不断的去获取服务端的配置信息，一旦配置发生变化，Apollo会根据变化的配置的Key找到对应的Bean，然后修改Bean的属性，从而实现了配置动态生效的特性。\n\n需要注意的是，Apollo在配置变化后，只能修改Bean的属性，例如我们数据源的属性发生变化，新创建的Connection对象是没问题的，但是连接池中已经创建的Connection对象相关信息是不能动态修改的，所以依然需要重启应用。\n\n<!-- more -->\n\n其中涉及到的Spring的扩展机制有：\n\n- BeanFactoryPostProcessor\n- BeanPostProcessor\n- BeanDefinitionRegistry\n- PropertySource\n- ImportBeanDefinitionRegistrar\n- PropertySourcesPlaceholderConfigurer\n\n...\n\n其中每一个都是非常关键的点，我们后续会一一进行学习。\n\n## Apollo启动过程\n\n首先，我们先看一张图：\n\n![Apollo启动图](/p/e352a76e/image-20230223224050610.png)\n\n1. Spring启动，扫描bean，将相关变量参数注册到Apollo属性注册表\n\n2.  通过RemoteConfigRepository获取配置，持久化本地，后续读取从本地读取,通过`PropertySourcesProcessor`执行如下步骤\n\n   （1）根据命名空间从配置中心获取配置信息，创建RemoteConfigRepository和LocalFileConfigRepository对象。RemoteConfigRepository表示远程配置中心资源，LocalFileConfigRepository表示本地缓存配置资源。\n\n   （2）LocalFileConfigRepository对象缓存配置信息到C:\\opt\\data 或者/opt/data目录\n\n   （3）RemoteConfigRepository开启HTTP长轮询请求定时任务，默认2s请求一次。\n\n   （4）將本地缓存配置信息转换为PropertySource对象（Apollo自定义了Spring的PropertySource），加载到Spring的Environment对象中。至此静态配置就已经加入到环境变量中\n\n   （5）將自定义的ConfigPropertySource注册为观察者。一旦RemoteConfigRepository发现远程配置中心信息发生变化，ConfigPropertySource对象会得到通知。\n\n3. 通过一个自定义监听器，监听对应事件\n\n4. 后续通过长轮询请求监听到配置变化，根据配置读取注册表里面的key和对应的bean，通过反射修改bean对应属性值\n\n## Apollo扩展点\n\n1. `PropertySourcesProcessor`初始化Apollo配置、接入Spring environment，初始化Apollo监听器\n2. `ApolloAnnotationProcessor`提供Apollo一些注解支持`@ApolloConfig`，`@ApolloConfigChangeListener`\n3. `SpringValueProcessor`提供对`@Value`动态生效能力 针对实例bean\n4. `SpringValueDefinitionProcessor`提供对`@Value`动态生效能力 针对bean定义\n4. `ApolloJsonValueProcessor`提供对`@ApolloJsonValue` 支持\n\n上述分别对应使用Spring的扩展能力`BeanFactoryPostProcessor`、`BeanPostProcessor`、`BeanPostProcessor`和`BeanFactoryPostProcessor`、`BeanDefinitionRegistryPostProcessor`、`BeanPostProcessor`\n\n我们这个系列也会对apollo基于spring提供的扩展点来嵌入自己的能力。主要为BeanFactoryPostProcessor、BeanPostProcessor这两个扩展点；先简单说一下：***只需要知道，BeanFactoryPostProcessor、BeanDefinitionRegistryPostProcessor在生成所有beandefinition之后调用，而BeanPostProcessor在通过beandefinition实例化bean的过程中调用即可。***\n\n\n\n那这些实现我们就下篇见了！！！","more":"<html><head></head><body><p>其中涉及到的 Spring 的扩展机制有：</p>\n<ul>\n<li>BeanFactoryPostProcessor</li>\n<li>BeanPostProcessor</li>\n<li>BeanDefinitionRegistry</li>\n<li>PropertySource</li>\n<li>ImportBeanDefinitionRegistrar</li>\n<li>PropertySourcesPlaceholderConfigurer</li>\n</ul>\n<p>…</p>\n<p>其中每一个都是非常关键的点，我们后续会一一进行学习。</p>\n<h2 id=\"apollo启动过程\"><a class=\"markdownIt-Anchor\" href=\"#apollo启动过程\">#</a> Apollo 启动过程</h2>\n<p>首先，我们先看一张图：</p>\n<p><img src=\"/p/e352a76e/image-20230223224050610.png\" alt=\"Apollo启动图\"></p>\n<ol>\n<li>\n<p>Spring 启动，扫描 bean，将相关变量参数注册到 Apollo 属性注册表</p>\n</li>\n<li>\n<p>通过 RemoteConfigRepository 获取配置，持久化本地，后续读取从本地读取，通过 <code>PropertySourcesProcessor</code>  执行如下步骤</p>\n</li>\n</ol>\n<p>（1）根据命名空间从配置中心获取配置信息，创建 RemoteConfigRepository 和 LocalFileConfigRepository 对象。RemoteConfigRepository 表示远程配置中心资源，LocalFileConfigRepository 表示本地缓存配置资源。</p>\n<p>（2）LocalFileConfigRepository 对象缓存配置信息到 C:\\opt\\data 或者 /opt/data 目录</p>\n<p>（3）RemoteConfigRepository 开启 HTTP 长轮询请求定时任务，默认 2s 请求一次。</p>\n<p>（4）將本地缓存配置信息转换为 PropertySource 对象（Apollo 自定义了 Spring 的 PropertySource），加载到 Spring 的 Environment 对象中。至此静态配置就已经加入到环境变量中</p>\n<p>（5）將自定义的 ConfigPropertySource 注册为观察者。一旦 RemoteConfigRepository 发现远程配置中心信息发生变化，ConfigPropertySource 对象会得到通知。</p>\n<ol start=\"3\">\n<li>\n<p>通过一个自定义监听器，监听对应事件</p>\n</li>\n<li>\n<p>后续通过长轮询请求监听到配置变化，根据配置读取注册表里面的 key 和对应的 bean，通过反射修改 bean 对应属性值</p>\n</li>\n</ol>\n<h2 id=\"apollo扩展点\"><a class=\"markdownIt-Anchor\" href=\"#apollo扩展点\">#</a> Apollo 扩展点</h2>\n<ol>\n<li><code>PropertySourcesProcessor</code>  初始化 Apollo 配置、接入 Spring environment，初始化 Apollo 监听器</li>\n<li><code>ApolloAnnotationProcessor</code>  提供 Apollo 一些注解支持 <code>@ApolloConfig</code> ， <code>@ApolloConfigChangeListener</code></li>\n<li><code>SpringValueProcessor</code>  提供对 <code>@Value</code>  动态生效能力 针对实例 bean</li>\n<li><code>SpringValueDefinitionProcessor</code>  提供对 <code>@Value</code>  动态生效能力 针对 bean 定义</li>\n<li><code>ApolloJsonValueProcessor</code>  提供对 <code>@ApolloJsonValue</code>  支持</li>\n</ol>\n<p>上述分别对应使用 Spring 的扩展能力 <code>BeanFactoryPostProcessor</code> 、 <code>BeanPostProcessor</code> 、 <code>BeanPostProcessor</code>  和 <code>BeanFactoryPostProcessor</code> 、 <code>BeanDefinitionRegistryPostProcessor</code> 、 <code>BeanPostProcessor</code></p>\n<p>我们这个系列也会对 apollo 基于 spring 提供的扩展点来嵌入自己的能力。主要为 BeanFactoryPostProcessor、BeanPostProcessor 这两个扩展点；先简单说一下：<em><strong>只需要知道，BeanFactoryPostProcessor、BeanDefinitionRegistryPostProcessor 在生成所有 beandefinition 之后调用，而 BeanPostProcessor 在通过 beandefinition 实例化 bean 的过程中调用即可。</strong></em></p>\n<p>那这些实现我们就下篇见了！！！</p></body></html>","categories":[{"name":"Java","path":"api/categories/Java.json"}],"tags":[{"name":"Apollo","path":"api/tags/Apollo.json"},{"name":"Spring","path":"api/tags/Spring.json"},{"name":"动态配置","path":"api/tags/动态配置.json"}]}