{"title":"单词接龙——leetcode127","slug":"word-ladder","date":"2022-01-09T10:38:08.000Z","updated":"2023-02-12T10:18:53.378Z","comments":true,"path":"api/articles/word-ladder.json","realpath":"/p/fbb9fe6d/","excerpt":"# 题目描述字典 wordList 中从单词 beginWord 和 endWord 的 转换序列 是一个按下述规格形成的序列：<br>序列中第一个单词是  beginWord  。<br>序列中最后一个单词是  endWord 。<br>每次转换只能改变一个字母。<br>转换过程中的中间单词必须是字典  wordList  中的单词。<br>给你两个单词  beginWord  和  endWord  和一个字典  wordList  ，找到从  beginWord  到  endWord  的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回  0 。","cover":"/p/fbb9fe6d/leetcode127.png","content":"<h1 id=\"题目描述\"><a class=\"markdownIt-Anchor\" href=\"#题目描述\">#</a> 题目描述</h1>\n<p>字典 wordList 中从单词 beginWord 和 endWord 的 转换序列 是一个按下述规格形成的序列：<br>\n序列中第一个单词是  <code>beginWord</code>  。<br>\n序列中最后一个单词是  <code>endWord</code> 。<br>\n每次转换只能改变一个字母。<br>\n转换过程中的中间单词必须是字典  <code>wordList</code>  中的单词。<br>\n给你两个单词  <code>beginWord</code>  和  <code>endWord</code>  和一个字典  <code>wordList</code>  ，找到从  <code>beginWord </code> 到  <code>endWord</code>  的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回  <code>0</code> 。</p>\n<span id=\"more\"></span>\n<p>示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class=\"line\">输出：5</span><br><span class=\"line\">解释：一个最短转换序列是 &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;, 返回它的长度 5。</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class=\"line\">输出：0</span><br><span class=\"line\">解释：endWord &quot;cog&quot; 不在字典中，所以无法进行转换。</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 &lt;= beginWord.length &lt;= 10</span><br><span class=\"line\">endWord.length == beginWord.length</span><br><span class=\"line\">1 &lt;= wordList.length &lt;= 5000</span><br><span class=\"line\">wordList[i].length == beginWord.length</span><br><span class=\"line\">beginWord、endWord 和 wordList[i] 由小写英文字母组成</span><br><span class=\"line\">beginWord != endWord</span><br><span class=\"line\">wordList 中的所有字符串 互不相同</span><br></pre></td></tr></table></figure>\n<h1 id=\"解题\"><a class=\"markdownIt-Anchor\" href=\"#解题\">#</a> 解题</h1>\n<h3 id=\"方法一广度优先搜索-优化建图\"><a class=\"markdownIt-Anchor\" href=\"#方法一广度优先搜索-优化建图\">#</a> 方法一：广度优先搜索 + 优化建图</h3>\n<h4 id=\"思路\"><a class=\"markdownIt-Anchor\" href=\"#思路\">#</a> 思路</h4>\n<p>本题要求的是最短转换序列的长度，看到最短首先想到的就是广度优先搜索。想到广度优先搜索自然而然的就能想到图，但是本题并没有直截了当的给出图的模型，因此我们需要把它抽象成图的模型。</p>\n<p>我们可以把每个单词都抽象为一个点，如果两个单词可以只改变一个字母进行转换，那么说明他们之间有一条双向边。因此我们只需要把满足转换条件的点相连，就形成了一张图。</p>\n<p>基于该图，我们以 beginWord 为图的起点，以 endWord 为终点进行广度优先搜索，寻找 beginWord 到 endWord 的最短路径。</p>\n<h4 id=\"算法\"><a class=\"markdownIt-Anchor\" href=\"#算法\">#</a> 算法</h4>\n<p>基于上面的思路我们考虑如何编程实现。</p>\n<p>首先为了方便表示，我们先给每一个单词标号，即给每个单词分配一个 id。创建一个由单词 word 到 id 对应的映射 wordId，并将 beginWord 与 wordList 中所有的单词都加入这个映射中。之后我们检查 endWord 是否在该映射内，若不存在，则输入无解。我们可以使用哈希表实现上面的映射关系。</p>\n<p>然后我们需要建图，依据朴素的思路，我们可以枚举每一对单词的组合，判断它们是否恰好相差一个字符，以判断这两个单词对应的节点是否能够相连。但是这样效率太低，我们可以优化建图。</p>\n<p>具体地，我们可以创建虚拟节点。对于单词 hit，我们创建三个虚拟节点 <em>it、h</em>t、hi*，并让 hit 向这三个虚拟节点分别连一条边即可。如果一个单词能够转化为 hit，那么该单词必然会连接到这三个虚拟节点之一。对于每一个单词，我们枚举它连接到的虚拟节点，把该单词对应的 id 与这些虚拟节点对应的 id 相连即可。</p>\n<p>最后我们将起点加入队列开始广度优先搜索，当搜索到终点时，我们就找到了最短路径的长度。注意因为添加了虚拟节点，所以我们得到的距离为实际最短路径长度的两倍。同时我们并未计算起点对答案的贡献，所以我们应当返回距离的一半再加一的结果。</p>\n<h4 id=\"代码\"><a class=\"markdownIt-Anchor\" href=\"#代码\">#</a> 代码</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    Map&lt;String, Integer&gt; wordId = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;String, Integer&gt;();</span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; edge = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">nodeNum</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">ladderLength</span><span class=\"params\">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String word : wordList) &#123;</span><br><span class=\"line\">            addEdge(word);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        addEdge(beginWord);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!wordId.containsKey(endWord)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] dis = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[nodeNum];</span><br><span class=\"line\">        Arrays.fill(dis, Integer.MAX_VALUE);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">beginId</span> <span class=\"operator\">=</span> wordId.get(beginWord), endId = wordId.get(endWord);</span><br><span class=\"line\">        dis[beginId] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        Queue&lt;Integer&gt; que = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;Integer&gt;();</span><br><span class=\"line\">        que.offer(beginId);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!que.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">x</span> <span class=\"operator\">=</span> que.poll();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (x == endId) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> dis[endId] / <span class=\"number\">2</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> it : edge.get(x)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (dis[it] == Integer.MAX_VALUE) &#123;</span><br><span class=\"line\">                    dis[it] = dis[x] + <span class=\"number\">1</span>;</span><br><span class=\"line\">                    que.offer(it);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">addEdge</span><span class=\"params\">(String word)</span> &#123;</span><br><span class=\"line\">        addWord(word);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">id1</span> <span class=\"operator\">=</span> wordId.get(word);</span><br><span class=\"line\">        <span class=\"type\">char</span>[] array = word.toCharArray();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">length</span> <span class=\"operator\">=</span> array.length;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; length; ++i) &#123;</span><br><span class=\"line\">            <span class=\"type\">char</span> <span class=\"variable\">tmp</span> <span class=\"operator\">=</span> array[i];</span><br><span class=\"line\">            array[i] = <span class=\"string\">&#x27;*&#x27;</span>;</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">newWord</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(array);</span><br><span class=\"line\">            addWord(newWord);</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">id2</span> <span class=\"operator\">=</span> wordId.get(newWord);</span><br><span class=\"line\">            edge.get(id1).add(id2);</span><br><span class=\"line\">            edge.get(id2).add(id1);</span><br><span class=\"line\">            array[i] = tmp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">addWord</span><span class=\"params\">(String word)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!wordId.containsKey(word)) &#123;</span><br><span class=\"line\">            wordId.put(word, nodeNum++);</span><br><span class=\"line\">            edge.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;Integer&gt;());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"复杂度分析\"><a class=\"markdownIt-Anchor\" href=\"#复杂度分析\">#</a> 复杂度分析</h4>\n<ul>\n<li>时间复杂度： <code>O(N×C2)</code> 。其中  N 为 wordList 的长度， C 为列表中单词的长度。</li>\n</ul>\n<p>建图过程中，对于每一个单词，我们需要枚举它连接到的所有虚拟节点，时间复杂度为   <code>O(C)</code> ，将这些单词加入到哈希表中，时间复杂度为  <code>O(N×C)</code> ，因此总时间复杂度为  <code>O(N×C)</code> 。</p>\n<p>广度优先搜索的时间复杂度最坏情况下是 O (N \\times C) O (N×C)。每一个单词需要拓展出 O©O© 个虚拟节点，因此节点数 O (N \\times C) O (N×C)。</p>\n<ul>\n<li>空间复杂度： <code>O(N×C2)</code> 。其中 N 为 wordList 的长度，C 为列表中单词的长度。哈希表中包含  <code>O(N×C)</code>  个节点，每个节点占用空间  <code>O(C)</code> ，因此总的空间复杂度为  <code>O(N×C^2)</code> 。</li>\n</ul>\n","raw":"# 题目描述\n\n字典 wordList 中从单词 beginWord 和 endWord 的 转换序列 是一个按下述规格形成的序列：\n序列中第一个单词是 `beginWord` 。\n序列中最后一个单词是 `endWord`。\n每次转换只能改变一个字母。\n转换过程中的中间单词必须是字典 `wordList` 中的单词。\n给你两个单词 `beginWord` 和 `endWord` 和一个字典 `wordList` ，找到从 `beginWord `到 `endWord` 的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回 `0`。\n\n<!-- more -->\n\n示例 1：\n```plaintext\n输入：beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n输出：5\n解释：一个最短转换序列是 \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\", 返回它的长度 5。\n```\n示例 2：\n\n```plaintext\n输入：beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\n输出：0\n解释：endWord \"cog\" 不在字典中，所以无法进行转换。\n```\n\n提示：\n\n```plaintext\n1 <= beginWord.length <= 10\nendWord.length == beginWord.length\n1 <= wordList.length <= 5000\nwordList[i].length == beginWord.length\nbeginWord、endWord 和 wordList[i] 由小写英文字母组成\nbeginWord != endWord\nwordList 中的所有字符串 互不相同\n```\n\n# 解题\n\n\n### 方法一：广度优先搜索 + 优化建图\n\n#### 思路\n\n本题要求的是最短转换序列的长度，看到最短首先想到的就是广度优先搜索。想到广度优先搜索自然而然的就能想到图，但是本题并没有直截了当的给出图的模型，因此我们需要把它抽象成图的模型。\n\n我们可以把每个单词都抽象为一个点，如果两个单词可以只改变一个字母进行转换，那么说明他们之间有一条双向边。因此我们只需要把满足转换条件的点相连，就形成了一张图。\n\n基于该图，我们以 beginWord 为图的起点，以 endWord 为终点进行广度优先搜索，寻找 beginWord 到 endWord 的最短路径。\n\n#### 算法\n\n基于上面的思路我们考虑如何编程实现。\n\n首先为了方便表示，我们先给每一个单词标号，即给每个单词分配一个 id。创建一个由单词 word 到 id 对应的映射 wordId，并将 beginWord 与 wordList 中所有的单词都加入这个映射中。之后我们检查 endWord 是否在该映射内，若不存在，则输入无解。我们可以使用哈希表实现上面的映射关系。\n\n然后我们需要建图，依据朴素的思路，我们可以枚举每一对单词的组合，判断它们是否恰好相差一个字符，以判断这两个单词对应的节点是否能够相连。但是这样效率太低，我们可以优化建图。\n\n具体地，我们可以创建虚拟节点。对于单词 hit，我们创建三个虚拟节点 *it、h*t、hi*，并让 hit 向这三个虚拟节点分别连一条边即可。如果一个单词能够转化为 hit，那么该单词必然会连接到这三个虚拟节点之一。对于每一个单词，我们枚举它连接到的虚拟节点，把该单词对应的 id 与这些虚拟节点对应的 id 相连即可。\n\n最后我们将起点加入队列开始广度优先搜索，当搜索到终点时，我们就找到了最短路径的长度。注意因为添加了虚拟节点，所以我们得到的距离为实际最短路径长度的两倍。同时我们并未计算起点对答案的贡献，所以我们应当返回距离的一半再加一的结果。\n\n#### 代码\n\n```java\nclass Solution {\n    Map<String, Integer> wordId = new HashMap<String, Integer>();\n    List<List<Integer>> edge = new ArrayList<List<Integer>>();\n    int nodeNum = 0;\n\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        for (String word : wordList) {\n            addEdge(word);\n        }\n        addEdge(beginWord);\n        if (!wordId.containsKey(endWord)) {\n            return 0;\n        }\n        int[] dis = new int[nodeNum];\n        Arrays.fill(dis, Integer.MAX_VALUE);\n        int beginId = wordId.get(beginWord), endId = wordId.get(endWord);\n        dis[beginId] = 0;\n\n        Queue<Integer> que = new LinkedList<Integer>();\n        que.offer(beginId);\n        while (!que.isEmpty()) {\n            int x = que.poll();\n            if (x == endId) {\n                return dis[endId] / 2 + 1;\n            }\n            for (int it : edge.get(x)) {\n                if (dis[it] == Integer.MAX_VALUE) {\n                    dis[it] = dis[x] + 1;\n                    que.offer(it);\n                }\n            }\n        }\n        return 0;\n    }\n\n    public void addEdge(String word) {\n        addWord(word);\n        int id1 = wordId.get(word);\n        char[] array = word.toCharArray();\n        int length = array.length;\n        for (int i = 0; i < length; ++i) {\n            char tmp = array[i];\n            array[i] = '*';\n            String newWord = new String(array);\n            addWord(newWord);\n            int id2 = wordId.get(newWord);\n            edge.get(id1).add(id2);\n            edge.get(id2).add(id1);\n            array[i] = tmp;\n        }\n    }\n\n    public void addWord(String word) {\n        if (!wordId.containsKey(word)) {\n            wordId.put(word, nodeNum++);\n            edge.add(new ArrayList<Integer>());\n        }\n    }\n}\n```\n\n\n\n\n#### 复杂度分析\n\n- 时间复杂度：`O(N×C2)`。其中  N 为 wordList 的长度， C 为列表中单词的长度。\n\n建图过程中，对于每一个单词，我们需要枚举它连接到的所有虚拟节点，时间复杂度为  `O(C)`，将这些单词加入到哈希表中，时间复杂度为 `O(N×C)`，因此总时间复杂度为 `O(N×C)`。\n\n广度优先搜索的时间复杂度最坏情况下是 O(N \\times C)O(N×C)。每一个单词需要拓展出 O(C)O(C) 个虚拟节点，因此节点数 O(N \\times C)O(N×C)。\n\n- 空间复杂度：`O(N×C2)`。其中 N 为 wordList 的长度，C 为列表中单词的长度。哈希表中包含 `O(N×C)` 个节点，每个节点占用空间 `O(C)`，因此总的空间复杂度为 `O(N×C^2)`。","more":"<p>示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class=\"line\">输出：5</span><br><span class=\"line\">解释：一个最短转换序列是 &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;, 返回它的长度 5。</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class=\"line\">输出：0</span><br><span class=\"line\">解释：endWord &quot;cog&quot; 不在字典中，所以无法进行转换。</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 &lt;= beginWord.length &lt;= 10</span><br><span class=\"line\">endWord.length == beginWord.length</span><br><span class=\"line\">1 &lt;= wordList.length &lt;= 5000</span><br><span class=\"line\">wordList[i].length == beginWord.length</span><br><span class=\"line\">beginWord、endWord 和 wordList[i] 由小写英文字母组成</span><br><span class=\"line\">beginWord != endWord</span><br><span class=\"line\">wordList 中的所有字符串 互不相同</span><br></pre></td></tr></table></figure>\n<h1 id=\"解题\"><a class=\"markdownIt-Anchor\" href=\"#解题\">#</a> 解题</h1>\n<h3 id=\"方法一广度优先搜索-优化建图\"><a class=\"markdownIt-Anchor\" href=\"#方法一广度优先搜索-优化建图\">#</a> 方法一：广度优先搜索 + 优化建图</h3>\n<h4 id=\"思路\"><a class=\"markdownIt-Anchor\" href=\"#思路\">#</a> 思路</h4>\n<p>本题要求的是最短转换序列的长度，看到最短首先想到的就是广度优先搜索。想到广度优先搜索自然而然的就能想到图，但是本题并没有直截了当的给出图的模型，因此我们需要把它抽象成图的模型。</p>\n<p>我们可以把每个单词都抽象为一个点，如果两个单词可以只改变一个字母进行转换，那么说明他们之间有一条双向边。因此我们只需要把满足转换条件的点相连，就形成了一张图。</p>\n<p>基于该图，我们以 beginWord 为图的起点，以 endWord 为终点进行广度优先搜索，寻找 beginWord 到 endWord 的最短路径。</p>\n<h4 id=\"算法\"><a class=\"markdownIt-Anchor\" href=\"#算法\">#</a> 算法</h4>\n<p>基于上面的思路我们考虑如何编程实现。</p>\n<p>首先为了方便表示，我们先给每一个单词标号，即给每个单词分配一个 id。创建一个由单词 word 到 id 对应的映射 wordId，并将 beginWord 与 wordList 中所有的单词都加入这个映射中。之后我们检查 endWord 是否在该映射内，若不存在，则输入无解。我们可以使用哈希表实现上面的映射关系。</p>\n<p>然后我们需要建图，依据朴素的思路，我们可以枚举每一对单词的组合，判断它们是否恰好相差一个字符，以判断这两个单词对应的节点是否能够相连。但是这样效率太低，我们可以优化建图。</p>\n<p>具体地，我们可以创建虚拟节点。对于单词 hit，我们创建三个虚拟节点 <em>it、h</em>t、hi*，并让 hit 向这三个虚拟节点分别连一条边即可。如果一个单词能够转化为 hit，那么该单词必然会连接到这三个虚拟节点之一。对于每一个单词，我们枚举它连接到的虚拟节点，把该单词对应的 id 与这些虚拟节点对应的 id 相连即可。</p>\n<p>最后我们将起点加入队列开始广度优先搜索，当搜索到终点时，我们就找到了最短路径的长度。注意因为添加了虚拟节点，所以我们得到的距离为实际最短路径长度的两倍。同时我们并未计算起点对答案的贡献，所以我们应当返回距离的一半再加一的结果。</p>\n<h4 id=\"代码\"><a class=\"markdownIt-Anchor\" href=\"#代码\">#</a> 代码</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    Map&lt;String, Integer&gt; wordId = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;String, Integer&gt;();</span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; edge = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">nodeNum</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">ladderLength</span><span class=\"params\">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String word : wordList) &#123;</span><br><span class=\"line\">            addEdge(word);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        addEdge(beginWord);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!wordId.containsKey(endWord)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] dis = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[nodeNum];</span><br><span class=\"line\">        Arrays.fill(dis, Integer.MAX_VALUE);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">beginId</span> <span class=\"operator\">=</span> wordId.get(beginWord), endId = wordId.get(endWord);</span><br><span class=\"line\">        dis[beginId] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        Queue&lt;Integer&gt; que = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;Integer&gt;();</span><br><span class=\"line\">        que.offer(beginId);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!que.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">x</span> <span class=\"operator\">=</span> que.poll();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (x == endId) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> dis[endId] / <span class=\"number\">2</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> it : edge.get(x)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (dis[it] == Integer.MAX_VALUE) &#123;</span><br><span class=\"line\">                    dis[it] = dis[x] + <span class=\"number\">1</span>;</span><br><span class=\"line\">                    que.offer(it);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">addEdge</span><span class=\"params\">(String word)</span> &#123;</span><br><span class=\"line\">        addWord(word);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">id1</span> <span class=\"operator\">=</span> wordId.get(word);</span><br><span class=\"line\">        <span class=\"type\">char</span>[] array = word.toCharArray();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">length</span> <span class=\"operator\">=</span> array.length;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; length; ++i) &#123;</span><br><span class=\"line\">            <span class=\"type\">char</span> <span class=\"variable\">tmp</span> <span class=\"operator\">=</span> array[i];</span><br><span class=\"line\">            array[i] = <span class=\"string\">&#x27;*&#x27;</span>;</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">newWord</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(array);</span><br><span class=\"line\">            addWord(newWord);</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">id2</span> <span class=\"operator\">=</span> wordId.get(newWord);</span><br><span class=\"line\">            edge.get(id1).add(id2);</span><br><span class=\"line\">            edge.get(id2).add(id1);</span><br><span class=\"line\">            array[i] = tmp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">addWord</span><span class=\"params\">(String word)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!wordId.containsKey(word)) &#123;</span><br><span class=\"line\">            wordId.put(word, nodeNum++);</span><br><span class=\"line\">            edge.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;Integer&gt;());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"复杂度分析\"><a class=\"markdownIt-Anchor\" href=\"#复杂度分析\">#</a> 复杂度分析</h4>\n<ul>\n<li>时间复杂度： <code>O(N×C2)</code> 。其中  N 为 wordList 的长度， C 为列表中单词的长度。</li>\n</ul>\n<p>建图过程中，对于每一个单词，我们需要枚举它连接到的所有虚拟节点，时间复杂度为   <code>O(C)</code> ，将这些单词加入到哈希表中，时间复杂度为  <code>O(N×C)</code> ，因此总时间复杂度为  <code>O(N×C)</code> 。</p>\n<p>广度优先搜索的时间复杂度最坏情况下是 O (N \\times C) O (N×C)。每一个单词需要拓展出 O©O© 个虚拟节点，因此节点数 O (N \\times C) O (N×C)。</p>\n<ul>\n<li>空间复杂度： <code>O(N×C2)</code> 。其中 N 为 wordList 的长度，C 为列表中单词的长度。哈希表中包含  <code>O(N×C)</code>  个节点，每个节点占用空间  <code>O(C)</code> ，因此总的空间复杂度为  <code>O(N×C^2)</code> 。</li>\n</ul>","categories":[{"name":"算法","path":"api/categories/算法.json"}],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"},{"name":"单词接龙","path":"api/tags/单词接龙.json"}]}