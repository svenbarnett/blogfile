{"total":28,"pageSize":10,"pageCount":3,"data":[{"title":"最长回文子串——Leetcode5","slug":"longest-palindromic-substring","date":"2022-01-03T06:28:19.000Z","updated":"2023-02-04T07:54:24.622Z","comments":null,"realpath":null,"path":"api/articles/longest-palindromic-substring.json","excerpt":"# 题目描述给你一个字符串 s，找到 s 中最长的回文子串。","keywords":"回文子串,leetcode5","cover":"/p/dfd6ab93/image-20220103143944443.png","content":"<h1 id=\"题目描述\"><a class=\"anchor\" href=\"#题目描述\">#</a> 题目描述</h1>\n<p>给你一个字符串 s，找到 s 中最长的回文子串。</p>\n<p><span id=\"more\"></span></p>\n<p>示例 1：</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;babad&quot;</span><br><span class=\"line\">输出：&quot;bab&quot;</span><br><span class=\"line\">解释：&quot;aba&quot; 同样是符合题意的答案。</span><br></pre></td></tr></table></figure></p>\n<p>示例 2：</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;cbbd&quot;</span><br><span class=\"line\">输出：&quot;bb&quot;</span><br></pre></td></tr></table></figure></p>\n<p>示例 3：</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;a&quot;</span><br><span class=\"line\">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure></p>\n<p>示例 4：</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;ac&quot;</span><br><span class=\"line\">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure></p>\n<p>提示：</p>\n<p><code>1 &lt;= s.length &lt;= 1000</code> <br>\ns 仅由数字和英文字母（大写和 / 或小写）组成</p>\n<h1 id=\"解题\"><a class=\"anchor\" href=\"#解题\">#</a> 解题</h1>\n<h2 id=\"解题思路\"><a class=\"anchor\" href=\"#解题思路\">#</a> 解题思路</h2>\n<p>对于一个子串而言，如果它是回文串，并且长度大于 22，那么将它首尾的两个字母去除之后，它仍然是个回文串。例如对于字符串 “ababa”，如果我们已经知道 “bab” 是回文串，那么 “ababa” 一定是回文串，这是因为它的首尾两个字母都是 “a”。</p>\n<p>根据这样的思路，我们就可以用动态规划的方法解决本题。我们用  <code>P(i,j) </code> 表示字符串 s 的第 i 到 j 个字母组成的串（下文表示成  <code>s[i:j]</code> ）是否为回文串：如果字符串 s 从 i 到 j 是回文串，那么 <code>P(i,j)= true</code> ，否则为 <code>P(i,j)= true</code> ；</p>\n<p>这里的「否」包含两种可能性：</p>\n<ul>\n<li>\n<p><code>s[i,j]</code>  本身不是一个回文串；</p>\n</li>\n<li>\n<p><code>i&gt;j</code> ，此时  <code>s[i,j]</code>  本身不合法。</p>\n</li>\n</ul>\n<p>那么我们就可以写出动态规划的状态转移方程：</p>\n<p><img src=\"/p/dfd6ab93/image-20220104210656306.png\" alt=\"状态转移方程\"></p>\n<p>也就是说，只有  <code>s[i+1:j−1] </code> 是回文串，并且  <code>s</code>  的第 <code>i</code>  和  <code>j</code>  个字母相同时， <code>s[i:j]</code>  才会是回文串。</p>\n<p>上文的所有讨论是建立在子串长度大于 2 的前提之上的，我们还需要考虑动态规划中的<strong>边界条件</strong>，即子串的长度为 1 或 2。</p>\n<ul>\n<li>\n<p>对于长度为 1 的子串，它显然是个回文串；</p>\n</li>\n<li>\n<p>对于长度为 2 的子串，只要它的两个字母相同，它就是一个回文串。</p>\n</li>\n</ul>\n<p>因此我们就可以写出动态规划的边界条件：</p>\n<p><img src=\"/p/dfd6ab93/image-20220104210730308.png\" alt=\"边界条件\"></p>\n<p>根据这个思路，我们就可以完成动态规划了，最终的答案即为所有 <code> P(i, j) = true</code>  中  <code>j−i+1</code> （即子串长度）的最大值。注意：在状态转移方程中，我们是从长度较短的字符串向长度较长的字符串进行转移的，因此一定要注意动态规划的循环顺序。</p>\n<h2 id=\"代码实现\"><a class=\"anchor\" href=\"#代码实现\">#</a> 代码实现</h2>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">longestPalindrome</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> s.length();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (len &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">maxLen</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">begin</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// dp[i][j] 表示 s[i..j] 是否是回文串</span></span><br><span class=\"line\">        <span class=\"type\">boolean</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">boolean</span>[len][len];</span><br><span class=\"line\">        <span class=\"comment\">// 初始化：所有长度为 1 的子串都是回文串</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">            dp[i][i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">char</span>[] charArray = s.toCharArray();</span><br><span class=\"line\">        <span class=\"comment\">// 递推开始</span></span><br><span class=\"line\">        <span class=\"comment\">// 先枚举子串长度</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">L</span> <span class=\"operator\">=</span> <span class=\"number\">2</span>; L &lt;= len; L++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 枚举左边界，左边界的上限设置可以宽松一些</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得</span></span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> L + i - <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"comment\">// 如果右边界越界，就可以退出当前循环</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (j &gt;= len) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (charArray[i] != charArray[j]) &#123;</span><br><span class=\"line\">                    dp[i][j] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (j - i &lt; <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">                        dp[i][j] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        dp[i][j] = dp[i + <span class=\"number\">1</span>][j - <span class=\"number\">1</span>];</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (dp[i][j] &amp;&amp; j - i + <span class=\"number\">1</span> &gt; maxLen) &#123;</span><br><span class=\"line\">                    maxLen = j - i + <span class=\"number\">1</span>;</span><br><span class=\"line\">                    begin = i;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s.substring(begin, begin + maxLen);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"复杂度分析\"><a class=\"anchor\" href=\"#复杂度分析\">#</a> 复杂度分析</h2>\n<p>时间复杂度： <code>O(n^2) </code> 其中 n 是字符串的长度。动态规划的状态总数为  <code>O(n^2)</code>  对于每个状态，我们需要转移的时间为  <code>O(1)</code> 。</p>\n<p>空间复杂度： <code>O(n^2)</code> ，即存储动态规划状态需要的空间。</p>\n","raw":null,"categories":[{"name":"java","path":"api/categories/java.json"}],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"},{"name":"动态规划","path":"api/tags/动态规划.json"}]},{"title":"linux生产免费的域名证书","slug":"acmesh-cert","date":"2021-12-29T13:59:07.000Z","updated":"2023-02-04T07:54:24.614Z","comments":null,"realpath":null,"path":"api/articles/acmesh-cert.json","excerpt":"简单来说 acme.sh 实现了 acme 协议，可以从 let‘s encrypt 生成免费的证书。<br>acme.sh 有以下特点：<br>一个纯粹用 Shell（Unix shell）语言编写的 ACME 协议客户端。<br>完整的 ACME 协议实施。 支持 ACME v1 和 ACME v2 支持 ACME v2 通配符证书<br>简单，功能强大且易于使用。你只需要 3 分钟就可以学习它。<br>Let's Encrypt 免费证书客户端最简单的 shell 脚本。<br>纯粹用 Shell 编写，不依赖于 python 或官方的 Let's Encrypt 客户端。<br>只需一个脚本即可自动颁发，续订和安装证书。 不需要 root/sudoer 访问权限。<br>支持在 Docker 内使用，支持 IPv6","keywords":"linux,cert,acme.sh","cover":"/p/4425fc35/867078-20190326175923357-720763416.png","content":"<p><a href=\"http://xn--acme-kt0gs67hmo3a2r1a.sh\">简单来说 acme.sh</a> 实现了 acme 协议，可以从 let‘s encrypt 生成免费的证书。<br>\n<a href=\"http://acme.sh\">acme.sh</a> 有以下特点：<br>\n一个纯粹用 Shell（Unix shell）语言编写的 ACME 协议客户端。<br>\n完整的 ACME 协议实施。 支持 ACME v1 和 ACME v2 支持 ACME v2 通配符证书<br>\n简单，功能强大且易于使用。你只需要 3 分钟就可以学习它。<br>\nLet's Encrypt 免费证书客户端最简单的 shell 脚本。<br>\n纯粹用 Shell 编写，不依赖于 python 或官方的 Let's Encrypt 客户端。<br>\n只需一个脚本即可自动颁发，续订和安装证书。 不需要 root/sudoer 访问权限。<br>\n支持在 Docker 内使用，支持 IPv6</p>\n<p><span id=\"more\"></span></p>\n<p><strong>安装环境：</strong><br>\n<strong>操作系统：centos 7 X64</strong><br>\n<strong>SSL 证书来源：Let's Encrypt</strong><br>\n<strong> 安装用脚本：<a href=\"http://acme.sh\">acme.sh</a></strong><br>\n<strong> 服务器：nginx</strong><br>\n<strong> 域名：<a href=\"http://epoint.pswen.cn\">epoint.pswen.cn</a></strong></p>\n<p><a href=\"http://1.xn--acme-ke9g492u.sh\">1. 安装 acme.sh</a></p>\n<p><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl https://get.acme.sh | sh</span><br></pre></td></tr></table></figure></p>\n<p>2. 安装后的配置<br>\n把 <a href=\"http://acme.sh\">acme.sh</a> 安装到你的 home 目录下:~/.acme.sh/ 并创建 一个 bash 的 alias, 方便你的使用:</p>\n<p><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alias acme.sh=~/.acme.sh/acme.sh</span><br><span class=\"line\">echo &#x27;alias acme.sh=~/.acme.sh/acme.sh&#x27; &gt;&gt;/etc/profile</span><br></pre></td></tr></table></figure></p>\n<p>3. 申请证书<br>\n<a href=\"http://acme.sh\"> acme.sh</a> 实现了 acme 协议支持的所有验证协议。一般有两种方式验证: http 和 dns 验证（本文不提供 dns 方式申请，dns 手动模式，不能自动更新证书。在续订证书时，您必须手动向域中添加新的 txt 记录。）</p>\n<p>HTTP 方式方法如下：</p>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">acme.sh --issue -d epoint.pswen.cn --webroot /nginx网站根目录</span><br></pre></td></tr></table></figure></p>\n<p>只需要指定域名，并指定域名所在的网站根目录【命令中根目录路径】. <a href=\"http://acme.sh\">acme.sh</a> 会全自动的生成验证文件，并放到网站的根目录，然后自动完成验证。最后会聪明的删除验证文件。整个过程没有任何副作用.</p>\n<p>4. 证书的安装<br>\n注意，默认生成的证书都放在安装目录下: ~/.acme.sh/, 请不要直接使用此目录下的文件，<br>\n 例如：不要直接让 nginx/apache 的配置文件使用这下面的文件.<br>\n 这里面的文件都是内部使用，而且目录结构可能会变化.</p>\n<p>正确的使用方法是使用 --installcert 命令，并指定目标位置，然后证书文件会被 copy 到相应的位置，</p>\n<p>Nginx 服务： <code>service nginx force-reload</code> 。(centos6)</p>\n<p>Nginx 服务： <code>systemctl restart nginx </code> 。(centos7)</p>\n<p>nginx 示例 1:</p>\n<p><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">acme.sh --installcert -d epoint.pswen.cn --key-file /usr/local/nginx/ssl_cert/epoint.pswen.cn.key --fullchain-file /usr/local/nginx/ssl_cert/epoint.pswen.cn.cer --reloadcmd &quot;service nginx force-reload&quot;</span><br></pre></td></tr></table></figure></p>\n<p>nginx 示例 2：</p>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">acme.sh --install-cert -d chandao.test.com \\</span><br><span class=\"line\">--key-file /usr/local/nginx/ssl_cert/test.com/chandao.test.com.key \\</span><br><span class=\"line\">--fullchain-file /usr/local/nginx/ssl_cert/test.com/chandao.test.com.cer \\</span><br><span class=\"line\">--reloadcmd      <span class=\"string\">&quot;service nginx force-reload&quot;</span></span><br></pre></td></tr></table></figure></p>\n<p>附带完成前面 1-4 步骤的截图：</p>\n<p><img src=\"/p/4425fc35/867078-20190326175923357-720763416.png\" alt=\"img\"></p>\n<ol start=\"5\">\n<li>Nginx 服务器安装 SSL 证书</li>\n</ol>\n<p>Nginx 配置 Http 和 Https 共存</p>\n<p><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">listen 80; #如果硬性要求全部走https协议，这一行去除</span><br><span class=\"line\">listen 443 ssl http2; #如果硬性要求全部走https协议，这里去除ssl</span><br><span class=\"line\">server_name chandao.test.com;</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">ssl on; <span class=\"comment\">#如果硬性要求全部走https协议，这里开启ssl on</span></span></span><br><span class=\"line\">ssl_certificate /usr/local/nginx/ssl_cert/test.com/chandao.test.com.cer;</span><br><span class=\"line\">ssl_certificate_key /usr/local/nginx/ssl_cert/test.com/chandao.test.com.key;</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">ssl性能调优</span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">nginx 1.13.0支持了TLSv1.3,TLSv1.3相比之前的TLSv1.2、TLSv1.1等性能大幅提升</span></span><br><span class=\"line\">ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class=\"line\">ssl_ciphers EECDH+CHACHA20:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5;</span><br><span class=\"line\">ssl_prefer_server_ciphers on;</span><br><span class=\"line\">ssl_session_timeout 10m;</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">使用ssl_session_cache优化https下Nginx的性能</span></span><br><span class=\"line\">ssl_session_cache builtin:1000 shared:SSL:10m;</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">OCSP Stapling 开启。OCSP是用于在线查询证书吊销情况的服务，使用OCSP Stapling能将证书有效状态的信息缓存到服务器，提高 TLS 握手速度</span></span><br><span class=\"line\">ssl_stapling on;</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">OCSP Stapling 验证开启</span></span><br><span class=\"line\">ssl_stapling_verify on; </span><br></pre></td></tr></table></figure></p>\n<p>完整例子：</p>\n<p><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">  listen 80;  #如果硬性要求全部走https协议，这一行去除</span><br><span class=\"line\">  listen       443 ssl http2;    #如果硬性要求全部走https协议，这里去除ssl</span><br><span class=\"line\">  server_name chandao.test.com;</span><br><span class=\"line\">  access_log off;</span><br><span class=\"line\">  index index.html index.htm index.php;</span><br><span class=\"line\">  root /data/wwwroot/chandao;</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">  #</span><span class=\"language-bash\">ssl on;   <span class=\"comment\">#如果硬性要求全部走https协议，这里开启ssl on</span></span></span><br><span class=\"line\">  ssl_certificate   /usr/local/nginx/ssl_cert/test.com/chandao.test.com.cer;</span><br><span class=\"line\">  ssl_certificate_key  /usr/local/nginx/ssl_cert/test.com/chandao.test.com.key;</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">  #</span><span class=\"language-bash\">ssl性能调优</span></span><br><span class=\"line\"><span class=\"meta prompt_\">  #</span><span class=\"language-bash\">nginx 1.13.0支持了TLSv1.3,TLSv1.3相比之前的TLSv1.2、TLSv1.1等性能大幅提升</span></span><br><span class=\"line\">  ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class=\"line\">  ssl_ciphers EECDH+CHACHA20:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5;</span><br><span class=\"line\">  ssl_prefer_server_ciphers on;</span><br><span class=\"line\">  ssl_session_timeout 10m;</span><br><span class=\"line\"><span class=\"meta prompt_\">  #</span><span class=\"language-bash\">使用ssl_session_cache优化https下Nginx的性能</span></span><br><span class=\"line\">  ssl_session_cache builtin:1000 shared:SSL:10m;</span><br><span class=\"line\"><span class=\"meta prompt_\">  #</span><span class=\"language-bash\">OCSP Stapling 开启。OCSP是用于在线查询证书吊销情况的服务，使用OCSP Stapling能将证书有效状态的信息缓存到服务器，提高 TLS 握手速度</span></span><br><span class=\"line\">  ssl_stapling on;</span><br><span class=\"line\"><span class=\"meta prompt_\">  #</span><span class=\"language-bash\">OCSP Stapling 验证开启</span></span><br><span class=\"line\">  ssl_stapling_verify on; </span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">  #</span><span class=\"language-bash\">error_page 404 /404.html;</span></span><br><span class=\"line\"><span class=\"meta prompt_\">  #</span><span class=\"language-bash\">error_page 502 /502.html;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  location ~ [^/]\\.php(/|$) &#123;</span><br><span class=\"line\">    #fastcgi_pass remote_php_ip:9000;</span><br><span class=\"line\">    fastcgi_pass unix:/dev/shm/php-cgi.sock;</span><br><span class=\"line\">    fastcgi_index index.php;</span><br><span class=\"line\">    include fastcgi.conf;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf|flv|mp4|ico)$ &#123;</span><br><span class=\"line\">    expires 30d;</span><br><span class=\"line\">    access_log off;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  location ~ .*\\.(js|css)?$ &#123;</span><br><span class=\"line\">    expires 7d;</span><br><span class=\"line\">    access_log off;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  location ~ /\\.ht &#123;</span><br><span class=\"line\">    deny all;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>6. 重启 nginx<br>\n 保存退出后，通过 nginx -t 来检查配置文件是否正确，有错误的话改之即可。配置文件检测正确之后，通过 service nginx force-reload 来重载配置文件。</p>\n<p><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -t</span><br><span class=\"line\">systemctl restart nginx</span><br></pre></td></tr></table></figure></p>\n","raw":null,"categories":[],"tags":[{"name":"linux","path":"api/tags/linux.json"},{"name":"acmesh","path":"api/tags/acmesh.json"},{"name":"域名证书","path":"api/tags/域名证书.json"}]},{"title":"Java位运算原理及使用讲解","slug":"java-bitewise","date":"2021-12-29T12:02:53.000Z","updated":"2023-02-04T07:54:24.614Z","comments":null,"realpath":null,"path":"api/articles/java-bitewise.json","excerpt":"日常开发中位运算不是很常用，但是巧妙的使用位运算可以大量减少运行开销，优化算法。举个例子，翻转操作比较常见，比如初始值为 1，操作一次变为 0，再操作一次变为 1。可能的做法是使用三木运算符，判断原始值为 1 还是 0，如果是 1，设置为 0，否则设置为 0. 但是使用位运算，不用判断原始值，直接改变值就可以： 1^num  ,num 为原始值。当然，一条语句可能对代码没什么影响，但是在高重复，大数据量的情况下将会节省很多开销。","keywords":"Java,位运算","cover":"/p/7670a0f/Center.png","content":"<p>日常开发中位运算不是很常用，但是巧妙的使用位运算可以大量减少运行开销，优化算法。举个例子，翻转操作比较常见，比如初始值为 1，操作一次变为 0，再操作一次变为 1。可能的做法是使用三木运算符，判断原始值为 1 还是 0，如果是 1，设置为 0，否则设置为 0. 但是使用位运算，不用判断原始值，直接改变值就可以： <code>1^num </code> ,num 为原始值。当然，一条语句可能对代码没什么影响，但是在高重复，大数据量的情况下将会节省很多开销。</p>\n<p><span id=\"more\"></span></p>\n<h1 id=\"1-位运算符\"><a class=\"anchor\" href=\"#1-位运算符\">#</a> 1. 位运算符</h1>\n<h2 id=\"11-java支持的位运算符\"><a class=\"anchor\" href=\"#11-java支持的位运算符\">#</a> 1.1 java 支持的位运算符：</h2>\n<p>&amp;：按位与。</p>\n<p>|：按位或。</p>\n<p>~：按位非。</p>\n<p>^：按位异或。</p>\n<p>&lt;&lt;：左位移运算符。</p>\n<p>&gt;&gt;：右位移运算符。</p>\n<p>&lt;&lt;&lt;：无符号右移运算符。</p>\n<p>位运 算 符 中，除 ～ 以 外，其余 均 为 二 元 运 算 符 。 操 作 数 只 能 为 整 型 和字 符 型 数 据 。</p>\n<p>Java 使用 补 码 来 表 示 二 进 制 数，在补 码 表 示 中，最高 位 为 符号 位，正数 的 符 号 位 为 0, 负数 为 1。补 码 的 规 定 如 下 :</p>\n<p>对 正 数 来 说，最高位为 0, 其余 各 位 代 表 数 值 本 身 (以二 进制 表 示), 如 +42 的补码 为 00101010。</p>\n<p>对 负 数 而 言，把该 数 绝 对 值 的 补 码 按 位 取 反，然后 对 整 个数 加 1, 即得 该 数的 补 码 。 如 -1 的补 码 为 11111111111111111111111111111111 (00000000000000000000000000000001 按 位 取 反 11111111111111111111111111111110+1=11111111111111111111111111111111)。为何有那么多 0、1，java 中 int 是 32 位的。</p>\n<h2 id=\"12-按位与\"><a class=\"anchor\" href=\"#12-按位与\">#</a> 1.2  按位与（&amp;）</h2>\n<p>按位与的运算规则</p>\n<table>\n<thead>\n<tr>\n<th>操作数 1</th>\n<th>0</th>\n<th>0</th>\n<th>1</th>\n<th>1</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>操作数 2</td>\n<td>0</td>\n<td>1</td>\n<td>0</td>\n<td>1</td>\n</tr>\n<tr>\n<td>按位与</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n<p>规则总结：只有两个操作数对应位同为 1 时，结果为 1，其余全为 0. （或者是只要有一个操作数为 0，结果就为 0）。</p>\n<p>举例：</p>\n<p><img src=\"/p/7670a0f/Center.png\" alt=\"img\"></p>\n<p><img src=\"/p/7670a0f/Center-20211229200705116.png\" alt=\"img\"></p>\n<p><img src=\"/p/7670a0f/Center-20211229200704972.png\" alt=\"img\"></p>\n<h2 id=\"13-按位或\"><a class=\"anchor\" href=\"#13-按位或\">#</a> 1.3 按位或（|）</h2>\n<p>按位或的运算规则</p>\n<table>\n<thead>\n<tr>\n<th>操作数 1</th>\n<th>0</th>\n<th>0</th>\n<th>1</th>\n<th>1</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>操作数 2</td>\n<td>0</td>\n<td>1</td>\n<td>0</td>\n<td>1</td>\n</tr>\n<tr>\n<td>按位或</td>\n<td>0</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n<p>规则总结：只有两个操作数对应位同为 0 时，结果为 0，其余全为 1.（或者是只要有一个操作数为 1，结果就为 1）。</p>\n<h2 id=\"14按位非~\"><a class=\"anchor\" href=\"#14按位非~\">#</a> 1.4 按位非（~）</h2>\n<p>按位非的运算规则</p>\n<table>\n<thead>\n<tr>\n<th>操作数</th>\n<th>0</th>\n<th>1</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>按位或</td>\n<td>1</td>\n<td>0</td>\n</tr>\n</tbody>\n</table>\n<p>在求负数的源码中使用过。</p>\n<h2 id=\"15-按位异或\"><a class=\"anchor\" href=\"#15-按位异或\">#</a> 1.5 按位异或（^）</h2>\n<p>按位异或的运算规则</p>\n<table>\n<thead>\n<tr>\n<th>操作数 1</th>\n<th>0</th>\n<th>0</th>\n<th>1</th>\n<th>1</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>操作数 2</td>\n<td>0</td>\n<td>1</td>\n<td>0</td>\n<td>1</td>\n</tr>\n<tr>\n<td>按位异或</td>\n<td>0</td>\n<td>1</td>\n<td>1</td>\n<td>0</td>\n</tr>\n</tbody>\n</table>\n<p>规则总结：异：1.</p>\n<h2 id=\"16-左位移\"><a class=\"anchor\" href=\"#16-左位移\">#</a> 1.6 左位移（&lt;&lt;）</h2>\n<p>算术右移（&gt;&gt;）: 符号位不变，低位补 0。如：2&lt;&lt;2 结果为 8。</p>\n<p><img src=\"/p/7670a0f/Center-20211229200705119.png\" alt=\"img\"></p>\n<p>当移动的位数超过数字本身的位数时，那么不就都需要补 0 操作，实际上不是的，java 不可能做那么浪费资源的事情。在真正执行位移前，其对要移动的位数做了一些预处理，比如 32 处理为 0，-1 处理为 31.</p>\n<h2 id=\"17-右位移\"><a class=\"anchor\" href=\"#17-右位移\">#</a> 1.7 右位移（&gt;&gt;）</h2>\n<p>低位溢出，符号位不变，并用符号位补溢出的高位。如：-6&gt;&gt;2 结果为 - 2。</p>\n<p><img src=\"/p/7670a0f/Center-20211229200705083.png\" alt=\"img\"></p>\n<h2 id=\"18-无符号右移\"><a class=\"anchor\" href=\"#18-无符号右移\">#</a> 1.8 无符号右移（&gt;&gt;&gt;）</h2>\n<p>低位溢出，高位补 0。注意，无符号右移（&gt;&gt;&gt;）中的符号位（最高位）也跟着变，无符号的意思是将符号位当作数字位看待。如：-1&gt;&gt;&gt;1 结果为 2147483647。这个数字应该比较熟悉，看两个输出语句就知道是什么了：</p>\n<p><code>System.out.println(Integer.toBinaryString(-1&gt;&gt;&gt;1));</code></p>\n<p><code>System.out.println(Integer.toBinaryString(Integer.MAX_VALUE));</code></p>\n<p>输出结果为：</p>\n<p>1111111111111111111111111111111</p>\n<p>1111111111111111111111111111111</p>\n<p>-1&gt;&gt;&gt;1 竟然得到了 int 所能表示的最大整数，精彩。</p>\n<p><img src=\"/p/7670a0f/Center-20211229200704949.png\" alt=\"img\"></p>\n<p>除了使用 - 1&gt;&gt;&gt;1 能得到 Integer.MAX_VALUE，以下的也能得到同样的结果：</p>\n<p>​    //maxInt</p>\n<p>​    System.<em>out</em>.println(~(1 &lt;&lt; 31));</p>\n<p>​    System.<em>out</em>.println((1 &lt;&lt; -1)-1);</p>\n<p>​    System.<em>out</em>.println(~(1 &lt;&lt; -1));</p>\n<p>使用位运算往往能很巧妙的实现某些算法完成一些复杂的功能。</p>\n<h1 id=\"常见使用\"><a class=\"anchor\" href=\"#常见使用\">#</a> 常见使用</h1>\n<h2 id=\"1-m2n\"><a class=\"anchor\" href=\"#1-m2n\">#</a> 1.   m*2^n</h2>\n<p>可以使用 m&lt;&lt;n 求得结果，如：</p>\n<p>​    System.<em>out</em>.println(&quot;2^3=&quot; + (1&lt;&lt;3));//2^3=8</p>\n<p>​    System.<em>out</em>.println(&quot;3<em>2^3=&quot; + (3&lt;&lt;3));//3</em>2^3=24</p>\n<p>计算结果是不是很正确呢？如果非要说 2&lt;&lt;-1 为什么不等于 0.5，前面说过，位运算的操作数只能是整型和字符型。在求 int 所能表示的最小值时，可以使用</p>\n<p>//minInt</p>\n<p>System.<em>out</em>.println(1 &lt;&lt; 31);</p>\n<p>System.<em>out</em>.println(1 &lt;&lt; -1);</p>\n<p>可以发现左移 31 位和 - 1 位所得的结果是一样的，同理，左移 30 位和左移 - 2 所得的结果也是一样的。移动一个负数位，是不是等同于右移该负数的绝对值位呢？输出一下就能发现不是的。java 中 int 所能表示的最大数值是 31 位，加上符号位共 32 位。在这里可以有这样的位移法则：</p>\n<p>法则一：任何数左移（右移）32 的倍数位等于该数本身。</p>\n<p>法则二：在位移运算 m&lt;&lt;n 的计算中，若 n 为正数，则实际移动的位数为 n%32，若 n 为负数，则实际移动的位数为 (32+n%32)，右移，同理。</p>\n<p>左移是乘以 2 的幂，对应着右移则是除以 2 的幂。</p>\n<h2 id=\"2-判断一个数n的奇偶性\"><a class=\"anchor\" href=\"#2-判断一个数n的奇偶性\">#</a> 2.   判断一个数 n 的奇偶性</h2>\n<p>n&amp;1 == 1?” 奇数”:” 偶数”</p>\n<p>为什么与 1 能判断奇偶？所谓的二进制就是满 2 进 1，那么好了，偶数的最低位肯定是 0（恰好满 2，对不对？），同理，奇数的最低位肯定是 1.int 类型的 1，前 31 位都是 0，无论是 1&amp;0 还是 0&amp;0 结果都是 0，那么有区别的就是 1 的最低位上的 1 了，若 n 的二进制最低位是 1（奇数）与上 1，结果为 1，反则结果为 0.</p>\n<h2 id=\"3-不用临时变量交换两个数\"><a class=\"anchor\" href=\"#3-不用临时变量交换两个数\">#</a> 3.   不用临时变量交换两个数</h2>\n<p>在 int [] 数组首尾互换中，是不看到过这样的代码：</p>\n<p><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> </span><br></pre></td></tr></table></figure></p>\n<ol>\n<li><code>public static int[] reverse(int[] nums)&#123;</code></li>\n<li><code>int i = 0;</code></li>\n<li><code>int j = nums.length-1;</code></li>\n<li><code>while(j&gt;i)&#123;</code></li>\n<li><code>nums[i]= nums[i]^nums[j];</code></li>\n<li><code>nums[j] = nums[j]^nums[i];</code></li>\n<li><code>nums[i] = nums[i]^nums[j];</code></li>\n<li><code>j--;</code></li>\n<li><code>i++;</code></li>\n<li><code>&#125;</code></li>\n<li><code>return nums;</code></li>\n<li><code>&#125;</code></li>\n</ol>\n<p>连续三次使用异或，并没有临时变量就完成了两个数字交换，怎么实现的呢？</p>\n<p><img src=\"/p/7670a0f/Center-20211229200705072.png\" alt=\"img\"></p>\n<p>上面的计算主要遵循了一个计算公式：b<sup>(a</sup>b)=a。</p>\n<p>我们可以对以上公式做如下的推导：</p>\n<p>任何数异或本身结果为 0. 且有定理 a<sup>b=b</sup>a。异或是一个无顺序的运算符，则 b<sup>a</sup>b=b<sup>b</sup>a，结果为 0^a。</p>\n<p>再次列出异或的计算表:</p>\n<table>\n<thead>\n<tr>\n<th>操作数 1</th>\n<th>0</th>\n<th>0</th>\n<th>1</th>\n<th>1</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>操作数 2</td>\n<td>0</td>\n<td>1</td>\n<td>0</td>\n<td>1</td>\n</tr>\n<tr>\n<td>按位异或</td>\n<td>0</td>\n<td>1</td>\n<td>1</td>\n<td>0</td>\n</tr>\n</tbody>\n</table>\n<p>可以发现，异或 0 具有保持的特点，而异或 1 具有翻转的特点。使用这些特点可以进行取数的操作。</p>\n<p>​     那么 0^a，使用异或 0 具有保持的特点，最终结果就是 a。</p>\n<p>其实 java 中的异或运算法则完全遵守数学中的计算法则：</p>\n<p>①  a ^ a =0</p>\n<p>②  a ^ b =b ^ a</p>\n<p>③  a ^b ^ c = a ^ (b ^ c) = (a ^ b) ^ c;</p>\n<p>④  d = a ^b ^ c 可以推出 a = d ^ b ^ c.</p>\n<p>⑤  a ^ b ^a = b.</p>\n<h2 id=\"4-取绝对值\"><a class=\"anchor\" href=\"#4-取绝对值\">#</a> 4.   取绝对值</h2>\n<p>(a^(a&gt;&gt;31))-(a&gt;&gt;31)</p>\n<p>先整理一下使用位运算取绝对值的思路：若 a 为正数，则不变，需要用异或 0 保持的特点；若 a 为负数，则其补码为源码翻转每一位后 + 1，先求其源码，补码 - 1 后再翻转每一位，此时需要使用异或 1 具有翻转的特点。</p>\n<p>任何正数右移 31 后只剩符号位 0，最终结果为 0，任何负数右移 31 后也只剩符号位 1，溢出的 31 位截断，空出的 31 位补符号位 1，最终结果为 - 1. 右移 31 操作可以取得任何整数的符号位。</p>\n<p>那么综合上面的步骤，可得到公式。a&gt;&gt;31 取得 a 的符号，若 a 为正数，a&gt;&gt;31 等于 0，a^0=a，不变；若 a 为负数，a&gt;&gt;31 等于 - 1 ，a^-1 翻转每一位.</p>\n","raw":null,"categories":[],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"位运算","path":"api/tags/位运算.json"}]},{"title":"夜中云谷","slug":"sz-tiananyungu","date":"2021-12-18T13:06:30.000Z","updated":"2023-02-04T07:54:24.678Z","comments":null,"realpath":null,"path":"api/articles/sz-tiananyungu.json","excerpt":null,"keywords":"深圳,天安云谷","cover":"/p/b10a7a0e/IMG_0119.jpg","content":"<p><img src=\"/p/b10a7a0e/IMG_0119.jpg\" alt=\"IMG_0119\"></p>\n","raw":null,"categories":[],"tags":[{"name":"夜景","path":"api/tags/夜景.json"},{"name":"图记","path":"api/tags/图记.json"},{"name":"天安云谷","path":"api/tags/天安云谷.json"}]},{"title":"gulp-imagemin在压缩图片","slug":"gulp-imagemin-use","date":"2021-11-16T14:35:58.000Z","updated":"2023-02-04T07:54:24.614Z","comments":null,"realpath":null,"path":"api/articles/gulp-imagemin-use.json","excerpt":"经过各种研（bai）究（du），找到了一种方案：采用 gulp + gulp-imagemin ，对图片进行压缩，结合 hexo 进行对应图片压缩。<br>","keywords":"gulp-imagemin,压缩图片,gulp","cover":"/p/1009bbf4/ppp","content":"<p>经过各种研（bai）究（du），找到了一种方案：采用 <code>gulp + gulp-imagemin</code> ，对图片进行压缩，结合 hexo 进行对应图片压缩。<br>\n<span id=\"more\"></span></p>\n<h3 id=\"安装\"><a class=\"anchor\" href=\"#安装\">#</a> 安装</h3>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install gulp --save-dev</span><br><span class=\"line\">npm install gulp-imagemin --save-dev</span><br><span class=\"line\">npm install imagemin-pngquant --save-dev</span><br><span class=\"line\"><span class=\"comment\"># 当然也可以--save  记得要给gulp全局安装下，npm命令不行，就是用cnpm</span></span><br><span class=\"line\">npm install gulp -g <span class=\"comment\"># 只有gulp要全局安装下</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"gulpfile\"><a class=\"anchor\" href=\"#gulpfile\">#</a> gulpfile</h3>\n<p>在 package.json 同名目录下，增加 gulpfile.js 对应的入口 js 文件</p>\n<p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> gulp <span class=\"keyword\">from</span> <span class=\"string\">&#x27;gulp&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> imagemin <span class=\"keyword\">from</span> <span class=\"string\">&#x27;gulp-imagemin&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> pngquant <span class=\"keyword\">from</span> <span class=\"string\">&#x27;imagemin-pngquant&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义一个任务 第一个参数为名称，后面时要执行的动作</span></span><br><span class=\"line\">gulp.<span class=\"title function_\">task</span>(<span class=\"string\">&#x27;minify-images&#x27;</span>, <span class=\"keyword\">function</span> (<span class=\"params\">done</span>) &#123;</span><br><span class=\"line\">    gulp.<span class=\"title function_\">src</span>(<span class=\"string\">&#x27;public/p/**/*.&#123;JPG,jpg,PNG,png,GIF,gif,SVG,svg,JPEG,jpeg&#125;&#x27;</span>)</span><br><span class=\"line\">\t\t.<span class=\"title function_\">pipe</span>(<span class=\"title function_\">imagemin</span>(&#123;</span><br><span class=\"line\">\t\t\t<span class=\"attr\">optimizationLevel</span>: <span class=\"number\">3</span>,</span><br><span class=\"line\">\t\t\t<span class=\"attr\">progressive</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">\t\t\t<span class=\"attr\">usa</span>:[<span class=\"title function_\">pngquant</span>()]</span><br><span class=\"line\">\t\t&#125;))</span><br><span class=\"line\">\t\t.<span class=\"title function_\">pipe</span>(gulp.<span class=\"title function_\">dest</span>(<span class=\"string\">&#x27;public/p/&#x27;</span>))</span><br><span class=\"line\">    <span class=\"title function_\">done</span>();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 定义default ，后面将多个任务序列化并行执行，我们只有一个</span></span><br><span class=\"line\">gulp.<span class=\"title function_\">task</span>(<span class=\"string\">&#x27;default&#x27;</span>, gulp.<span class=\"title function_\">series</span>(gulp.<span class=\"title function_\">parallel</span>(<span class=\"string\">&#x27;minify-images&#x27;</span>)), <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">info</span>(<span class=\"string\">&quot;----------gulp Finished----------&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>执行命令 <code>gulp</code>  默认情况下，代表 <code>gulp default</code>  就执行你上面的 default 任务</p>\n<p>当然你也可以制定任务名称： <code>gulp minify-images</code>  执行指定 task</p>\n<p>然后再 hexo 状态下：</p>\n<p><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean </span><br><span class=\"line\">hexo g</span><br><span class=\"line\">gulp</span><br><span class=\"line\"><span class=\"comment\"># 输出如下：</span></span><br><span class=\"line\">[22:46:42] Using gulpfile ~/Desktop/blogfile/gulpfile.js</span><br><span class=\"line\">[22:46:42] Starting <span class=\"string\">&#x27;default&#x27;</span>...</span><br><span class=\"line\">[22:46:42] Starting <span class=\"string\">&#x27;minify-images&#x27;</span>...</span><br><span class=\"line\">[22:46:42] Finished <span class=\"string\">&#x27;minify-images&#x27;</span> after 74 ms</span><br><span class=\"line\">[22:46:42] Finished <span class=\"string\">&#x27;default&#x27;</span> after 99 ms</span><br></pre></td></tr></table></figure></p>\n<p>那说明成功了</p>\n<h3 id=\"遇到的坑\"><a class=\"anchor\" href=\"#遇到的坑\">#</a> 遇到的坑</h3>\n<ul>\n<li>引入语法问题，插件需要使用 es6 语法，故此你的 package.json 需要增加一个参数 <code>  &quot;type&quot;: &quot;module&quot;</code>  如此你可以再 gulpfile.js 中使用 es6 的 import 语法</li>\n</ul>\n","raw":null,"categories":[],"tags":[{"name":"gulp","path":"api/tags/gulp.json"},{"name":"压缩图片","path":"api/tags/压缩图片.json"},{"name":"gulp-imagemin","path":"api/tags/gulp-imagemin.json"}]},{"title":"图记——今日午餐","slug":"today-life-lunach","date":"2021-11-14T04:29:41.000Z","updated":"2023-02-04T07:54:24.686Z","comments":null,"realpath":null,"path":"api/articles/today-life-lunach.json","excerpt":null,"keywords":"生活,午餐","cover":"/p/dbbc4a4a/IMG_0073.JPG","content":"<p><img src=\"/p/dbbc4a4a/IMG_0073.JPG\" alt=\"今日午餐\"></p>\n","raw":null,"categories":[],"tags":[{"name":"图记","path":"api/tags/图记.json"},{"name":"生活","path":"api/tags/生活.json"},{"name":"午餐","path":"api/tags/午餐.json"}]},{"title":"虚拟机类加载机制-类加载时机","slug":"jvm-classload","date":"2021-11-12T14:55:27.000Z","updated":"2023-02-04T07:54:24.618Z","comments":null,"realpath":null,"path":"api/articles/jvm-classload.json","excerpt":"在 Java 语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略虽然会令类加载时稍微增加一些性能开销，但是会为 Java 应用程序提供高度的灵活性，Java 里天生可以动态扩展的语言特性就是依赖于运行期动态加载和动态连接这个特点实现的。","keywords":"jvm,虚拟机,类加载,类加载时机","cover":"/p/8239/20160719124551909.jpeg","content":"<p>在 Java 语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略虽然会令类加载时稍微增加一些性能开销，但是会为 Java 应用程序提供高度的灵活性，Java 里天生可以动态扩展的语言特性就是依赖于运行期动态加载和动态连接这个特点实现的。</p>\n<p><span id=\"more\"></span></p>\n<p>例如，如果编写一个面向接口的应用程序，可以等到运行时再指定其实际的实现类；用户可以通过 Java 预定义的和自定义类加载器，让一个本地的应用程序可以在运行时从网络或其他地方加载一个二进制流作为程序代码的一部分，这种组装应用程序的方式目前已广泛应用于 Java 程序之中。从最基础的 Applet、JSP 到相对复杂的 OSGI 技术，都使用了 Java 语言运行期类加载的特性。</p>\n<h2 id=\"类加载机制\"><a class=\"anchor\" href=\"#类加载机制\">#</a> 类加载机制</h2>\n<p>生命周期：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialzation）、使用（Using）和卸载（Unloading）7 个阶段。</p>\n<p><img src=\"/p/8239/20160719124551909.jpeg\" alt=\"生命周期\"></p>\n<p>什么情况下需要开始进行类加载过程的第一阶段呢？没有明确约束，虚拟机自由把握；</p>\n<p>而初始化阶段有严格规范，以下五种情况必须理解对类进行初始化。</p>\n<ol>\n<li>遇到 new（new 关键词实例化），getstatic（读取类的 static 字段），putstatic（设置类的 static 字段，被 final 修饰、已在编译期就把结果放入了常量池的字段除外），invokestatic（调用一个类的静态方法）</li>\n<li>使用 <code>java.lang.reflect</code>  包的方法对类进行反射调用</li>\n<li>初始化一个类，会先初始化它的父类</li>\n<li>虚拟机启动时，会先初始化执行的主类（main 方法）</li>\n<li>JDK1.7 的 <code>java.lang.invoke.MethodHandle</code>  的方法去获取句柄</li>\n</ol>\n<p><em><strong>有且仅有</strong></em>这五种情况，除此之外都是被动引用，不会触发初始化，举 3 个例子</p>\n<ul>\n<li>对于静态字段，只有定义这个字段的类才会被初始化，例如父类定义的静态字段，通过子类去使用父类的静态字段，那么只有父类会初始化，子类不会</li>\n<li>数组类型定义使用时，类似 <code>SubClass[]</code>  不会进行初始化</li>\n<li>被 finla 修饰的静态字段，会进行常量传播优化，实际上这个字段已经和这个类没啥关系了</li>\n</ul>\n<p>初始化第三种情况下，对于接口有个特例情况：一个类初始化时要求父类全部初始化，而接口，不要求其父接口全部都完成初始化，只有在使用到才会初始化。</p>\n","raw":null,"categories":[],"tags":[{"name":"jvm","path":"api/tags/jvm.json"},{"name":"类加载","path":"api/tags/类加载.json"}]},{"title":"环形链表——LeetCode141","slug":"linked-list-cycle","date":"2021-11-12T13:17:10.000Z","updated":"2023-02-04T07:54:24.618Z","comments":null,"realpath":null,"path":"api/articles/linked-list-cycle.json","excerpt":"给定一个链表，判断链表中是否有环。如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。<br>如果链表中存在环，则返回 true 。 否则，返回 false 。<br>LeetCode-141 链接：https://leetcode-cn.com/problems/linked-list-cycle","keywords":"环形链表,快慢指针","cover":"/p/1426/circularlinkedlist.png","content":"<p>给定一个链表，判断链表中是否有环。</p>\n<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。<br>\n如果链表中存在环，则返回 true 。 否则，返回 false 。<br>\nLeetCode-141 链接：<a href=\"https://leetcode-cn.com/problems/linked-list-cycle\">https://leetcode-cn.com/problems/linked-list-cycle</a></p>\n<p><span id=\"more\"></span></p>\n<p>示例 1：</p>\n<p><img src=\"/p/1426/circularlinkedlist.png\" alt=\"环形链表-示例1\"></p>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：<span class=\"built_in\">head</span> = [3,2,0,-4], pos = 1</span><br><span class=\"line\">输出：<span class=\"literal\">true</span></span><br><span class=\"line\">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure></p>\n<p>示例 2：</p>\n<p><img src=\"/p/1426/circularlinkedlist_test2.png\" alt=\"环形链表-示例2\"></p>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：<span class=\"built_in\">head</span> = [1,2], pos = 0</span><br><span class=\"line\">输出：<span class=\"literal\">true</span></span><br><span class=\"line\">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure></p>\n<p>示例 3：</p>\n<p><img src=\"/p/1426/circularlinkedlist_test3.png\" alt=\"环形链表-示例3\"></p>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：<span class=\"built_in\">head</span> = [1], pos = -1</span><br><span class=\"line\">输出：<span class=\"literal\">false</span></span><br><span class=\"line\">解释：链表中没有环。</span><br></pre></td></tr></table></figure></p>\n<p>提示：</p>\n<p><figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">链表中节点的数目范围是 <span class=\"literal\">[<span class=\"number\">0</span>, <span class=\"number\">104</span>]</span></span><br><span class=\"line\">-<span class=\"number\">105</span> &lt;= <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Node</span>.</span></span><span class=\"keyword\">val</span> &lt;= <span class=\"number\">105</span></span><br><span class=\"line\">pos 为 -<span class=\"number\">1</span> 或者链表中的一个 有效索引 。</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"解题\"><a class=\"anchor\" href=\"#解题\">#</a> 解题</h3>\n<ol>\n<li>Hash 表</li>\n</ol>\n<p>最容易想到的方法是遍历所有节点，每次遍历到一个节点时，判断该节点此前是否被访问过。</p>\n<p>具体地，我们可以使用哈希表来存储所有已经访问过的节点。每次我们到达一个节点，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。重复这一过程，直到我们遍历完整个链表即可。</p>\n<p>代码实现：</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">hasCycle</span><span class=\"params\">(ListNode head)</span> &#123;</span><br><span class=\"line\">        Set&lt;ListNode&gt; seen = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;ListNode&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (head != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!seen.add(head)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            head = head.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>复杂度分析</p>\n<p>时间复杂度： <code>O(N)</code> ，其中  <code>N </code> 是链表中的节点数。最坏情况下我们需要遍历每个节点一次。<br>\n空间复杂度： <code>O(N)</code> ，其中 <code>N </code> 是链表中的节点数。主要为哈希表的开销，最坏情况下我们需要将每个节点插入到哈希表中一次。</p>\n<ol start=\"2\">\n<li>快慢指针</li>\n</ol>\n<p>方法需要读者对「Floyd 判圈算法」（又称龟兔赛跑算法）有所了解。</p>\n<p>假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。</p>\n<p>我们可以根据上述思路来解决本题。具体地，我们定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。</p>\n<p><img src=\"/p/1426/2.png\" alt=\"龟兔赛跑\"></p>\n<blockquote>\n<p>为什么我们要规定初始时慢指针在位置 head，快指针在位置 head.next，而不是两个指针都在位置 head（即与「乌龟」和「兔子」中的叙述相同）？</p>\n</blockquote>\n<ul>\n<li>观察下面的代码，我们使用的是 while 循环，循环条件先于循环体。由于循环条件一定是判断快慢指针是否重合，如果我们将两个指针初始都置于 head，那么 while 循环就不会执行。因此，我们可以假想一个在 head 之前的虚拟节点，慢指针从虚拟节点移动一步到达 head，快指针从虚拟节点移动两步到达 head.next，这样我们就可以使用 while 循环了。</li>\n<li>当然，我们也可以使用 do-while 循环。此时，我们就可以把快慢指针的初始值都置为 head。</li>\n</ul>\n<p>代码实现：</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">hasCycle</span><span class=\"params\">(ListNode head)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head == <span class=\"literal\">null</span> || head.next == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">slow</span> <span class=\"operator\">=</span> head;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">fast</span> <span class=\"operator\">=</span> head.next;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (slow != fast) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (fast == <span class=\"literal\">null</span> || fast.next == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            slow = slow.next;</span><br><span class=\"line\">            fast = fast.next.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>复杂度分析</p>\n<p>时间复杂度： <code>O(N)</code> ，其中  <code>N</code>  是链表中的节点数。<br>\n当链表中不存在环时，快指针将先于慢指针到达链表尾部，链表中每个节点至多被访问两次。<br>\n当链表中存在环时，每一轮移动后，快慢指针的距离将减小一。而初始距离为环的长度，因此至多移动<br>\n <code>N</code>  轮。<br>\n空间复杂度： <code>O(1)</code> 。我们只使用了两个指针的额外空间。</p>\n","raw":null,"categories":[],"tags":[{"name":"算法","path":"api/tags/算法.json"},{"name":"快慢指针","path":"api/tags/快慢指针.json"},{"name":"环形链表","path":"api/tags/环形链表.json"}]},{"title":"寻找重复数——LeetCode287","slug":"find-the-duplicate-number","date":"2021-11-11T13:02:11.000Z","updated":"2023-02-04T07:54:24.614Z","comments":null,"realpath":null,"path":"api/articles/find-the-duplicate-number.json","excerpt":"给定一个包含 n + 1 个整数的数组 nums ，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。<br>假设 nums 只有 一个重复的整数 ，找出 这个重复的数 。<br>你设计的解决方案必须不修改数组 nums 且只用常量级 O (1) 的额外空间。<br>Leetcode-287 链接：https://leetcode-cn.com/problems/find-the-duplicate-number<br>","keywords":"寻找重复数,二分法,算法,leetcode","cover":"","content":"<p>给定一个包含 n + 1 个整数的数组 nums ，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。<br>\n假设 nums 只有 一个重复的整数 ，找出 这个重复的数 。<br>\n你设计的解决方案必须不修改数组 nums 且只用常量级 O (1) 的额外空间。<br>\nLeetcode-287 链接：<a href=\"https://leetcode-cn.com/problems/find-the-duplicate-number\">https://leetcode-cn.com/problems/find-the-duplicate-number</a><br>\n<span id=\"more\"></span><br>\n 示例 1：<br>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,3,4,2,2]</span><br><span class=\"line\">输出：2</span><br></pre></td></tr></table></figure></p>\n<p>示例 2：<br>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [3,1,3,4,2]</span><br><span class=\"line\">输出：3</span><br></pre></td></tr></table></figure></p>\n<p>示例 3：<br>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,1]</span><br><span class=\"line\">输出：1</span><br></pre></td></tr></table></figure></p>\n<p>示例 4：<br>\n<figure class=\"highlight fix\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">输入：nums </span>=<span class=\"string\"> [1,1,2]</span></span><br><span class=\"line\"><span class=\"string\">输出：1</span></span><br></pre></td></tr></table></figure></p>\n<p>提示：<br>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 &lt;= n &lt;= 105</span><br><span class=\"line\">nums.length == n + 1</span><br><span class=\"line\">1 &lt;= nums[i] &lt;= n</span><br></pre></td></tr></table></figure><br>\nnums 中 只有一个整数 出现 两次或多次 ，其余整数均只出现 一次</p>\n<h3 id=\"解题\"><a class=\"anchor\" href=\"#解题\">#</a> 解题</h3>\n<ol>\n<li>二分法</li>\n</ol>\n<p>针对用例 <code>[1,3,4,2,2]</code></p>\n<p>定义一个 <code>cnt</code>  数组用来存储小于等于 索引  <code>i</code>  的总数</p>\n<p>如果知道 cnt 数组随数字 index 逐渐增大具有单调性，那么当 num [index] 那么我们就可以直接利用二分查找来找到重复的数</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">nums</th>\n<th style=\"text-align:center\">1</th>\n<th style=\"text-align:center\">2</th>\n<th style=\"text-align:center\">3</th>\n<th style=\"text-align:center\">4</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">cnt</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">5</td>\n</tr>\n</tbody>\n</table>\n<p>小于等于 1 的一个</p>\n<p>小于等于 2 的三个</p>\n<p>小于等于 3 的四个</p>\n<p>小于等于 4 的五个</p>\n<p>由此可见：我们的目标是 2，target 满足: target 前面的  <code>cnt[i] &lt;=  i</code> , 目标值 target 之后的  <code>cnt[i] &gt; i</code></p>\n<p>实际上可以归纳为：</p>\n<ul>\n<li>\n<p>如果测试用例的数组中  <code>target</code>  出现了两次，其余的数各出现了一次，这个时候肯定满足上文提及的性质，因为小于  <code>target</code>  的数 i 满足  <code>cnt[i]=i</code> ，大于等于  <code>target</code>  的数  <code>j</code>  满足  <code>cnt[j]=j+1</code> 。</p>\n</li>\n<li>\n<p>如果测试用例的数组中 <code>target </code> 出现了三次及以上，那么必然有一些数不在  <code>nums</code>  数组中了，这个时候相当于我们用 <code>target</code>  去替换了这些数，我们考虑替换的时候对 <code>cnt[] </code> 数组的影响。如果替换的数 <code>i</code>  小于  <code>target</code>  ，那么在数 <code>i</code>  到 <code>target</code>  区间的值，均减一，其他不变，满足条件。如果替换的数  <code>j</code>  大于等于  <code>target</code> ，那么 <code>target</code>  到 数 <code>j</code>  区间内值均加一，其他不变，亦满足条件。</p>\n</li>\n</ul>\n<p>因此不管多个重复还是两个重复，数组都满足那个性质。</p>\n<p>代码实现：</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">findDuplicate</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> nums.length;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">l</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>, r = n - <span class=\"number\">1</span>, ans = -<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (l &lt;= r) &#123;</span><br><span class=\"line\">           # 右移动一位，相关于除以<span class=\"number\">2</span>，取中间值</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">mid</span> <span class=\"operator\">=</span> (l + r) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">cnt</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">              # 将小于等于中间值都加起来  </span><br><span class=\"line\">              <span class=\"keyword\">if</span> (nums[i] &lt;= mid) &#123;</span><br><span class=\"line\">                    cnt++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">           # 如果此时的cnt总数小于等于mid，那说明不在mid左边</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cnt &lt;= mid) &#123;</span><br><span class=\"line\">               # 把左边拉到中间</span><br><span class=\"line\">                l = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                # 否则把右边拉到中间</span><br><span class=\"line\">                r = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">                # 记录答案</span><br><span class=\"line\">                ans = mid;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>复杂度分析</p>\n<p>时间复杂度： <code>O(n * logn)</code> ，其中 n 为 nums 数组的长度。二分查找最多需要二分 <code>O(logn) </code> 次，每次判断的时候需要 <code>O(n)</code>  遍历 nums 数组求解小于等于 mid 的数的个数，因此总时间复杂度为 <code>O(n * logn)</code> 。</p>\n<p>空间复杂度： <code>O(1)</code> 。我们只需要常数空间存放若干变量。</p>\n<ol start=\"2\">\n<li>快慢指针</li>\n</ol>\n<p>我们对 nums 数组建图，每个位置  <code>i</code>  连一条  <code>i→nums[i]</code>  的边。由于存在的重复的数字<br>\n <code>target</code>  因此  <code>target </code> 这个位置一定有起码两条指向它的边，因此整张图一定存在环，且我们要找到的<br>\n <code>target</code>  就是这个环的入口.</p>\n<p>我们先设置慢指针 <code>slow 和快指针</code>   <code>fast</code>  ，慢指针每次走一步，快指针每次走两步，根据「Floyd 判圈算法」两个指针在有环的情况下一定会相遇，此时我们再将  <code>slow</code>  放置起点 <code>0</code> ，两个指针每次同时移动一步，相遇的点就是答案。</p>\n<p>代码实现：</p>\n<p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">findDuplicate</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">slow</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, fast = <span class=\"number\">0</span>;</span><br><span class=\"line\">      \t# 找环的入口</span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            slow = nums[slow];</span><br><span class=\"line\">            fast = nums[nums[fast]];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> (slow != fast);</span><br><span class=\"line\">        # 重置slow为起点</span><br><span class=\"line\">        slow = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (slow != fast) &#123;</span><br><span class=\"line\">            slow = nums[slow];</span><br><span class=\"line\">            fast = nums[fast];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        # 再次相遇 就是环入口</span><br><span class=\"line\">        <span class=\"keyword\">return</span> slow;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>复杂度分析</p>\n<p>时间复杂度： <code>O(n)</code> 。「Floyd 判圈算法」时间复杂度为线性的时间复杂度。<br>\n空间复杂度： <code>O(1)</code> 。我们只需要常数空间存放若干变量。</p>\n","raw":null,"categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"},{"name":"二分法","path":"api/tags/二分法.json"},{"name":"快慢指针","path":"api/tags/快慢指针.json"}]},{"title":"图记——晚霞的尾巴","slug":"pic-shenzhen-1","date":"2021-08-27T10:50:09.000Z","updated":"2023-02-04T07:54:24.666Z","comments":null,"realpath":null,"path":"api/articles/pic-shenzhen-1.json","excerpt":null,"keywords":"晚霞,天安云谷","cover":"/p/4ee64d66/IMG_0027.jpg","content":"<p><img src=\"/p/4ee64d66/IMG_0027.jpg\" alt=\"晚霞的尾巴\"></p>\n","raw":null,"categories":[],"tags":[{"name":"晚霞","path":"api/tags/晚霞.json"},{"name":"云谷","path":"api/tags/云谷.json"}]}]}