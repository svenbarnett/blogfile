{"total":36,"pageSize":10,"pageCount":4,"data":[{"title":"JVM调优——X参数,方法内联","slug":"jvm-params","date":"2022-01-12T15:06:08.000Z","updated":"2023-04-30T03:57:46.427Z","comments":null,"realpath":null,"path":"api/articles/jvm-params.json","excerpt":"JVM 的 -X  参数是非标准参数，在不同版本的 JVM 中，参数可能会有所不同，可以通过 java -X  查看非标准参数","keywords":"jvm调优,mixed,混合,xint,解释,comp,纯编译,方法内联","cover":"/p/638c83fa/logo","content":"<html><head></head><body><p>JVM 的 <code>-X</code>  参数是非标准参数，在不同版本的 JVM 中，参数可能会有所不同，可以通过 <code>java -X</code>  查看非标准参数</p>\n<span id=\"more\"></span>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; java -X</span><br><span class=\"line\"></span><br><span class=\"line\">    -Xbatch           禁用后台编译</span><br><span class=\"line\">    -Xbootclasspath/a:&lt;以 : 分隔的目录和 zip/jar 文件&gt;</span><br><span class=\"line\">                      附加在引导类路径末尾</span><br><span class=\"line\">    -Xcheck:jni       对 JNI 函数执行其他检查</span><br><span class=\"line\">    -Xcomp            强制在首次调用时编译方法</span><br><span class=\"line\">    -Xdebug           不执行任何操作。为实现向后兼容而提供。</span><br><span class=\"line\">    -Xdiag            显示附加诊断消息</span><br><span class=\"line\">    -Xfuture          启用最严格的检查，预期将来的默认值。</span><br><span class=\"line\">                      此选项已过时，可能会在</span><br><span class=\"line\">                      未来发行版中删除。</span><br><span class=\"line\">    -Xint             仅解释模式执行</span><br><span class=\"line\">    -Xinternalversion</span><br><span class=\"line\">                      显示比 -version 选项更详细的</span><br><span class=\"line\">                      JVM 版本信息</span><br><span class=\"line\">    -Xlog:&lt;opts&gt;      配置或启用采用 Java 虚拟</span><br><span class=\"line\">                      机 (Java Virtual Machine, JVM) 统一记录框架进行事件记录。使用 -Xlog:help</span><br><span class=\"line\">                      可了解详细信息。</span><br><span class=\"line\">    -Xloggc:&lt;file&gt;    将 GC 状态记录在文件中（带时间戳）。</span><br><span class=\"line\">                      此选项已过时，可能会在</span><br><span class=\"line\">                      将来的发行版中删除。它将替换为 -Xlog:gc:&lt;file&gt;。</span><br><span class=\"line\">    -Xmixed           混合模式执行（默认值）</span><br><span class=\"line\">    -Xmn&lt;size&gt;        为年轻代（新生代）设置初始和最大堆大小</span><br><span class=\"line\">                      （以字节为单位）</span><br><span class=\"line\">    -Xms&lt;size&gt;        设置初始 Java 堆大小</span><br><span class=\"line\">    -Xmx&lt;size&gt;        设置最大 Java 堆大小</span><br><span class=\"line\">    -Xnoclassgc       禁用类垃圾收集</span><br><span class=\"line\">    -Xrs              减少 Java/VM 对操作系统信号的使用（请参见文档）</span><br><span class=\"line\">    -Xshare:auto      在可能的情况下使用共享类数据（默认值）</span><br><span class=\"line\">    -Xshare:off       不尝试使用共享类数据</span><br><span class=\"line\">    -Xshare:on        要求使用共享类数据，否则将失败。</span><br><span class=\"line\">                      这是一个测试选项，可能导致间歇性</span><br><span class=\"line\">                      故障。不应在生产环境中使用它。</span><br><span class=\"line\">    -XshowSettings    显示所有设置并继续</span><br><span class=\"line\">    -XshowSettings:all</span><br><span class=\"line\">                      显示所有设置并继续</span><br><span class=\"line\">    -XshowSettings:locale</span><br><span class=\"line\">                      显示所有与区域设置相关的设置并继续</span><br><span class=\"line\">    -XshowSettings:properties</span><br><span class=\"line\">                      显示所有属性设置并继续</span><br><span class=\"line\">    -XshowSettings:vm</span><br><span class=\"line\">                      显示所有与 vm 相关的设置并继续</span><br><span class=\"line\">    -XshowSettings:system</span><br><span class=\"line\">                      （仅 Linux）显示主机系统或容器</span><br><span class=\"line\">                      配置并继续</span><br><span class=\"line\">    -Xss&lt;size&gt;        设置 Java 线程堆栈大小</span><br><span class=\"line\">    -Xverify          设置字节码验证器的模式</span><br><span class=\"line\">                      请注意，选项 -Xverify:none 已过时，</span><br><span class=\"line\">                      可能会在未来发行版中删除。</span><br><span class=\"line\">    --add-reads &lt;module&gt;=&lt;target-module&gt;(,&lt;target-module&gt;)*</span><br><span class=\"line\">                      更新 &lt;module&gt; 以读取 &lt;target-module&gt;，而无论</span><br><span class=\"line\">                      模块如何声明。</span><br><span class=\"line\">                      &lt;target-module&gt; 可以是 ALL-UNNAMED，将读取所有未命名</span><br><span class=\"line\">                      模块。</span><br><span class=\"line\">    --add-exports &lt;module&gt;/&lt;package&gt;=&lt;target-module&gt;(,&lt;target-module&gt;)*</span><br><span class=\"line\">                      更新 &lt;module&gt; 以将 &lt;package&gt; 导出到 &lt;target-module&gt;，</span><br><span class=\"line\">                      而无论模块如何声明。</span><br><span class=\"line\">                      &lt;target-module&gt; 可以是 ALL-UNNAMED，将导出到所有</span><br><span class=\"line\">                      未命名模块。</span><br><span class=\"line\">    --add-opens &lt;module&gt;/&lt;package&gt;=&lt;target-module&gt;(,&lt;target-module&gt;)*</span><br><span class=\"line\">                      更新 &lt;module&gt; 以在 &lt;target-module&gt; 中打开</span><br><span class=\"line\">                      &lt;package&gt;，而无论模块如何声明。</span><br><span class=\"line\">    --illegal-access=&lt;value&gt;</span><br><span class=\"line\">                      允许或拒绝通过未命名模块中的代码对命名模块中的</span><br><span class=\"line\">                      类型成员进行访问。</span><br><span class=\"line\">                      &lt;value&gt; 为 \"deny\"、\"permit\"、\"warn\" 或 \"debug\" 之一</span><br><span class=\"line\">                      此选项将在未来发行版中删除。</span><br><span class=\"line\">    --limit-modules &lt;module name&gt;[,&lt;module name&gt;...]</span><br><span class=\"line\">                      限制可观察模块的领域</span><br><span class=\"line\">    --patch-module &lt;module&gt;=&lt;file&gt;(:&lt;file&gt;)*</span><br><span class=\"line\">                      使用 JAR 文件或目录中的类和资源</span><br><span class=\"line\">                      覆盖或增强模块。</span><br><span class=\"line\">    --source &lt;version&gt;</span><br><span class=\"line\">                      设置源文件模式中源的版本。</span><br><span class=\"line\"></span><br><span class=\"line\">这些额外选项如有更改, 恕不另行通知。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">以下选项是特定于 macOS 的选项：</span><br><span class=\"line\">    -XstartOnFirstThread</span><br><span class=\"line\">                      在第一个 (AppKit) 线程上运行 main() 方法</span><br><span class=\"line\">    -Xdock:name=&lt;application name&gt;</span><br><span class=\"line\">                      覆盖停靠栏中显示的默认应用程序名称</span><br><span class=\"line\">    -Xdock:icon=&lt;path to icon file&gt;</span><br><span class=\"line\">                     覆盖停靠栏中显示的默认图标</span><br></pre></td></tr></tbody></table></figure></div>\n<h2 id=\"-xint-xcomp与-xmixed参数\"><a class=\"markdownIt-Anchor\" href=\"#-xint-xcomp与-xmixed参数\">#</a> -Xint、-Xcomp 与 - Xmixed 参数</h2>\n<h3 id=\"-xint参数\"><a class=\"markdownIt-Anchor\" href=\"#-xint参数\">#</a> -Xint 参数</h3>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在解释模式（interpreted mode）下，-Xint标记会强制JVM执行所有的字节码，这当然会降低运行速度，通常低10倍或更多。</span><br></pre></td></tr></tbody></table></figure></div>\n<p><img src=\"/p/638c83fa/index.html20190729122640228.png\" alt=\"interpreted-mode\"></p>\n<h3 id=\"-xcomp参数\"><a class=\"markdownIt-Anchor\" href=\"#-xcomp参数\">#</a> -Xcomp 参数</h3>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Xcomp参数与-Xint正好相反，JVM在第一次使用时会把所有的字节码编译成本地代码，从而带来最大程度的优化。</span><br></pre></td></tr></tbody></table></figure></div>\n<p><img src=\"/p/638c83fa/index.html20190729122919297.png\" alt=\"compiled-mode\"></p>\n<p>然而，很多应用在使用 - Xcomp 也会有一些性能损失，当然这笔 - Xint 损失的少，原因是 - Xcomp 没有让 JVM 启用 JIT 编译器的全部功能。JIT 编译器可以对是否需要编译做出判断。如果所有代码都需要进行编译的话，对于一些只执行一次的代码就没有意义了。</p>\n<h3 id=\"-xmixed参数\"><a class=\"markdownIt-Anchor\" href=\"#-xmixed参数\">#</a> -Xmixed 参数</h3>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Xmixed是混合模式，将解释模式和变异模式进行混合使用，有JVM自己决定，这是JVM的默认模式，也是推荐模式</span><br></pre></td></tr></tbody></table></figure></div>\n<p><img src=\"/p/638c83fa/index.html2019072913573773.png\" alt=\"mixed-model\"></p>\n<h2 id=\"jvm方法内联优化\"><a class=\"markdownIt-Anchor\" href=\"#jvm方法内联优化\">#</a> JVM 方法内联优化</h2>\n<h3 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\">#</a> 前言</h3>\n<p>在日常中工作中，我们时不时会代码进行一些优化，比如用新的算法，简化计算逻辑，减少计算量等。对于 java 程序来说，除了开发者本身对代码优化之外，还有一个 \"人\" 也在背后默默的优化我们的代码，这个 \"人\" 就是 jvm。jvm 会帮我们分析出热点代码，优化代码逻辑。其中 jvm 最常做的优化之一就是：方法内联优化。</p>\n<h3 id=\"方法内联\"><a class=\"markdownIt-Anchor\" href=\"#方法内联\">#</a> 方法内联</h3>\n<p>什么是方法内联？又可以叫做函数内联，java 中方法可等同于其它语言中的函数。关于方法内联维基百科上面解释是：</p>\n<blockquote>\n<p>在计算机科学中，内联函数（有时称作在线函数或编译时期展开函数）是一种编程语言结构，用来建议编译器对一些特殊函数进行内联扩展（有时称作在线扩展）；也就是说<strong>建议编译器将指定的函数体插入并取代每一处调用该函数的地方（上下文），从而节省了每次调用函数带来的额外时间开支。</strong></p>\n</blockquote>\n<p>简单通俗的讲就是把方法内部调用的其它方法的逻辑，嵌入到自身的方法中去，变成自身的一部分，之后不再调用该方法，从而节省调用函数带来的额外开支。</p>\n<h3 id=\"函数调用开销\"><a class=\"markdownIt-Anchor\" href=\"#函数调用开销\">#</a> 函数调用开销</h3>\n<p>之所以出现方法内联是因为函数调用除了执行自身逻辑的开销外，还有一些不为人知的额外开销。这部分额外的开销主要来自方法栈帧的生成、参数字段的压入、栈帧的弹出、还有指令执行地址的跳转。比如有下面这样代码：</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"JAVA\"><figure class=\"iseeu highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">function_A</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span>{</span><br><span class=\"line\">    <span class=\"comment\">//do something</span></span><br><span class=\"line\">    function_B(a,b);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">function_B</span><span class=\"params\">(<span class=\"type\">int</span> c, <span class=\"type\">int</span> d)</span>{</span><br><span class=\"line\">    <span class=\"comment\">//do something</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span>{</span><br><span class=\"line\">     function_A(<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure></div>\n<p>则代码的执行过程如下：</p>\n<p><img src=\"/p/638c83fa/index.html247487dfbaf1ec956441e9e5e2f85817_1440w.jpg\" alt=\"img\"></p>\n<p>所以如果 java 中方法调用嵌套过多或者方法过多，这种额外的开销就越多。</p>\n<p>试想一下想 get/set 这种方法调用：</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"JAVA\"><figure class=\"iseeu highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getI</span><span class=\"params\">()</span> {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setI</span><span class=\"params\">(<span class=\"type\">int</span> i)</span> {</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.i = i;</span><br><span class=\"line\">} </span><br></pre></td></tr></tbody></table></figure></div>\n<p>很可能自身执行逻辑的开销还比不上为了调用这个方法的额外开锁。如果类似的方法被频繁的调用，则真正相对执行效率就会很低，虽然这类方法的执行时间很短。这也是为什么 jvm 会在热点代码中执行方法内联的原因，这样的话就可以省去调用调用函数带来的额外开支。</p>\n<p>这里举个内联的可能形式：</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"JAVA\"><figure class=\"iseeu highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span>  <span class=\"title function_\">add</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b , <span class=\"type\">int</span> c, <span class=\"type\">int</span> d)</span>{</span><br><span class=\"line\">      <span class=\"keyword\">return</span> add(a, b) + add(c, d);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">add</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure></div>\n<p>内联之后：</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"JAVA\"><figure class=\"iseeu highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span>  <span class=\"title function_\">add</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b , <span class=\"type\">int</span> c, <span class=\"type\">int</span> d)</span>{</span><br><span class=\"line\">      <span class=\"keyword\">return</span> a + b + c + d;</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure></div>\n<p>这样除了本身的相加逻辑的开销，比内联前减少了二次调用函数带来的额外开销。</p>\n<h3 id=\"内联条件\"><a class=\"markdownIt-Anchor\" href=\"#内联条件\">#</a> 内联条件</h3>\n<p>一个方法如果满足以下条件就很可能被 jvm 内联。</p>\n<p>1、热点代码： 如果一个方法的执行频率很高就表示优化的潜在价值就越大。那代码执行多少次才能确定为热点代码？这是根据编译器的编译模式来决定的。如果是客户端编译模式则次数是 1500，服务端编译模式是 10000。次数的大小可以通过 - XX:CompileThreshold 来调整。</p>\n<p>2、方法体不能太大：jvm 中被内联的方法会编译成机器码放在 code cache 中。如果方法体太大，则能缓存热点方法就少，反而会影响性能。</p>\n<p>3、如果希望方法被内联，尽量用 private、static、final 修饰，这样 jvm 可以直接内联。如果是 public、protected 修饰方法 jvm 则需要进行类型判断，因为这些方法可以被子类继承和覆盖，jvm 需要判断内联究竟内联是父类还是其中某个子类的方法。</p>\n<blockquote>\n<p>所以了解 jvm 方法内联机制之后，会有助于我们工作中写出能让 jvm 更容易优化的代码，有助于提升程序的性能。</p>\n</blockquote>\n</body></html>","raw":null,"categories":[{"name":"java","path":"api/categories/java.json"}],"tags":[{"name":"jvm调优","path":"api/tags/jvm调优.json"},{"name":"混合模式","path":"api/tags/混合模式.json"},{"name":"解释模式","path":"api/tags/解释模式.json"},{"name":"纯编译模式","path":"api/tags/纯编译模式.json"}]},{"title":"巧妙使用正则——去除小数点后多余的零","slug":"js-regexp","date":"2022-01-10T13:51:44.000Z","updated":"2023-04-30T03:57:46.427Z","comments":null,"realpath":null,"path":"api/articles/js-regexp.json","excerpt":"直接上代码1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>const arr=['1200.00100','1200.00000','1200.','1200','1200.10000','0.120010000','0.000011111']<br>const regexp=/(?:\\.0*|(\\.\\d+?)0+)$/<br>arr.forEach((item)=&gt;{<br>    console.log(item.replace(regexp,'$1'))<br>})<br><br>// &gt; 1200.001<br>// &gt; 1200<br>// &gt; 1200<br>// &gt; 1200<br>// &gt; 1200.1<br>// &gt; 0.12001<br>// &gt; 0.000011111<br>","keywords":"正则,js,去除零","cover":"/p/9195a466/image.svg","content":"<html><head></head><body><p>直接上代码</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"JSX\"><figure class=\"iseeu highlight jsx\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr=[<span class=\"string\">'1200.00100'</span>,<span class=\"string\">'1200.00000'</span>,<span class=\"string\">'1200.'</span>,<span class=\"string\">'1200'</span>,<span class=\"string\">'1200.10000'</span>,<span class=\"string\">'0.120010000'</span>,<span class=\"string\">'0.000011111'</span>]</span><br><span class=\"line\"><span class=\"keyword\">const</span> regexp=<span class=\"regexp\">/(?:\\.0*|(\\.\\d+?)0+)$/</span></span><br><span class=\"line\">arr.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">item</span>)=&gt;</span>{</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(item.<span class=\"title function_\">replace</span>(regexp,<span class=\"string\">'$1'</span>))</span><br><span class=\"line\">})</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// &gt; 1200.001</span></span><br><span class=\"line\"><span class=\"comment\">// &gt; 1200</span></span><br><span class=\"line\"><span class=\"comment\">// &gt; 1200</span></span><br><span class=\"line\"><span class=\"comment\">// &gt; 1200</span></span><br><span class=\"line\"><span class=\"comment\">// &gt; 1200.1</span></span><br><span class=\"line\"><span class=\"comment\">// &gt; 0.12001</span></span><br><span class=\"line\"><span class=\"comment\">// &gt; 0.000011111</span></span><br></pre></td></tr></tbody></table></figure></div>\n<span id=\"more\"></span>\n<p>正则可视化：</p>\n<p><img src=\"/p/9195a466/index.htmlimage.svg\" alt=\"image\"></p>\n<p>推荐个可视化网址：<a href=\"https://regexper.com/\">https://regexper.com/</a></p>\n<!-- more -->\n<p>再解释下正则的意思 <code>(?:.0*|(.\\d+?)0+)$</code></p>\n<p>先分解成 4 部分</p>\n<ol>\n<li><code>(?:reg1|reg2)</code>  - 它是一个正则分组非捕获组，要么匹配 reg1，要么匹配 reg2，优先匹配 reg1，加上？: 不对捕获组记录</li>\n<li><code>.0*</code>  - 表示匹配一个。开头，后边跟着 0 或 0 个以上数量的 0，且不进行捕获，所以在填充 $1 时，就是个空值</li>\n<li><code>(.\\d+?)0+</code>  - 它是一个捕获组，匹配一个。开头后边跟着非贪婪（懒惰）匹配任意数字，接着在末尾尽可能多的匹配 0 这个字符，匹配完成后，生成一个捕获组内容</li>\n<li><code>$</code>  - 表示匹配结果需要以 0 作为结尾</li>\n</ol>\n<h2 id=\"正则分组\"><a class=\"markdownIt-Anchor\" href=\"#正则分组\">#</a> 正则分组</h2>\n<ul>\n<li>\n<p>普通捕获组</p>\n<p>从正则表达式左侧开始，每出现一个左括号 \"(\" 记做一个分组，分组编号从 1 开始。0 代表整个表达式。</p>\n<p>对于时间字符串：2017-04-25，表达式如下</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"JS\"><figure class=\"iseeu highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(\\\\d{<span class=\"number\">4</span>})-((\\\\d{<span class=\"number\">2</span>})-(\\\\d{<span class=\"number\">2</span>}))</span><br></pre></td></tr></tbody></table></figure></div>\n<p>有 4 个左括号，所以有 4 个分组:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">编号</th>\n<th style=\"text-align:left\">捕获组</th>\n<th style=\"text-align:left\">匹配</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">0</td>\n<td style=\"text-align:left\">(\\d{4})-((\\d{2})-(\\d{2}))</td>\n<td style=\"text-align:left\">2017-04-25</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">(\\d{4})</td>\n<td style=\"text-align:left\">2017</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">((\\d{2})-(\\d{2}))</td>\n<td style=\"text-align:left\">04-25</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">3</td>\n<td style=\"text-align:left\">(\\d{2})</td>\n<td style=\"text-align:left\">04</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">4</td>\n<td style=\"text-align:left\">(\\d{2})</td>\n<td style=\"text-align:left\">25</td>\n</tr>\n</tbody>\n</table>\n</li>\n<li>\n<p>命名捕获组</p>\n<p>每个以左括号开始的捕获组，都紧跟着 <strong>?</strong>，而后才是正则表达式。</p>\n<p>对于时间字符串：2017-04-25，表达式如下:</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"JS\"><figure class=\"iseeu highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(?&lt;year&gt;\\\\d{<span class=\"number\">4</span>})-(?&lt;md&gt;(?&lt;month&gt;\\\\d{<span class=\"number\">2</span>})-(?&lt;date&gt;\\\\d{<span class=\"number\">2</span>}))</span><br></pre></td></tr></tbody></table></figure></div>\n<p>有 4 个命名的捕获组，分别是:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">编号</th>\n<th style=\"text-align:left\">名称</th>\n<th style=\"text-align:left\">捕获组</th>\n<th style=\"text-align:left\">匹配</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">0</td>\n<td style=\"text-align:left\">0</td>\n<td style=\"text-align:left\">(?\\d{4})-(?(?\\d{2})-(?\\d{2}))</td>\n<td style=\"text-align:left\">2017-04-25</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">year</td>\n<td style=\"text-align:left\">(?\\d{4})-</td>\n<td style=\"text-align:left\">2017</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">md</td>\n<td style=\"text-align:left\">(?(?\\d{2})-(?\\d{2}))</td>\n<td style=\"text-align:left\">04-25</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">3</td>\n<td style=\"text-align:left\">month</td>\n<td style=\"text-align:left\">(?\\d{2})</td>\n<td style=\"text-align:left\">04</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">4</td>\n<td style=\"text-align:left\">date</td>\n<td style=\"text-align:left\">(?\\d{2})</td>\n<td style=\"text-align:left\">25</td>\n</tr>\n</tbody>\n</table>\n<p>命名的捕获组同样也可以使用编号获取相应值。</p>\n</li>\n</ul>\n<h2 id=\"非捕获组\"><a class=\"markdownIt-Anchor\" href=\"#非捕获组\">#</a> 非捕获组</h2>\n<p>在左括号后紧跟  <code>?:</code> ，而后再加上正则表达式，构成非捕获组 <strong>(?:Expression)</strong>。</p>\n<p>对于时间字符串：2017-04-25，表达式如下:</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"JS\"><figure class=\"iseeu highlight js\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(?:\\\\d{<span class=\"number\">4</span>})-((\\\\d{<span class=\"number\">2</span>})-(\\\\d{<span class=\"number\">2</span>}))</span><br></pre></td></tr></tbody></table></figure></div>\n<p>这个正则表达式虽然有四个左括号，理论上有 4 个捕获组。但是第一组 <strong>(?:\\d{4})</strong>，其实是被忽略的。当使用 matcher.group (4) 时，系统会报错。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">编号</th>\n<th style=\"text-align:left\">捕获组</th>\n<th style=\"text-align:left\">匹配</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">0</td>\n<td style=\"text-align:left\">(\\d{4})-((\\d{2})-(\\d{2}))</td>\n<td style=\"text-align:left\">2017-04-25</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">((\\d{2})-(\\d{2}))</td>\n<td style=\"text-align:left\">04-25</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">(\\d{2})</td>\n<td style=\"text-align:left\">04</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">3</td>\n<td style=\"text-align:left\">(\\d{2})</td>\n<td style=\"text-align:left\">25</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"非贪婪懒惰匹配\"><a class=\"markdownIt-Anchor\" href=\"#非贪婪懒惰匹配\">#</a> 非贪婪 (懒惰) 匹配</h2>\n<p>** 贪婪匹配:** 正则表达式一般趋向于最大长度匹配，也就是所谓的贪婪匹配。如上面使用模式 p 匹配字符串 str，结果就是匹配到：<strong>abcaxc</strong>(ab*c)。</p>\n<p><strong>非贪婪匹配</strong>：就是匹配到结果就好，就少的匹配字符。如上面使用模式 p 匹配字符串 str，结果就是匹配到：<strong>abc</strong>(ab*c)。</p>\n<p>问号可以表示重复前面内容的 0 次或一次，也就是要么不出现，要么出现一次</p>\n<p>示例 1：</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"JAVA\"><figure class=\"iseeu highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">string</span> <span class=\"variable\">pattern1</span> <span class=\"operator\">=</span> @<span class=\"string\">\"a.*?c\"</span>;   <span class=\"comment\">// non-greedy match </span></span><br><span class=\"line\"><span class=\"type\">Regex</span> <span class=\"variable\">regex</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Regex</span>(pattern1);</span><br><span class=\"line\">regex.Match(<span class=\"string\">\"abcabc\"</span>); <span class=\"comment\">// return \"abc\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">## 结果：abc</span><br></pre></td></tr></tbody></table></figure></div>\n<p>示例 2：</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"PYTHON\"><figure class=\"iseeu highlight python\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\">s=<span class=\"string\">'hello 1234567 world'</span></span><br><span class=\"line\">res = re.<span class=\"keyword\">match</span>(<span class=\"string\">'he.*?(\\d).*rld$'</span>,s)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(res.group(<span class=\"number\">1</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 结果：123456</span></span><br></pre></td></tr></tbody></table></figure></div>\n<p>常用非贪婪表达式</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*? 重复任意次，但尽可能少重复</span><br><span class=\"line\">+? 重复1次或更多次，但尽可能少重复</span><br><span class=\"line\">?? 重复0次或1次，但尽可能少重复</span><br><span class=\"line\">{n,m}? 重复n到m次，但尽可能少重复</span><br><span class=\"line\">{n,}? 重复n次以上，但尽可能少重复</span><br></pre></td></tr></tbody></table></figure></div></body></html>","raw":null,"categories":[{"name":"前端","path":"api/categories/前端.json"}],"tags":[{"name":"正则","path":"api/tags/正则.json"},{"name":"js","path":"api/tags/js.json"},{"name":"去除零","path":"api/tags/去除零.json"}]},{"title":"单词接龙——leetcode127","slug":"word-ladder","date":"2022-01-09T10:38:08.000Z","updated":"2023-04-30T03:57:46.503Z","comments":null,"realpath":null,"path":"api/articles/word-ladder.json","excerpt":"# 题目描述字典&nbsp;wordList 中从单词 beginWord&nbsp;和 endWord 的 转换序列 是一个按下述规格形成的序列：<br>序列中第一个单词是  beginWord  。<br>序列中最后一个单词是  endWord 。<br>每次转换只能改变一个字母。<br>转换过程中的中间单词必须是字典&nbsp; wordList  中的单词。<br>给你两个单词  beginWord &nbsp;和  endWord  和一个字典  wordList  ，找到从&nbsp; beginWord  到&nbsp; endWord  的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回  0 。","keywords":"算法,leetcode,单词接龙","cover":"/p/fbb9fe6d/leetcode127.png","content":"<html><head></head><body><h1 id=\"题目描述\"><a class=\"markdownIt-Anchor\" href=\"#题目描述\">#</a> 题目描述</h1>\n<p>字典&nbsp;wordList 中从单词 beginWord&nbsp;和 endWord 的 转换序列 是一个按下述规格形成的序列：<br>\n序列中第一个单词是  <code>beginWord</code>  。<br>\n序列中最后一个单词是  <code>endWord</code> 。<br>\n每次转换只能改变一个字母。<br>\n转换过程中的中间单词必须是字典&nbsp; <code>wordList</code>  中的单词。<br>\n给你两个单词  <code>beginWord</code> &nbsp;和  <code>endWord</code>  和一个字典  <code>wordList</code>  ，找到从&nbsp; <code>beginWord </code> 到&nbsp; <code>endWord</code>  的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回  <code>0</code> 。</p>\n<span id=\"more\"></span>\n<p>示例 1：</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]</span><br><span class=\"line\">输出：5</span><br><span class=\"line\">解释：一个最短转换序列是 \"hit\" -&gt; \"hot\" -&gt; \"dot\" -&gt; \"dog\" -&gt; \"cog\", 返回它的长度 5。</span><br></pre></td></tr></tbody></table></figure></div>\n<p>示例 2：</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]</span><br><span class=\"line\">输出：0</span><br><span class=\"line\">解释：endWord \"cog\" 不在字典中，所以无法进行转换。</span><br></pre></td></tr></tbody></table></figure></div>\n<p>提示：</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 &lt;= beginWord.length &lt;= 10</span><br><span class=\"line\">endWord.length == beginWord.length</span><br><span class=\"line\">1 &lt;= wordList.length &lt;= 5000</span><br><span class=\"line\">wordList[i].length == beginWord.length</span><br><span class=\"line\">beginWord、endWord 和 wordList[i] 由小写英文字母组成</span><br><span class=\"line\">beginWord != endWord</span><br><span class=\"line\">wordList 中的所有字符串 互不相同</span><br></pre></td></tr></tbody></table></figure></div>\n<h1 id=\"解题\"><a class=\"markdownIt-Anchor\" href=\"#解题\">#</a> 解题</h1>\n<h3 id=\"方法一广度优先搜索-优化建图\"><a class=\"markdownIt-Anchor\" href=\"#方法一广度优先搜索-优化建图\">#</a> 方法一：广度优先搜索 + 优化建图</h3>\n<h4 id=\"思路\"><a class=\"markdownIt-Anchor\" href=\"#思路\">#</a> 思路</h4>\n<p>本题要求的是最短转换序列的长度，看到最短首先想到的就是广度优先搜索。想到广度优先搜索自然而然的就能想到图，但是本题并没有直截了当的给出图的模型，因此我们需要把它抽象成图的模型。</p>\n<p>我们可以把每个单词都抽象为一个点，如果两个单词可以只改变一个字母进行转换，那么说明他们之间有一条双向边。因此我们只需要把满足转换条件的点相连，就形成了一张图。</p>\n<p>基于该图，我们以 beginWord 为图的起点，以 endWord 为终点进行广度优先搜索，寻找 beginWord 到 endWord 的最短路径。</p>\n<h4 id=\"算法\"><a class=\"markdownIt-Anchor\" href=\"#算法\">#</a> 算法</h4>\n<p>基于上面的思路我们考虑如何编程实现。</p>\n<p>首先为了方便表示，我们先给每一个单词标号，即给每个单词分配一个 id。创建一个由单词 word 到 id 对应的映射 wordId，并将 beginWord 与 wordList 中所有的单词都加入这个映射中。之后我们检查 endWord 是否在该映射内，若不存在，则输入无解。我们可以使用哈希表实现上面的映射关系。</p>\n<p>然后我们需要建图，依据朴素的思路，我们可以枚举每一对单词的组合，判断它们是否恰好相差一个字符，以判断这两个单词对应的节点是否能够相连。但是这样效率太低，我们可以优化建图。</p>\n<p>具体地，我们可以创建虚拟节点。对于单词 hit，我们创建三个虚拟节点 <em>it、h</em>t、hi*，并让 hit 向这三个虚拟节点分别连一条边即可。如果一个单词能够转化为 hit，那么该单词必然会连接到这三个虚拟节点之一。对于每一个单词，我们枚举它连接到的虚拟节点，把该单词对应的 id 与这些虚拟节点对应的 id 相连即可。</p>\n<p>最后我们将起点加入队列开始广度优先搜索，当搜索到终点时，我们就找到了最短路径的长度。注意因为添加了虚拟节点，所以我们得到的距离为实际最短路径长度的两倍。同时我们并未计算起点对答案的贡献，所以我们应当返回距离的一半再加一的结果。</p>\n<h4 id=\"代码\"><a class=\"markdownIt-Anchor\" href=\"#代码\">#</a> 代码</h4>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"JAVA\"><figure class=\"iseeu highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> {</span><br><span class=\"line\">    Map&lt;String, Integer&gt; wordId = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;String, Integer&gt;();</span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; edge = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">nodeNum</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">ladderLength</span><span class=\"params\">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> {</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String word : wordList) {</span><br><span class=\"line\">            addEdge(word);</span><br><span class=\"line\">        }</span><br><span class=\"line\">        addEdge(beginWord);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!wordId.containsKey(endWord)) {</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"type\">int</span>[] dis = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[nodeNum];</span><br><span class=\"line\">        Arrays.fill(dis, Integer.MAX_VALUE);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">beginId</span> <span class=\"operator\">=</span> wordId.get(beginWord), endId = wordId.get(endWord);</span><br><span class=\"line\">        dis[beginId] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        Queue&lt;Integer&gt; que = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;Integer&gt;();</span><br><span class=\"line\">        que.offer(beginId);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!que.isEmpty()) {</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">x</span> <span class=\"operator\">=</span> que.poll();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (x == endId) {</span><br><span class=\"line\">                <span class=\"keyword\">return</span> dis[endId] / <span class=\"number\">2</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">            }</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> it : edge.get(x)) {</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (dis[it] == Integer.MAX_VALUE) {</span><br><span class=\"line\">                    dis[it] = dis[x] + <span class=\"number\">1</span>;</span><br><span class=\"line\">                    que.offer(it);</span><br><span class=\"line\">                }</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">addEdge</span><span class=\"params\">(String word)</span> {</span><br><span class=\"line\">        addWord(word);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">id1</span> <span class=\"operator\">=</span> wordId.get(word);</span><br><span class=\"line\">        <span class=\"type\">char</span>[] array = word.toCharArray();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">length</span> <span class=\"operator\">=</span> array.length;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; length; ++i) {</span><br><span class=\"line\">            <span class=\"type\">char</span> <span class=\"variable\">tmp</span> <span class=\"operator\">=</span> array[i];</span><br><span class=\"line\">            array[i] = <span class=\"string\">'*'</span>;</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">newWord</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(array);</span><br><span class=\"line\">            addWord(newWord);</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">id2</span> <span class=\"operator\">=</span> wordId.get(newWord);</span><br><span class=\"line\">            edge.get(id1).add(id2);</span><br><span class=\"line\">            edge.get(id2).add(id1);</span><br><span class=\"line\">            array[i] = tmp;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">addWord</span><span class=\"params\">(String word)</span> {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!wordId.containsKey(word)) {</span><br><span class=\"line\">            wordId.put(word, nodeNum++);</span><br><span class=\"line\">            edge.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;Integer&gt;());</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure></div>\n<h4 id=\"复杂度分析\"><a class=\"markdownIt-Anchor\" href=\"#复杂度分析\">#</a> 复杂度分析</h4>\n<ul>\n<li>时间复杂度： <code>O(N×C2)</code> 。其中  N 为 wordList 的长度， C 为列表中单词的长度。</li>\n</ul>\n<p>建图过程中，对于每一个单词，我们需要枚举它连接到的所有虚拟节点，时间复杂度为   <code>O(C)</code> ，将这些单词加入到哈希表中，时间复杂度为  <code>O(N×C)</code> ，因此总时间复杂度为  <code>O(N×C)</code> 。</p>\n<p>广度优先搜索的时间复杂度最坏情况下是 O (N \\times C) O (N×C)。每一个单词需要拓展出 O©O© 个虚拟节点，因此节点数 O (N \\times C) O (N×C)。</p>\n<ul>\n<li>空间复杂度： <code>O(N×C2)</code> 。其中 N 为 wordList 的长度，C 为列表中单词的长度。哈希表中包含  <code>O(N×C)</code>  个节点，每个节点占用空间  <code>O(C)</code> ，因此总的空间复杂度为  <code>O(N×C^2)</code> 。</li>\n</ul>\n</body></html>","raw":null,"categories":[{"name":"算法","path":"api/categories/算法.json"}],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"},{"name":"单词接龙","path":"api/tags/单词接龙.json"}]},{"title":"买卖股票的最佳时机 II——LeetCode122","slug":"best-time-to-buy-and-sell-stock-ii","date":"2022-01-06T15:28:13.000Z","updated":"2023-04-30T03:57:46.423Z","comments":null,"realpath":null,"path":"api/articles/best-time-to-buy-and-sell-stock-ii.json","excerpt":"# 题目描述给定一个数组 prices ，其中&nbsp;prices [i] 是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。","keywords":"leetcode,算法,贪心算法,动态规划","cover":"/p/f883163f/2022-01-06%2023.30.34.png","content":"<html><head></head><body><h1 id=\"题目描述\"><a class=\"markdownIt-Anchor\" href=\"#题目描述\">#</a> 题目描述</h1>\n<p>给定一个数组 prices ，其中&nbsp;prices [i] 是一支给定股票第 i 天的价格。</p>\n<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>\n<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>\n<span id=\"more\"></span>\n<p>示例 1:</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: prices = [7,1,5,3,6,4]</span><br><span class=\"line\">输出: 7</span><br></pre></td></tr></tbody></table></figure></div>\n<p>解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出，这笔交易所能获得利润 = 5-1 = 4 。<br>\n随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，这笔交易所能获得利润 = 6-3 = 3 。<br>\n&nbsp;<br>\n示例 2:</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: prices = [1,2,3,4,5]</span><br><span class=\"line\">输出: 4</span><br></pre></td></tr></tbody></table></figure></div>\n<p>解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出，这笔交易所能获得利润 = 5-1 = 4 。<br>\n注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</p>\n<p>示例&nbsp;3:</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: prices = [7,6,4,3,1]</span><br><span class=\"line\">输出: 0</span><br></pre></td></tr></tbody></table></figure></div>\n<p>解释：在这种情况下，没有交易完成，所以最大利润为 0。</p>\n<p>提示：<br>\n]<br>\n1 &lt;= prices.length &lt;= 3 * 10^4<br>\n0 &lt;= prices[i] &lt;= 10^4</p>\n<h1 id=\"解题\"><a class=\"markdownIt-Anchor\" href=\"#解题\">#</a> 解题</h1>\n<h2 id=\"解法一动态规划\"><a class=\"markdownIt-Anchor\" href=\"#解法一动态规划\">#</a> 解法一：动态规划</h2>\n<h3 id=\"思路\"><a class=\"markdownIt-Anchor\" href=\"#思路\">#</a> 思路</h3>\n<p>虑到「不能同时参与多笔交易」，因此每天交易结束后只可能存在手里有一支股票或者没有股票的状态。</p>\n<p>定义状态 <code>dp[i][0]</code>  表示第 i 天交易完后手里没有股票的最大利润， <code>dp[i][1]</code>  表示第 i 天交易完后手里持有一支股票的最大利润（i 从 0 开始）。(<strong>定义状态</strong>)</p>\n<p>考虑 <code>dp[i][0]</code>  的转移方程，如果这一天交易完后手里没有股票，那么可能的转移状态为前一天已经没有股票，即  <code>dp[i−1][0]</code> ，或者前一天结束的时候手里持有一支股票，即  <code>dp[i−1][1]</code> ，这时候我们要将其卖出，并获得  <code>prices[i]</code>  的收益。因此为了收益最大化，我们列出如下的转移方程：</p>\n<p><code>dp[i][0] = max{ dp[i−1][0] , dp[i−1][1] + prices[i]}</code></p>\n<p>再来考虑 <code>dp[i][1]</code> ，按照同样的方式考虑转移状态，那么可能的转移状态为前一天已经持有一支股票，即 <code>dp[i−1][1]</code> ，或者前一天结束时还没有股票，即  <code>dp[i−1][0]</code> ，这时候我们要将其买入，并减少 <code>prices[i]</code>  的收益。可以列出如下的转移方程：</p>\n<p><code>dp[i][1] = max{ dp[i−1][1], dp[i−1][0]−prices[i] }</code></p>\n<p>对于初始状态，根据状态定义我们可以知道第 00 天交易结束的时候  <code>dp[0][0]=0</code> ， <code>dp[0][1]=−prices[0]</code> 。</p>\n<p>因此，我们只要从前往后依次计算状态即可。由于全部交易结束后，持有股票的收益一定低于不持有股票的收益，因此这时候  <code>dp[n−1][0]</code>  的收益必然是大于 <code>dp[n−1][1]</code>  的，最后的答案即为  <code>dp[n−1][0]</code> 。</p>\n<h3 id=\"解题-2\"><a class=\"markdownIt-Anchor\" href=\"#解题-2\">#</a> 解题</h3>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"JAVA\"><figure class=\"iseeu highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> {</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxProfit</span><span class=\"params\">(<span class=\"type\">int</span>[] prices)</span> {</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> prices.length;</span><br><span class=\"line\">        <span class=\"comment\">// 状态定义 x为天数  y为0为当天不持有 1为当天持有</span></span><br><span class=\"line\">        <span class=\"type\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n][<span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"comment\">// 定义起始状态</span></span><br><span class=\"line\">        <span class=\"comment\">// 第一天 不持有，不花钱 收益为0</span></span><br><span class=\"line\">        dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 第一天 持有，花钱 收益为当天买股票的钱</span></span><br><span class=\"line\">        dp[<span class=\"number\">0</span>][<span class=\"number\">1</span>] = - prices[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"comment\">// 从第二天开始递推哈</span></span><br><span class=\"line\">        <span class=\"comment\">//</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">d</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; d &lt; n; d++) {</span><br><span class=\"line\">            <span class=\"comment\">// 第二天不持有股票：</span></span><br><span class=\"line\">            <span class=\"comment\">// 第一天不持有股票的收益 + （没买）0  |  第一天持有股票 + （卖出）第二天价格 ；</span></span><br><span class=\"line\">            dp[d][<span class=\"number\">0</span>] = Math.max(dp[d-<span class=\"number\">1</span>][<span class=\"number\">0</span>], dp[d-<span class=\"number\">1</span>][<span class=\"number\">1</span>] + prices[d]);</span><br><span class=\"line\">            <span class=\"comment\">// 第二天持有股票：</span></span><br><span class=\"line\">            <span class=\"comment\">// 第一天不持有股票的收益 + 买入第二天价格  |  第一天持有股票 + 没买也没卖 ；</span></span><br><span class=\"line\">            dp[d][<span class=\"number\">1</span>] = Math.max(dp[d-<span class=\"number\">1</span>][<span class=\"number\">0</span>] - prices[d], dp[d-<span class=\"number\">1</span>][<span class=\"number\">1</span>]);</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"comment\">// 持有股票的收益必定小于不持有股票</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n-<span class=\"number\">1</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure></div>\n<p>注意到上面的状态转移方程中，每一天的状态只与前一天的状态有关，而与更早的状态都无关，因此我们不必存储这些无关的状态，只需要将 <code>dp[i−1][0] </code> 和 <code>dp[i−1][1]</code>  存放在两个变量中，通过它们计算出 <code>dp[i][0]</code>  和 <code>dp[i][1]</code>  并存回对应的变量，以便于第 <code>i+1</code>  天的状态转移即可。</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"JAVA\"><figure class=\"iseeu highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> {</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxProfit</span><span class=\"params\">(<span class=\"type\">int</span>[] prices)</span> {</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> prices.length;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">dp0</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, dp1 = -prices[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; n; ++i) {</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">newDp0</span> <span class=\"operator\">=</span> Math.max(dp0, dp1 + prices[i]);</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">newDp1</span> <span class=\"operator\">=</span> Math.max(dp1, dp0 - prices[i]);</span><br><span class=\"line\">            dp0 = newDp0;</span><br><span class=\"line\">            dp1 = newDp1;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp0;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure></div>\n<h3 id=\"复杂度分析\"><a class=\"markdownIt-Anchor\" href=\"#复杂度分析\">#</a> 复杂度分析</h3>\n<ul>\n<li>\n<p>时间复杂度： <code>O(n)</code> ，其中 n 为数组的长度。一共有 2n 个状态，每次状态转移的时间复杂度为  <code>O(1)</code> ，因此时间复杂度为 <code>O(2n)=O(n)</code> 。</p>\n</li>\n<li>\n<p>空间复杂度： <code>O(n)</code> 。我们需要开辟 <code>O(n)</code>  空间存储动态规划中的所有状态。如果使用空间优化，空间复杂度可以优化至  <code>O(1)</code> 。</p>\n</li>\n</ul>\n<h2 id=\"解法二贪心\"><a class=\"markdownIt-Anchor\" href=\"#解法二贪心\">#</a> 解法二：贪心</h2>\n<h3 id=\"思路-2\"><a class=\"markdownIt-Anchor\" href=\"#思路-2\">#</a> 思路</h3>\n<h3 id=\"解题-3\"><a class=\"markdownIt-Anchor\" href=\"#解题-3\">#</a> 解题</h3>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"JAVA\"><figure class=\"iseeu highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> {</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxProfit</span><span class=\"params\">(<span class=\"type\">int</span>[] prices)</span> {</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">ans</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> prices.length;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; n; ++i) {</span><br><span class=\"line\">            ans += Math.max(<span class=\"number\">0</span>, prices[i] - prices[i - <span class=\"number\">1</span>]);</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure></div>\n<h3 id=\"复杂度分析-2\"><a class=\"markdownIt-Anchor\" href=\"#复杂度分析-2\">#</a> 复杂度分析</h3>\n</body></html>","raw":null,"categories":[{"name":"java","path":"api/categories/java.json"}],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"},{"name":"贪心","path":"api/tags/贪心.json"},{"name":"动态规划","path":"api/tags/动态规划.json"}]},{"title":"路径总和 II——LeetCode113","slug":"path-sum-ii","date":"2022-01-05T14:27:28.000Z","updated":"2023-04-30T03:57:46.439Z","comments":null,"realpath":null,"path":"api/articles/path-sum-ii.json","excerpt":"# 题目描述给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。叶子节点 是指没有子节点的节点。","keywords":"二叉树,dfs,bfs,leetcode","cover":"/p/7d31a8bc/u=193842663,8061252&fm=26&fmt=auto.jpeg","content":"<html><head></head><body><h1 id=\"题目描述\"><a class=\"markdownIt-Anchor\" href=\"#题目描述\">#</a> 题目描述</h1>\n<p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p>\n<p>叶子节点 是指没有子节点的节点。</p>\n<span id=\"more\"></span>\n<p>示例 1：</p>\n<p><img src=\"/p/7d31a8bc/index.htmlpathsumii1.jpg\" alt=\"\"></p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22</span><br><span class=\"line\">输出：[[5,4,11,2],[5,8,4,5]]</span><br></pre></td></tr></tbody></table></figure></div>\n<p>示例 2：</p>\n<p><img src=\"/p/7d31a8bc/index.htmlpathsum2.jpg\" alt=\"img\"></p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：root = [1,2,3], targetSum = 5</span><br><span class=\"line\">输出：[]</span><br></pre></td></tr></tbody></table></figure></div>\n<p>示例 3：</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：root = [1,2], targetSum = 0</span><br><span class=\"line\">输出：[]</span><br></pre></td></tr></tbody></table></figure></div>\n<p>提示：</p>\n<p>树中节点总数在范围 [0, 5000] 内<br>\n - 1000 &lt;= Node.val &lt;= 1000<br>\n-1000 &lt;= targetSum &lt;= 1000</p>\n<h1 id=\"解题\"><a class=\"markdownIt-Anchor\" href=\"#解题\">#</a> 解题</h1>\n<h2 id=\"dfs解法\"><a class=\"markdownIt-Anchor\" href=\"#dfs解法\">#</a> dfs 解法</h2>\n<ul>\n<li>\n<p>前言<br>\n注意到本题的要求是，找到所有满足从「根节点」到某个「叶子节点」经过的路径上的节点之和等于目标和的路径。核心思想是对树进行一次遍历，在遍历时记录从根节点到当前节点的路径和，以防止重复计算。</p>\n</li>\n<li>\n<p>思路及算法</p>\n<p>我们可以采用深度优先搜索的方式，枚举每一条从根节点到叶子节点的路径。当我们遍历到叶子节点，且此时路径和恰为目标和时，我们就找到了一条满足条件的路径。</p>\n</li>\n<li>\n<p>代码实现</p>\n</li>\n</ul>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"JAVA\"><figure class=\"iseeu highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> {</span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; ret = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class=\"line\">    Deque&lt;Integer&gt; path = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;Integer&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">pathSum</span><span class=\"params\">(TreeNode root, <span class=\"type\">int</span> targetSum)</span> {</span><br><span class=\"line\">        dfs(root, targetSum);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">dfs</span><span class=\"params\">(TreeNode root, <span class=\"type\">int</span> targetSum)</span> {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) {</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        path.offerLast(root.val);</span><br><span class=\"line\">        targetSum -= root.val;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root.left == <span class=\"literal\">null</span> &amp;&amp; root.right == <span class=\"literal\">null</span> &amp;&amp; targetSum == <span class=\"number\">0</span>) {</span><br><span class=\"line\">            ret.add(<span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;Integer&gt;(path));</span><br><span class=\"line\">        }</span><br><span class=\"line\">        dfs(root.left, targetSum);</span><br><span class=\"line\">        dfs(root.right, targetSum);</span><br><span class=\"line\">        path.pollLast();</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure></div>\n<ul>\n<li>复杂度分析</li>\n</ul>\n<p>复杂度分析</p>\n<p>时间复杂度： <code>O(N^2)</code> ・，其中 N 是树的节点数。在最坏情况下，树的上半部分为链状，下半部分为完全二叉树，并且从根节点到每一个叶子节点的路径都符合题目要求。此时，路径的数目为  <code>O(N)</code> ，并且每一条路径的节点个数也为 O (N) O (N)，因此要将这些路径全部添加进答案中，时间复杂度为  <code>O(N^2)</code></p>\n<p>空间复杂度： <code>O(N)</code> ，其中 N 是树的节点数。空间复杂度主要取决于栈空间的开销，栈中的元素个数不会超过树的节点数。</p>\n<h2 id=\"bfs解法\"><a class=\"markdownIt-Anchor\" href=\"#bfs解法\">#</a> bfs 解法</h2>\n<ul>\n<li>思路及算法</li>\n</ul>\n<p>我们也可以采用广度优先搜索的方式，遍历这棵树。当我们遍历到叶子节点，且此时路径和恰为目标和时，我们就找到了一条满足条件的路径。</p>\n<p>为了节省空间，我们使用哈希表记录树中的每一个节点的父节点。每次找到一个满足条件的节点，我们就从该节点出发不断向父节点迭代，即可还原出从根节点到当前节点的路径。</p>\n<ul>\n<li>代码实现</li>\n</ul>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"JAVA\"><figure class=\"iseeu highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> {</span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; ret = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class=\"line\">    Map&lt;TreeNode, TreeNode&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;TreeNode, TreeNode&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">pathSum</span><span class=\"params\">(TreeNode root, <span class=\"type\">int</span> targetSum)</span> {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) {</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        Queue&lt;TreeNode&gt; queueNode = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class=\"line\">        Queue&lt;Integer&gt; queueSum = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;Integer&gt;();</span><br><span class=\"line\">        queueNode.offer(root);</span><br><span class=\"line\">        queueSum.offer(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!queueNode.isEmpty()) {</span><br><span class=\"line\">            <span class=\"type\">TreeNode</span> <span class=\"variable\">node</span> <span class=\"operator\">=</span> queueNode.poll();</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">rec</span> <span class=\"operator\">=</span> queueSum.poll() + node.val;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node.left == <span class=\"literal\">null</span> &amp;&amp; node.right == <span class=\"literal\">null</span>) {</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (rec == targetSum) {</span><br><span class=\"line\">                    getPath(node);</span><br><span class=\"line\">                }</span><br><span class=\"line\">            } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (node.left != <span class=\"literal\">null</span>) {</span><br><span class=\"line\">                    map.put(node.left, node);</span><br><span class=\"line\">                    queueNode.offer(node.left);</span><br><span class=\"line\">                    queueSum.offer(rec);</span><br><span class=\"line\">                }</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (node.right != <span class=\"literal\">null</span>) {</span><br><span class=\"line\">                    map.put(node.right, node);</span><br><span class=\"line\">                    queueNode.offer(node.right);</span><br><span class=\"line\">                    queueSum.offer(rec);</span><br><span class=\"line\">                }</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getPath</span><span class=\"params\">(TreeNode node)</span> {</span><br><span class=\"line\">        List&lt;Integer&gt; temp = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;Integer&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (node != <span class=\"literal\">null</span>) {</span><br><span class=\"line\">            temp.add(node.val);</span><br><span class=\"line\">            node = map.get(node);</span><br><span class=\"line\">        }</span><br><span class=\"line\">        Collections.reverse(temp);</span><br><span class=\"line\">        ret.add(<span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;Integer&gt;(temp));</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure></div>\n<ul>\n<li>复杂度分析</li>\n</ul>\n<p>时间复杂度： <code>O(N^2)</code> ，其中 NN 是树的节点数。分析思路与方法一相同。</p>\n<p>空间复杂度： <code>O(N)</code> ，其中 NN 是树的节点数。空间复杂度主要取决于哈希表和队列空间的开销，哈希表需要存储除根节点外的每个节点的父节点，队列中的元素个数不会超过树的节点数</p>\n</body></html>","raw":null,"categories":[{"name":"java","path":"api/categories/java.json"}],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"树","path":"api/tags/树.json"},{"name":"dfs","path":"api/tags/dfs.json"},{"name":"bfs","path":"api/tags/bfs.json"}]},{"title":"复原IP地址——LeetCode93","slug":"restore-ip-addresses","date":"2022-01-04T13:58:27.000Z","updated":"2023-04-30T03:57:46.483Z","comments":null,"realpath":null,"path":"api/articles/restore-ip-addresses.json","excerpt":"# 题目描述有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。例如：“0.1.2.201” 和 “192.168.1.1” 是 有效 IP 地址，但是 “0.011.255.245”、“192.168.1.312” 和 “192.168@1.1” 是 无效 IP 地址。<br>给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 ‘.’ 来形成。你不能重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。","keywords":"算法,leetcode,ip,地址,回溯","cover":"/p/ab179abd/leetcode.jpeg","content":"<html><head></head><body><h1 id=\"题目描述\"><a class=\"markdownIt-Anchor\" href=\"#题目描述\">#</a> 题目描述</h1>\n<p>有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。</p>\n<p>例如：“0.1.2.201” 和 “192.168.1.1” 是 有效 IP 地址，但是 “0.011.255.245”、“192.168.1.312” 和 “192.168@1.1” 是 无效 IP 地址。<br>\n给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 ‘.’ 来形成。你不能重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。</p>\n<span id=\"more\"></span>\n<h2 id=\"用例\"><a class=\"markdownIt-Anchor\" href=\"#用例\">#</a> 用例</h2>\n<p>示例 1：</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = \"25525511135\"</span><br><span class=\"line\">输出：[\"255.255.11.135\",\"255.255.111.35\"]</span><br></pre></td></tr></tbody></table></figure></div>\n<p>示例 2：</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = \"0000\"</span><br><span class=\"line\">输出：[\"0.0.0.0\"]</span><br></pre></td></tr></tbody></table></figure></div>\n<p>示例 3：</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = \"1111\"</span><br><span class=\"line\">输出：[\"1.1.1.1\"]</span><br></pre></td></tr></tbody></table></figure></div>\n<p>示例 4：</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = \"010010\"</span><br><span class=\"line\">输出：[\"0.10.0.10\",\"0.100.1.0\"]</span><br></pre></td></tr></tbody></table></figure></div>\n<p>示例 5：</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = \"101023\"</span><br><span class=\"line\">输出：[\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]</span><br></pre></td></tr></tbody></table></figure></div>\n<p>提示：</p>\n<p>0 &lt;= s.length &lt;= 20<br>\ns 仅由数字组成</p>\n<h1 id=\"解题\"><a class=\"markdownIt-Anchor\" href=\"#解题\">#</a> 解题</h1>\n<h2 id=\"解题思路\"><a class=\"markdownIt-Anchor\" href=\"#解题思路\">#</a> 解题思路</h2>\n<p>由于我们需要找出所有可能复原出的 IP 地址，因此可以考虑使用<strong>回溯</strong>的方法，对<strong>所有可能的字符串分隔方式</strong>进行搜索，并筛选出满足要求的作为答案。</p>\n<p>设题目中给出的字符串为 s。我们用递归函数  <code>dfs(segId,segStart)</code>  表示我们正在从 <code>s[segStart] </code> 的位置开始，搜索 IP 地址中的第 segId 段，其中 <code>segId∈{0,1,2,3}</code> 。由于 IP 地址的每一段必须是  <code>[0, 255] </code> 中的整数，因此我们从 segStart 开始，从小到大依次枚举当前这一段 IP 地址的结束位置 segEnd。如果满足要求，就递归地进行下一段搜索，调用递归函数 <code>dfs(segId+1,segEnd+1)</code> 。</p>\n<p>特别地，由于 IP 地址的每一段不能有前导零，因此如果  <code>s[segStart]</code>  等于字符 0，那么 IP 地址的第 segId 段只能为 0，需要作为特殊情况进行考虑。</p>\n<p>在搜索的过程中，如果我们已经得到了全部的 4 段 IP 地址（即 segId=4），并且遍历完了整个字符串（即  <code>segStart=∣s∣</code> ，其中  <code>|s|</code>  表示字符串 s 的长度），那么就复原出了一种满足题目要求的 IP 地址，我们将其加入答案。在其它的时刻，如果提前遍历完了整个字符串，那么我们需要结束搜索，回溯到上一步。</p>\n<h2 id=\"代码实现\"><a class=\"markdownIt-Anchor\" href=\"#代码实现\">#</a> 代码实现</h2>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"JAVA\"><figure class=\"iseeu highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> {</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">SEG_COUNT</span> <span class=\"operator\">=</span> <span class=\"number\">4</span>;</span><br><span class=\"line\">    List&lt;String&gt; ans = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;String&gt;();</span><br><span class=\"line\">    <span class=\"type\">int</span>[] segments = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[SEG_COUNT];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;String&gt; <span class=\"title function_\">restoreIpAddresses</span><span class=\"params\">(String s)</span> {</span><br><span class=\"line\">        segments = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[SEG_COUNT];</span><br><span class=\"line\">        dfs(s, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">dfs</span><span class=\"params\">(String s, <span class=\"type\">int</span> segId, <span class=\"type\">int</span> segStart)</span> {</span><br><span class=\"line\">        <span class=\"comment\">// 如果找到了 4 段 IP 地址并且遍历完了字符串，那么就是一种答案</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (segId == SEG_COUNT) {</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (segStart == s.length()) {</span><br><span class=\"line\">                <span class=\"type\">StringBuffer</span> <span class=\"variable\">ipAddr</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuffer</span>();</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; SEG_COUNT; ++i) {</span><br><span class=\"line\">                    ipAddr.append(segments[i]);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (i != SEG_COUNT - <span class=\"number\">1</span>) {</span><br><span class=\"line\">                        ipAddr.append(<span class=\"string\">'.'</span>);</span><br><span class=\"line\">                    }</span><br><span class=\"line\">                }</span><br><span class=\"line\">                ans.add(ipAddr.toString());</span><br><span class=\"line\">            }</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果还没有找到 4 段 IP 地址就已经遍历完了字符串，那么提前回溯</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (segStart == s.length()) {</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 由于不能有前导零，如果当前数字为 0，那么这一段 IP 地址只能为 0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.charAt(segStart) == <span class=\"string\">'0'</span>) {</span><br><span class=\"line\">            segments[segId] = <span class=\"number\">0</span>;</span><br><span class=\"line\">            dfs(s, segId + <span class=\"number\">1</span>, segStart + <span class=\"number\">1</span>);</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 一般情况，枚举每一种可能性并递归</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">addr</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">segEnd</span> <span class=\"operator\">=</span> segStart; segEnd &lt; s.length(); ++segEnd) {</span><br><span class=\"line\">            addr = addr * <span class=\"number\">10</span> + (s.charAt(segEnd) - <span class=\"string\">'0'</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (addr &gt; <span class=\"number\">0</span> &amp;&amp; addr &lt;= <span class=\"number\">0xFF</span>) {</span><br><span class=\"line\">                segments[segId] = addr;</span><br><span class=\"line\">                dfs(s, segId + <span class=\"number\">1</span>, segEnd + <span class=\"number\">1</span>);</span><br><span class=\"line\">            } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure></div>\n<h2 id=\"复杂度分析\"><a class=\"markdownIt-Anchor\" href=\"#复杂度分析\">#</a> 复杂度分析</h2>\n<p>复杂度分析</p>\n<p>我们用 SEG_COUNT=4 表示 IP 地址的段数。</p>\n<p>时间复杂度： <code>O(3^SEG_COUNT × ∣s∣)</code> 。由于 IP 地址的每一段的位数不会超过 3，因此在递归的每一层，我们最多只会深入到下一层的 33 种情况。由于 SEG_COUNT=4，对应着递归的最大层数。如果我们复原出了一种满足题目要求的 IP 地址，那么需要  <code>O(∣s∣) </code> 的时间将其加入答案数组中，因此总时间复杂度为 <code>O(3 ^SEG_COUNT ×∣s∣)</code> 。</p>\n<p>空间复杂度： <code>O(SEG_COUNT)</code> ，这里只计入除了用来存储答案数组以外的额外空间复杂度。递归使用的空间与递归的最大深度 \\text {SEG_COUNT} SEG_COUNT 成正比。并且在上面的代码中，我们只额外使用了长度为  <code>SEG_COUNT</code>  的数组  <code>segments</code>  存储已经搜索过的 IP 地址，因此空间复杂度为 <code>O(SEG_COUNT)</code> 。</p>\n</body></html>","raw":null,"categories":[{"name":"java","path":"api/categories/java.json"}],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"},{"name":"回溯","path":"api/tags/回溯.json"}]},{"title":"最长回文子串——Leetcode5","slug":"longest-palindromic-substring","date":"2022-01-03T06:28:19.000Z","updated":"2023-04-30T03:57:46.431Z","comments":null,"realpath":null,"path":"api/articles/longest-palindromic-substring.json","excerpt":"# 题目描述给你一个字符串 s，找到 s 中最长的回文子串。","keywords":"回文子串,leetcode5","cover":"/p/dfd6ab93/image-20220103143944443.png","content":"<html><head></head><body><h1 id=\"题目描述\"><a class=\"markdownIt-Anchor\" href=\"#题目描述\">#</a> 题目描述</h1>\n<p>给你一个字符串 s，找到 s 中最长的回文子串。</p>\n<span id=\"more\"></span>\n<p>示例 1：</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = \"babad\"</span><br><span class=\"line\">输出：\"bab\"</span><br><span class=\"line\">解释：\"aba\" 同样是符合题意的答案。</span><br></pre></td></tr></tbody></table></figure></div>\n<p>示例 2：</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = \"cbbd\"</span><br><span class=\"line\">输出：\"bb\"</span><br></pre></td></tr></tbody></table></figure></div>\n<p>示例 3：</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = \"a\"</span><br><span class=\"line\">输出：\"a\"</span><br></pre></td></tr></tbody></table></figure></div>\n<p>示例 4：</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = \"ac\"</span><br><span class=\"line\">输出：\"a\"</span><br></pre></td></tr></tbody></table></figure></div>\n<p>提示：</p>\n<p><code>1 &lt;= s.length &lt;= 1000</code> <br>\ns 仅由数字和英文字母（大写和 / 或小写）组成</p>\n<h1 id=\"解题\"><a class=\"markdownIt-Anchor\" href=\"#解题\">#</a> 解题</h1>\n<h2 id=\"解题思路\"><a class=\"markdownIt-Anchor\" href=\"#解题思路\">#</a> 解题思路</h2>\n<p>对于一个子串而言，如果它是回文串，并且长度大于 22，那么将它首尾的两个字母去除之后，它仍然是个回文串。例如对于字符串 “ababa”，如果我们已经知道 “bab” 是回文串，那么 “ababa” 一定是回文串，这是因为它的首尾两个字母都是 “a”。</p>\n<p>根据这样的思路，我们就可以用动态规划的方法解决本题。我们用  <code>P(i,j) </code> 表示字符串 s 的第 i 到 j 个字母组成的串（下文表示成  <code>s[i:j]</code> ）是否为回文串：如果字符串 s 从 i 到 j 是回文串，那么 <code>P(i,j)= true</code> ，否则为 <code>P(i,j)= true</code> ；</p>\n<p>这里的「否」包含两种可能性：</p>\n<ul>\n<li>\n<p><code>s[i,j]</code>  本身不是一个回文串；</p>\n</li>\n<li>\n<p><code>i&gt;j</code> ，此时  <code>s[i,j]</code>  本身不合法。</p>\n</li>\n</ul>\n<p>那么我们就可以写出动态规划的状态转移方程：</p>\n<p><img src=\"/p/dfd6ab93/index.htmlimage-20220104210656306.png\" alt=\"状态转移方程\"></p>\n<p>也就是说，只有  <code>s[i+1:j−1] </code> 是回文串，并且  <code>s</code>  的第 <code>i</code>  和  <code>j</code>  个字母相同时， <code>s[i:j]</code>  才会是回文串。</p>\n<p>上文的所有讨论是建立在子串长度大于 2 的前提之上的，我们还需要考虑动态规划中的<strong>边界条件</strong>，即子串的长度为 1 或 2。</p>\n<ul>\n<li>\n<p>对于长度为 1 的子串，它显然是个回文串；</p>\n</li>\n<li>\n<p>对于长度为 2 的子串，只要它的两个字母相同，它就是一个回文串。</p>\n</li>\n</ul>\n<p>因此我们就可以写出动态规划的边界条件：</p>\n<p><img src=\"/p/dfd6ab93/index.htmlimage-20220104210730308.png\" alt=\"边界条件\"></p>\n<p>根据这个思路，我们就可以完成动态规划了，最终的答案即为所有 <code> P(i, j) = true</code>  中  <code>j−i+1</code> （即子串长度）的最大值。注意：在状态转移方程中，我们是从长度较短的字符串向长度较长的字符串进行转移的，因此一定要注意动态规划的循环顺序。</p>\n<h2 id=\"代码实现\"><a class=\"markdownIt-Anchor\" href=\"#代码实现\">#</a> 代码实现</h2>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"JAVA\"><figure class=\"iseeu highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> {</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">longestPalindrome</span><span class=\"params\">(String s)</span> {</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> s.length();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (len &lt; <span class=\"number\">2</span>) {</span><br><span class=\"line\">            <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">maxLen</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">begin</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// dp[i][j] 表示 s[i..j] 是否是回文串</span></span><br><span class=\"line\">        <span class=\"type\">boolean</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">boolean</span>[len][len];</span><br><span class=\"line\">        <span class=\"comment\">// 初始化：所有长度为 1 的子串都是回文串</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; len; i++) {</span><br><span class=\"line\">            dp[i][i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">char</span>[] charArray = s.toCharArray();</span><br><span class=\"line\">        <span class=\"comment\">// 递推开始</span></span><br><span class=\"line\">        <span class=\"comment\">// 先枚举子串长度</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">L</span> <span class=\"operator\">=</span> <span class=\"number\">2</span>; L &lt;= len; L++) {</span><br><span class=\"line\">            <span class=\"comment\">// 枚举左边界，左边界的上限设置可以宽松一些</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; len; i++) {</span><br><span class=\"line\">                <span class=\"comment\">// 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得</span></span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> L + i - <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"comment\">// 如果右边界越界，就可以退出当前循环</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (j &gt;= len) {</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                }</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (charArray[i] != charArray[j]) {</span><br><span class=\"line\">                    dp[i][j] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">                } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (j - i &lt; <span class=\"number\">3</span>) {</span><br><span class=\"line\">                        dp[i][j] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                    } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">                        dp[i][j] = dp[i + <span class=\"number\">1</span>][j - <span class=\"number\">1</span>];</span><br><span class=\"line\">                    }</span><br><span class=\"line\">                }</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (dp[i][j] &amp;&amp; j - i + <span class=\"number\">1</span> &gt; maxLen) {</span><br><span class=\"line\">                    maxLen = j - i + <span class=\"number\">1</span>;</span><br><span class=\"line\">                    begin = i;</span><br><span class=\"line\">                }</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s.substring(begin, begin + maxLen);</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure></div>\n<h2 id=\"复杂度分析\"><a class=\"markdownIt-Anchor\" href=\"#复杂度分析\">#</a> 复杂度分析</h2>\n<p>时间复杂度： <code>O(n^2) </code> 其中 n 是字符串的长度。动态规划的状态总数为  <code>O(n^2)</code>  对于每个状态，我们需要转移的时间为  <code>O(1)</code> 。</p>\n<p>空间复杂度： <code>O(n^2)</code> ，即存储动态规划状态需要的空间。</p>\n</body></html>","raw":null,"categories":[{"name":"java","path":"api/categories/java.json"}],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"},{"name":"动态规划","path":"api/tags/动态规划.json"}]},{"title":"linux生产免费的域名证书","slug":"acmesh-cert","date":"2021-12-29T13:59:07.000Z","updated":"2023-04-30T03:57:46.423Z","comments":null,"realpath":null,"path":"api/articles/acmesh-cert.json","excerpt":"简单来说 acme.sh 实现了 acme 协议，可以从 let‘s encrypt 生成免费的证书。<br>acme.sh 有以下特点：<br>一个纯粹用 Shell（Unix shell）语言编写的 ACME 协议客户端。<br>完整的 ACME 协议实施。 支持 ACME v1 和 ACME v2 支持 ACME v2 通配符证书<br>简单，功能强大且易于使用。你只需要 3 分钟就可以学习它。<br>Let’s Encrypt 免费证书客户端最简单的 shell 脚本。<br>纯粹用 Shell 编写，不依赖于 python 或官方的 Let’s Encrypt 客户端。<br>只需一个脚本即可自动颁发，续订和安装证书。 不需要 root/sudoer 访问权限。<br>支持在 Docker 内使用，支持 IPv6","keywords":"linux,cert,acme.sh","cover":"/p/4425fc35/867078-20190326175923357-720763416.png","content":"<html><head></head><body><p><a href=\"http://xn--acme-kt0gs67hmo3a2r1a.sh\">简单来说 acme.sh</a> 实现了 acme 协议，可以从 let‘s encrypt 生成免费的证书。<br>\n<a href=\"http://acme.sh\">acme.sh</a> 有以下特点：<br>\n一个纯粹用 Shell（Unix shell）语言编写的 ACME 协议客户端。<br>\n完整的 ACME 协议实施。 支持 ACME v1 和 ACME v2 支持 ACME v2 通配符证书<br>\n简单，功能强大且易于使用。你只需要 3 分钟就可以学习它。<br>\nLet’s Encrypt 免费证书客户端最简单的 shell 脚本。<br>\n纯粹用 Shell 编写，不依赖于 python 或官方的 Let’s Encrypt 客户端。<br>\n只需一个脚本即可自动颁发，续订和安装证书。 不需要 root/sudoer 访问权限。<br>\n支持在 Docker 内使用，支持 IPv6</p>\n<span id=\"more\"></span>\n<p><strong>安装环境：</strong><br>\n<strong>操作系统：centos 7 X64</strong><br>\n<strong>SSL 证书来源：Let’s Encrypt</strong><br>\n<strong> 安装用脚本：<a href=\"http://acme.sh\">acme.sh</a></strong><br>\n<strong> 服务器：nginx</strong><br>\n<strong> 域名：<a href=\"http://epoint.pswen.cn\">epoint.pswen.cn</a></strong></p>\n<p><a href=\"http://1.xn--acme-ke9g492u.sh\">1. 安装 acme.sh</a></p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"SHELL\"><figure class=\"iseeu highlight shell\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl https://get.acme.sh | sh</span><br></pre></td></tr></tbody></table></figure></div>\n<p>2. 安装后的配置<br>\n把 <a href=\"http://acme.sh\">acme.sh</a> 安装到你的 home 目录下:~/.acme.sh/ 并创建 一个 bash 的 alias, 方便你的使用:</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"SHELL\"><figure class=\"iseeu highlight shell\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alias acme.sh=~/.acme.sh/acme.sh</span><br><span class=\"line\">echo 'alias acme.sh=~/.acme.sh/acme.sh' &gt;&gt;/etc/profile</span><br></pre></td></tr></tbody></table></figure></div>\n<p>3. 申请证书<br>\n<a href=\"http://acme.sh\"> acme.sh</a> 实现了 acme 协议支持的所有验证协议。一般有两种方式验证: http 和 dns 验证（本文不提供 dns 方式申请，dns 手动模式，不能自动更新证书。在续订证书时，您必须手动向域中添加新的 txt 记录。）</p>\n<p>HTTP 方式方法如下：</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"SH\"><figure class=\"iseeu highlight sh\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">acme.sh --issue -d epoint.pswen.cn --webroot /nginx网站根目录</span><br></pre></td></tr></tbody></table></figure></div>\n<p>只需要指定域名，并指定域名所在的网站根目录【命令中根目录路径】. <a href=\"http://acme.sh\">acme.sh</a> 会全自动的生成验证文件，并放到网站的根目录，然后自动完成验证。最后会聪明的删除验证文件。整个过程没有任何副作用.</p>\n<p>4. 证书的安装<br>\n注意，默认生成的证书都放在安装目录下: ~/.acme.sh/, 请不要直接使用此目录下的文件，<br>\n 例如：不要直接让 nginx/apache 的配置文件使用这下面的文件.<br>\n 这里面的文件都是内部使用，而且目录结构可能会变化.</p>\n<p>正确的使用方法是使用 --installcert 命令，并指定目标位置，然后证书文件会被 copy 到相应的位置，</p>\n<p>Nginx 服务： <code>service nginx force-reload</code> 。(centos6)</p>\n<p>Nginx 服务： <code>systemctl restart nginx </code> 。(centos7)</p>\n<p>nginx 示例 1:</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"SHELL\"><figure class=\"iseeu highlight shell\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">acme.sh --installcert -d epoint.pswen.cn --key-file /usr/local/nginx/ssl_cert/epoint.pswen.cn.key --fullchain-file /usr/local/nginx/ssl_cert/epoint.pswen.cn.cer --reloadcmd \"service nginx force-reload\"</span><br></pre></td></tr></tbody></table></figure></div>\n<p>nginx 示例 2：</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"SH\"><figure class=\"iseeu highlight sh\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">acme.sh --install-cert -d chandao.test.com \\</span><br><span class=\"line\">--key-file /usr/local/nginx/ssl_cert/test.com/chandao.test.com.key \\</span><br><span class=\"line\">--fullchain-file /usr/local/nginx/ssl_cert/test.com/chandao.test.com.cer \\</span><br><span class=\"line\">--reloadcmd      <span class=\"string\">\"service nginx force-reload\"</span></span><br></pre></td></tr></tbody></table></figure></div>\n<p>附带完成前面 1-4 步骤的截图：</p>\n<p><img src=\"/p/4425fc35/index.html867078-20190326175923357-720763416.png\" alt=\"img\"></p>\n<ol start=\"5\">\n<li>Nginx 服务器安装 SSL 证书</li>\n</ol>\n<p>Nginx 配置 Http 和 Https 共存</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"SHELL\"><figure class=\"iseeu highlight shell\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">listen 80; #如果硬性要求全部走https协议，这一行去除</span><br><span class=\"line\">listen 443 ssl http2; #如果硬性要求全部走https协议，这里去除ssl</span><br><span class=\"line\">server_name chandao.test.com;</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">ssl on; <span class=\"comment\">#如果硬性要求全部走https协议，这里开启ssl on</span></span></span><br><span class=\"line\">ssl_certificate /usr/local/nginx/ssl_cert/test.com/chandao.test.com.cer;</span><br><span class=\"line\">ssl_certificate_key /usr/local/nginx/ssl_cert/test.com/chandao.test.com.key;</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">ssl性能调优</span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">nginx 1.13.0支持了TLSv1.3,TLSv1.3相比之前的TLSv1.2、TLSv1.1等性能大幅提升</span></span><br><span class=\"line\">ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class=\"line\">ssl_ciphers EECDH+CHACHA20:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5;</span><br><span class=\"line\">ssl_prefer_server_ciphers on;</span><br><span class=\"line\">ssl_session_timeout 10m;</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">使用ssl_session_cache优化https下Nginx的性能</span></span><br><span class=\"line\">ssl_session_cache builtin:1000 shared:SSL:10m;</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">OCSP Stapling 开启。OCSP是用于在线查询证书吊销情况的服务，使用OCSP Stapling能将证书有效状态的信息缓存到服务器，提高 TLS 握手速度</span></span><br><span class=\"line\">ssl_stapling on;</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">OCSP Stapling 验证开启</span></span><br><span class=\"line\">ssl_stapling_verify on; </span><br></pre></td></tr></tbody></table></figure></div>\n<p>完整例子：</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"SHELL\"><figure class=\"iseeu highlight shell\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server {</span><br><span class=\"line\">  listen 80;  #如果硬性要求全部走https协议，这一行去除</span><br><span class=\"line\">  listen       443 ssl http2;    #如果硬性要求全部走https协议，这里去除ssl</span><br><span class=\"line\">  server_name chandao.test.com;</span><br><span class=\"line\">  access_log off;</span><br><span class=\"line\">  index index.html index.htm index.php;</span><br><span class=\"line\">  root /data/wwwroot/chandao;</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">  #</span><span class=\"language-bash\">ssl on;   <span class=\"comment\">#如果硬性要求全部走https协议，这里开启ssl on</span></span></span><br><span class=\"line\">  ssl_certificate   /usr/local/nginx/ssl_cert/test.com/chandao.test.com.cer;</span><br><span class=\"line\">  ssl_certificate_key  /usr/local/nginx/ssl_cert/test.com/chandao.test.com.key;</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">  #</span><span class=\"language-bash\">ssl性能调优</span></span><br><span class=\"line\"><span class=\"meta prompt_\">  #</span><span class=\"language-bash\">nginx 1.13.0支持了TLSv1.3,TLSv1.3相比之前的TLSv1.2、TLSv1.1等性能大幅提升</span></span><br><span class=\"line\">  ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class=\"line\">  ssl_ciphers EECDH+CHACHA20:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5;</span><br><span class=\"line\">  ssl_prefer_server_ciphers on;</span><br><span class=\"line\">  ssl_session_timeout 10m;</span><br><span class=\"line\"><span class=\"meta prompt_\">  #</span><span class=\"language-bash\">使用ssl_session_cache优化https下Nginx的性能</span></span><br><span class=\"line\">  ssl_session_cache builtin:1000 shared:SSL:10m;</span><br><span class=\"line\"><span class=\"meta prompt_\">  #</span><span class=\"language-bash\">OCSP Stapling 开启。OCSP是用于在线查询证书吊销情况的服务，使用OCSP Stapling能将证书有效状态的信息缓存到服务器，提高 TLS 握手速度</span></span><br><span class=\"line\">  ssl_stapling on;</span><br><span class=\"line\"><span class=\"meta prompt_\">  #</span><span class=\"language-bash\">OCSP Stapling 验证开启</span></span><br><span class=\"line\">  ssl_stapling_verify on; </span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">  #</span><span class=\"language-bash\">error_page 404 /404.html;</span></span><br><span class=\"line\"><span class=\"meta prompt_\">  #</span><span class=\"language-bash\">error_page 502 /502.html;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  location ~ [^/]\\.php(/|$) {</span><br><span class=\"line\">    #fastcgi_pass remote_php_ip:9000;</span><br><span class=\"line\">    fastcgi_pass unix:/dev/shm/php-cgi.sock;</span><br><span class=\"line\">    fastcgi_index index.php;</span><br><span class=\"line\">    include fastcgi.conf;</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf|flv|mp4|ico)$ {</span><br><span class=\"line\">    expires 30d;</span><br><span class=\"line\">    access_log off;</span><br><span class=\"line\">  }</span><br><span class=\"line\">  location ~ .*\\.(js|css)?$ {</span><br><span class=\"line\">    expires 7d;</span><br><span class=\"line\">    access_log off;</span><br><span class=\"line\">  }</span><br><span class=\"line\">  location ~ /\\.ht {</span><br><span class=\"line\">    deny all;</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure></div>\n<p>6. 重启 nginx<br>\n 保存退出后，通过 nginx -t 来检查配置文件是否正确，有错误的话改之即可。配置文件检测正确之后，通过 service nginx force-reload 来重载配置文件。</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"SHELL\"><figure class=\"iseeu highlight shell\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nginx -t</span><br><span class=\"line\">systemctl restart nginx</span><br></pre></td></tr></tbody></table></figure></div>\n</body></html>","raw":null,"categories":[],"tags":[{"name":"linux","path":"api/tags/linux.json"},{"name":"acmesh","path":"api/tags/acmesh.json"},{"name":"域名证书","path":"api/tags/域名证书.json"}]},{"title":"Java位运算原理及使用讲解","slug":"java-bitewise","date":"2021-12-29T12:02:53.000Z","updated":"2023-04-30T03:57:46.427Z","comments":null,"realpath":null,"path":"api/articles/java-bitewise.json","excerpt":"日常开发中位运算不是很常用，但是巧妙的使用位运算可以大量减少运行开销，优化算法。举个例子，翻转操作比较常见，比如初始值为 1，操作一次变为 0，再操作一次变为 1。可能的做法是使用三木运算符，判断原始值为 1 还是 0，如果是 1，设置为 0，否则设置为 0. 但是使用位运算，不用判断原始值，直接改变值就可以： 1^num  ,num 为原始值。当然，一条语句可能对代码没什么影响，但是在高重复，大数据量的情况下将会节省很多开销。","keywords":"Java,位运算","cover":"/p/7670a0f/index.htmlCenter.png","content":"<html><head></head><body><p>日常开发中位运算不是很常用，但是巧妙的使用位运算可以大量减少运行开销，优化算法。举个例子，翻转操作比较常见，比如初始值为 1，操作一次变为 0，再操作一次变为 1。可能的做法是使用三木运算符，判断原始值为 1 还是 0，如果是 1，设置为 0，否则设置为 0. 但是使用位运算，不用判断原始值，直接改变值就可以： <code>1^num </code> ,num 为原始值。当然，一条语句可能对代码没什么影响，但是在高重复，大数据量的情况下将会节省很多开销。</p>\n<span id=\"more\"></span>\n<h1 id=\"1-位运算符\"><a class=\"markdownIt-Anchor\" href=\"#1-位运算符\">#</a> 1. 位运算符</h1>\n<h2 id=\"11-java支持的位运算符\"><a class=\"markdownIt-Anchor\" href=\"#11-java支持的位运算符\">#</a> 1.1 java 支持的位运算符：</h2>\n<p>&amp;：按位与。</p>\n<p>|：按位或。</p>\n<p>~：按位非。</p>\n<p>^：按位异或。</p>\n<p>&lt;&lt;：左位移运算符。</p>\n<p>&gt;&gt;：右位移运算符。</p>\n<p>&lt;&lt;&lt;：无符号右移运算符。</p>\n<p>位运 算 符 中，除 ～ 以 外，其余 均 为 二 元 运 算 符 。 操 作 数 只 能 为 整 型 和字 符 型 数 据 。</p>\n<p>Java 使用 补 码 来 表 示 二 进 制 数，在补 码 表 示 中，最高 位 为 符号 位，正数 的 符 号 位 为 0, 负数 为 1。补 码 的 规 定 如 下 :</p>\n<p>对 正 数 来 说，最高位为 0, 其余 各 位 代 表 数 值 本 身 (以二 进制 表 示), 如 +42 的补码 为 00101010。</p>\n<p>对 负 数 而 言，把该 数 绝 对 值 的 补 码 按 位 取 反，然后 对 整 个数 加 1, 即得 该 数的 补 码 。 如 -1 的补 码 为 11111111111111111111111111111111 (00000000000000000000000000000001 按 位 取 反 11111111111111111111111111111110+1=11111111111111111111111111111111)。为何有那么多 0、1，java 中 int 是 32 位的。</p>\n<h2 id=\"12-按位与\"><a class=\"markdownIt-Anchor\" href=\"#12-按位与\">#</a> 1.2  按位与（&amp;）</h2>\n<p>按位与的运算规则</p>\n<table>\n<thead>\n<tr>\n<th>操作数 1</th>\n<th>0</th>\n<th>0</th>\n<th>1</th>\n<th>1</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>操作数 2</td>\n<td>0</td>\n<td>1</td>\n<td>0</td>\n<td>1</td>\n</tr>\n<tr>\n<td>按位与</td>\n<td>0</td>\n<td>0</td>\n<td>0</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n<p>规则总结：只有两个操作数对应位同为 1 时，结果为 1，其余全为 0. （或者是只要有一个操作数为 0，结果就为 0）。</p>\n<p>举例：</p>\n<p><img src=\"/p/7670a0f/index.htmlCenter.png\" alt=\"img\"></p>\n<p><img src=\"/p/7670a0f/index.htmlCenter-20211229200705116.png\" alt=\"img\"></p>\n<p><img src=\"/p/7670a0f/index.htmlCenter-20211229200704972.png\" alt=\"img\"></p>\n<h2 id=\"13-按位或\"><a class=\"markdownIt-Anchor\" href=\"#13-按位或\">#</a> 1.3 按位或（|）</h2>\n<p>按位或的运算规则</p>\n<table>\n<thead>\n<tr>\n<th>操作数 1</th>\n<th>0</th>\n<th>0</th>\n<th>1</th>\n<th>1</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>操作数 2</td>\n<td>0</td>\n<td>1</td>\n<td>0</td>\n<td>1</td>\n</tr>\n<tr>\n<td>按位或</td>\n<td>0</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n<p>规则总结：只有两个操作数对应位同为 0 时，结果为 0，其余全为 1.（或者是只要有一个操作数为 1，结果就为 1）。</p>\n<h2 id=\"14按位非~\"><a class=\"markdownIt-Anchor\" href=\"#14按位非~\">#</a> 1.4 按位非（~）</h2>\n<p>按位非的运算规则</p>\n<table>\n<thead>\n<tr>\n<th>操作数</th>\n<th>0</th>\n<th>1</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>按位或</td>\n<td>1</td>\n<td>0</td>\n</tr>\n</tbody>\n</table>\n<p>在求负数的源码中使用过。</p>\n<h2 id=\"15-按位异或\"><a class=\"markdownIt-Anchor\" href=\"#15-按位异或\">#</a> 1.5 按位异或（^）</h2>\n<p>按位异或的运算规则</p>\n<table>\n<thead>\n<tr>\n<th>操作数 1</th>\n<th>0</th>\n<th>0</th>\n<th>1</th>\n<th>1</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>操作数 2</td>\n<td>0</td>\n<td>1</td>\n<td>0</td>\n<td>1</td>\n</tr>\n<tr>\n<td>按位异或</td>\n<td>0</td>\n<td>1</td>\n<td>1</td>\n<td>0</td>\n</tr>\n</tbody>\n</table>\n<p>规则总结：异：1.</p>\n<h2 id=\"16-左位移\"><a class=\"markdownIt-Anchor\" href=\"#16-左位移\">#</a> 1.6 左位移（&lt;&lt;）</h2>\n<p>算术右移（&gt;&gt;）: 符号位不变，低位补 0。如：2&lt;&lt;2 结果为 8。</p>\n<p><img src=\"/p/7670a0f/index.htmlCenter-20211229200705119.png\" alt=\"img\"></p>\n<p>当移动的位数超过数字本身的位数时，那么不就都需要补 0 操作，实际上不是的，java 不可能做那么浪费资源的事情。在真正执行位移前，其对要移动的位数做了一些预处理，比如 32 处理为 0，-1 处理为 31.</p>\n<h2 id=\"17-右位移\"><a class=\"markdownIt-Anchor\" href=\"#17-右位移\">#</a> 1.7 右位移（&gt;&gt;）</h2>\n<p>低位溢出，符号位不变，并用符号位补溢出的高位。如：-6&gt;&gt;2 结果为 - 2。</p>\n<p><img src=\"/p/7670a0f/index.htmlCenter-20211229200705083.png\" alt=\"img\"></p>\n<h2 id=\"18-无符号右移\"><a class=\"markdownIt-Anchor\" href=\"#18-无符号右移\">#</a> 1.8 无符号右移（&gt;&gt;&gt;）</h2>\n<p>低位溢出，高位补 0。注意，无符号右移（&gt;&gt;&gt;）中的符号位（最高位）也跟着变，无符号的意思是将符号位当作数字位看待。如：-1&gt;&gt;&gt;1 结果为 2147483647。这个数字应该比较熟悉，看两个输出语句就知道是什么了：</p>\n<p><code>System.out.println(Integer.toBinaryString(-1&gt;&gt;&gt;1));</code></p>\n<p><code>System.out.println(Integer.toBinaryString(Integer.MAX_VALUE));</code></p>\n<p>输出结果为：</p>\n<p>1111111111111111111111111111111</p>\n<p>1111111111111111111111111111111</p>\n<p>-1&gt;&gt;&gt;1 竟然得到了 int 所能表示的最大整数，精彩。</p>\n<p><img src=\"/p/7670a0f/index.htmlCenter-20211229200704949.png\" alt=\"img\"></p>\n<p>除了使用 - 1&gt;&gt;&gt;1 能得到 Integer.MAX_VALUE，以下的也能得到同样的结果：</p>\n<p>​    //maxInt</p>\n<p>​    System.<em>out</em>.println(~(1 &lt;&lt; 31));</p>\n<p>​    System.<em>out</em>.println((1 &lt;&lt; -1)-1);</p>\n<p>​    System.<em>out</em>.println(~(1 &lt;&lt; -1));</p>\n<p>使用位运算往往能很巧妙的实现某些算法完成一些复杂的功能。</p>\n<h1 id=\"常见使用\"><a class=\"markdownIt-Anchor\" href=\"#常见使用\">#</a> 常见使用</h1>\n<h2 id=\"1-m2n\"><a class=\"markdownIt-Anchor\" href=\"#1-m2n\">#</a> 1.   m*2^n</h2>\n<p>可以使用 m&lt;&lt;n 求得结果，如：</p>\n<p>​    System.<em>out</em>.println(“2^3=” + (1&lt;&lt;3));//2^3=8</p>\n<p>​    System.<em>out</em>.println(\"3<em>2^3=\" + (3&lt;&lt;3));//3</em>2^3=24</p>\n<p>计算结果是不是很正确呢？如果非要说 2&lt;&lt;-1 为什么不等于 0.5，前面说过，位运算的操作数只能是整型和字符型。在求 int 所能表示的最小值时，可以使用</p>\n<p>//minInt</p>\n<p>System.<em>out</em>.println(1 &lt;&lt; 31);</p>\n<p>System.<em>out</em>.println(1 &lt;&lt; -1);</p>\n<p>可以发现左移 31 位和 - 1 位所得的结果是一样的，同理，左移 30 位和左移 - 2 所得的结果也是一样的。移动一个负数位，是不是等同于右移该负数的绝对值位呢？输出一下就能发现不是的。java 中 int 所能表示的最大数值是 31 位，加上符号位共 32 位。在这里可以有这样的位移法则：</p>\n<p>法则一：任何数左移（右移）32 的倍数位等于该数本身。</p>\n<p>法则二：在位移运算 m&lt;&lt;n 的计算中，若 n 为正数，则实际移动的位数为 n%32，若 n 为负数，则实际移动的位数为 (32+n%32)，右移，同理。</p>\n<p>左移是乘以 2 的幂，对应着右移则是除以 2 的幂。</p>\n<h2 id=\"2-判断一个数n的奇偶性\"><a class=\"markdownIt-Anchor\" href=\"#2-判断一个数n的奇偶性\">#</a> 2.   判断一个数 n 的奇偶性</h2>\n<p>n&amp;1 == 1?” 奇数”:” 偶数”</p>\n<p>为什么与 1 能判断奇偶？所谓的二进制就是满 2 进 1，那么好了，偶数的最低位肯定是 0（恰好满 2，对不对？），同理，奇数的最低位肯定是 1.int 类型的 1，前 31 位都是 0，无论是 1&amp;0 还是 0&amp;0 结果都是 0，那么有区别的就是 1 的最低位上的 1 了，若 n 的二进制最低位是 1（奇数）与上 1，结果为 1，反则结果为 0.</p>\n<h2 id=\"3-不用临时变量交换两个数\"><a class=\"markdownIt-Anchor\" href=\"#3-不用临时变量交换两个数\">#</a> 3.   不用临时变量交换两个数</h2>\n<p>在 int [] 数组首尾互换中，是不看到过这样的代码：</p>\n<figure class=\"highlight\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> </span><br></pre></td></tr></tbody></table></figure>\n<ol>\n<li><code>public static int[] reverse(int[] nums){</code></li>\n<li><code>int i = 0;</code></li>\n<li><code>int j = nums.length-1;</code></li>\n<li><code>while(j&gt;i){</code></li>\n<li><code>nums[i]= nums[i]^nums[j];</code></li>\n<li><code>nums[j] = nums[j]^nums[i];</code></li>\n<li><code>nums[i] = nums[i]^nums[j];</code></li>\n<li><code>j--;</code></li>\n<li><code>i++;</code></li>\n<li><code>}</code></li>\n<li><code>return nums;</code></li>\n<li><code>}</code></li>\n</ol>\n<p>连续三次使用异或，并没有临时变量就完成了两个数字交换，怎么实现的呢？</p>\n<p><img src=\"/p/7670a0f/index.htmlCenter-20211229200705072.png\" alt=\"img\"></p>\n<p>上面的计算主要遵循了一个计算公式：b<sup>(a</sup>b)=a。</p>\n<p>我们可以对以上公式做如下的推导：</p>\n<p>任何数异或本身结果为 0. 且有定理 a<sup>b=b</sup>a。异或是一个无顺序的运算符，则 b<sup>a</sup>b=b<sup>b</sup>a，结果为 0^a。</p>\n<p>再次列出异或的计算表:</p>\n<table>\n<thead>\n<tr>\n<th>操作数 1</th>\n<th>0</th>\n<th>0</th>\n<th>1</th>\n<th>1</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>操作数 2</td>\n<td>0</td>\n<td>1</td>\n<td>0</td>\n<td>1</td>\n</tr>\n<tr>\n<td>按位异或</td>\n<td>0</td>\n<td>1</td>\n<td>1</td>\n<td>0</td>\n</tr>\n</tbody>\n</table>\n<p>可以发现，异或 0 具有保持的特点，而异或 1 具有翻转的特点。使用这些特点可以进行取数的操作。</p>\n<p>​     那么 0^a，使用异或 0 具有保持的特点，最终结果就是 a。</p>\n<p>其实 java 中的异或运算法则完全遵守数学中的计算法则：</p>\n<p>①  a ^ a =0</p>\n<p>②  a ^ b =b ^ a</p>\n<p>③  a ^b ^ c = a ^ (b ^ c) = (a ^ b) ^ c;</p>\n<p>④  d = a ^b ^ c 可以推出 a = d ^ b ^ c.</p>\n<p>⑤  a ^ b ^a = b.</p>\n<h2 id=\"4-取绝对值\"><a class=\"markdownIt-Anchor\" href=\"#4-取绝对值\">#</a> 4.   取绝对值</h2>\n<p>(a^(a&gt;&gt;31))-(a&gt;&gt;31)</p>\n<p>先整理一下使用位运算取绝对值的思路：若 a 为正数，则不变，需要用异或 0 保持的特点；若 a 为负数，则其补码为源码翻转每一位后 + 1，先求其源码，补码 - 1 后再翻转每一位，此时需要使用异或 1 具有翻转的特点。</p>\n<p>任何正数右移 31 后只剩符号位 0，最终结果为 0，任何负数右移 31 后也只剩符号位 1，溢出的 31 位截断，空出的 31 位补符号位 1，最终结果为 - 1. 右移 31 操作可以取得任何整数的符号位。</p>\n<p>那么综合上面的步骤，可得到公式。a&gt;&gt;31 取得 a 的符号，若 a 为正数，a&gt;&gt;31 等于 0，a^0=a，不变；若 a 为负数，a&gt;&gt;31 等于 - 1 ，a^-1 翻转每一位.</p>\n</body></html>","raw":null,"categories":[],"tags":[{"name":"Java","path":"api/tags/Java.json"},{"name":"位运算","path":"api/tags/位运算.json"}]},{"title":"夜中云谷","slug":"sz-tiananyungu","date":"2021-12-18T13:06:30.000Z","updated":"2023-04-30T03:57:46.483Z","comments":null,"realpath":null,"path":"api/articles/sz-tiananyungu.json","excerpt":"","keywords":"深圳,天安云谷","cover":"/p/b10a7a0e/IMG_0119.jpg","content":"<html><head></head><body><p><img src=\"/p/b10a7a0e/index.htmlIMG_0119.jpg\" alt=\"IMG_0119\"></p>\n</body></html>","raw":null,"categories":[],"tags":[{"name":"夜景","path":"api/tags/夜景.json"},{"name":"图记","path":"api/tags/图记.json"},{"name":"天安云谷","path":"api/tags/天安云谷.json"}]}]}