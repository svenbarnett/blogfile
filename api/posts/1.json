{"total":32,"pageSize":10,"pageCount":4,"data":[{"title":"从Apollo动态配置原理学Spring(二)","slug":"20230226","date":"2023-02-26T12:39:24.000Z","updated":"2023-03-12T14:09:38.928Z","comments":null,"realpath":null,"path":"api/articles/20230226.json","excerpt":"Apollo 动态配置其实本质就是利用 Spring Bean 的生命周期的扩展点，这个扩展点超级多，不可能全部列出来，只说核心的扩展点。这也就是为什么 Spring 的扩展性很好的原因，开了很多的口子，尽可能让某个功能高内聚松耦合，用户需要哪个功能就用哪个，而不是直接来一个大而全的东西。我们先通过学习核心的，然后后续对照 Apollo 用到了哪些再对照，就会发现很多地方就能理解的很好了","keywords":"Spring生命周期","cover":"/p/4c633c0c/20210707002134280.png","content":"<blockquote>\n<p>Apollo 动态配置其实本质就是利用 Spring Bean 的生命周期的扩展点，这个扩展点超级多，不可能全部列出来，只说核心的扩展点。这也就是为什么 Spring 的扩展性很好的原因，开了很多的口子，尽可能让某个功能高内聚松耦合，用户需要哪个功能就用哪个，而不是直接来一个大而全的东西。</p>\n</blockquote>\n<p>我们先通过学习核心的，然后后续对照 Apollo 用到了哪些再对照，就会发现很多地方就能理解的很好了</p>\n<span id=\"more\"></span>\n<p><strong>什么是 Spring Bean 的生命周期</strong></p>\n<p>对于普通的 Java 对象，当 new 的时候创建对象，然后该对象就能够使用了。一旦该对象不再被使用，则由 Java 自动进行垃圾回收。</p>\n<p>而 Spring 中的对象是 bean，bean 和普通的 Java 对象没啥大的区别，只不过 Spring 不再自己去 new 对象了，而是由 IoC 容器去帮助我们实例化对象并且管理它，我们需要哪个对象，去问 IoC 容器要即可。IoC 其实就是解决对象之间的耦合问题，Spring Bean 的生命周期完全由容器控制。</p>\n<h2 id=\"spring-bean-的生命周期\"><a class=\"markdownIt-Anchor\" href=\"#spring-bean-的生命周期\">#</a> Spring Bean 的生命周期</h2>\n<p>这里要提一下，这里我们说的 Spring Bean 的生命周期主要指的是 singleton bean，对于 prototype 的 bean ，Spring 在创建好交给使用者之后则不会再管理后续的生命周期。</p>\n<p>我们也来复习下 Spring 中的 bean 的作用域有哪些？</p>\n<ul>\n<li><code>singleton</code>  : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。</li>\n<li><code>prototype</code>  : 每次请求都会创建一个新的 bean 实例。</li>\n<li><code>request</code>  : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。</li>\n<li><code>session</code>  : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。</li>\n<li><code>global-session</code> ： 全局 session 作用域，仅仅在基于 Portlet 的 web 应用中才有意义，Spring5 已经没有了。Portlet 是能够生成语义代码（例如：HTML）片段的小型 Java Web 插件。它们基于 portlet 容器，可以像 servlet 一样处理 HTTP 请求。但是，与 servlet 不同，每个 portlet 都有不同的会话。</li>\n</ul>\n<p>我们知道对于普通的 Java 对象来说，它们的生命周期就是：</p>\n<ul>\n<li>实例化</li>\n<li>该对象不再被使用时通过垃圾回收机制进行回收</li>\n</ul>\n<p>而对于 Spring Bean 的生命周期来说：</p>\n<ul>\n<li>实例化 Instantiation</li>\n<li>属性赋值 Populate</li>\n<li>初始化 Initialization</li>\n<li>销毁 Destruction</li>\n</ul>\n<p>实例化 -&gt; 属性赋值 -&gt; 初始化 -&gt; 销毁</p>\n<p>只有四个步骤，这样拆解的话是不是感觉也不难？不像其他人写的那样直接一上来就各种 BeanPostProcessor、BeanFactoryPostProcessor 全部怼进流程里去，别说读者看着头大，自己写的可能短时间内还记得流程，隔个一段时间，你可能都不知道自己写了个啥。</p>\n<p>通过 Bean 创建流程入口 <code>AbstractApplicationContext#refresh()</code>  方法的  <code>finishBeanFactoryInitialization(beanFactory)</code>  处带大家跟一下源码，想了想还是不带入过多的代码进来，直接给到最终的主要逻辑。</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\"data-rel=\"JAVA\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> Object <span class=\"title function_\">doCreateBean</span><span class=\"params\">(String beanName, RootBeanDefinition mbd, <span class=\"meta\">@Nullable</span> Object[] args)</span> <span class=\"keyword\">throws</span> BeanCreationException &#123;</span><br><span class=\"line\">    <span class=\"type\">BeanWrapper</span> <span class=\"variable\">instanceWrapper</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mbd.isSingleton()) &#123;</span><br><span class=\"line\">        instanceWrapper = (BeanWrapper)<span class=\"built_in\">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instanceWrapper == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 实例化阶段</span></span><br><span class=\"line\">        instanceWrapper = <span class=\"built_in\">this</span>.createBeanInstance(beanName, mbd, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"type\">Object</span> <span class=\"variable\">exposedObject</span> <span class=\"operator\">=</span> bean;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 属性赋值阶段</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.populateBean(beanName, mbd, instanceWrapper);</span><br><span class=\"line\">        <span class=\"comment\">// 初始化阶段</span></span><br><span class=\"line\">        exposedObject = <span class=\"built_in\">this</span>.initializeBean(beanName, exposedObject, mbd);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable var18) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<p>至于销毁，是在容器关闭时调用的，详见  <code>ConfigurableApplicationContext#close()</code></p>\n<p>是不是很清爽了？至于 BeanPostProcessor、BeanFactoryPostProcessor 以及其他的类，只不过是对主流程四个步骤的一系列扩展点而已。</p>\n<h2 id=\"spring-bean-的生命周期的扩展点\"><a class=\"markdownIt-Anchor\" href=\"#spring-bean-的生命周期的扩展点\">#</a> Spring Bean 的生命周期的扩展点</h2>\n<p>Spring Bean 的生命周期的扩展点超级多，老周这里不可能全部列出来，只说核心的扩展点。这也就是为什么 Spring 的扩展性很好的原因，开了很多的口子，尽可能让某个功能高内聚松耦合，用户需要哪个功能就用哪个，而不是直接来一个大而全的东西。</p>\n<p><strong>Bean 自身的方法</strong></p>\n<p>比如构造函数、getter/setter 以及 init-method 和 destory-method 所指定的方法等，也就对应着上文说的实例化 -&gt; 属性赋值 -&gt; 初始化 -&gt; 销毁四个阶段。</p>\n<p><img src=\"/p/4c633c0c/20210707002134280.png\" alt=\"阶段示意图\"></p>\n<p><strong>容器级的方法（BeanPostProcessor 一系列接口）</strong></p>\n<p>主要是后处理器方法，比如下图的  <code>InstantiationAwareBeanPostProcessor</code> 、 <code>BeanPostProcessor</code>  接口方法。这些接口的实现类是独立于 Bean 的，并且会注册到 Spring 容器中。在 Spring 容器创建任何 Bean 的时候，这些后处理器都会发生作用。</p>\n<p><img src=\"/p/4c633c0c/20210707225212729.png\" alt=\"扩展点\"></p>\n<p><strong>InstantiationAwareBeanPostProcessor 源码分析</strong></p>\n<p>我们翻一下源码发现 InstantiationAwareBeanPostProcessor 是继承了 BeanPostProcessor</p>\n<p><img src=\"/p/4c633c0c/20210707230505579.png\" alt=\"InstantiationAwareBeanPostProcessor \"></p>\n<p><img src=\"/p/4c633c0c/20210707230919307.png\" alt=\"BeanPostProcessor\"></p>\n<ul>\n<li><code>InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation</code>  调用点</li>\n</ul>\n<blockquote>\n<p>Object postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName)<br>\n 返回值：如果返回的不为 null，那么后续的 Bean 的创建流程【实例化、初始化 afterProperties】都不会执行，而是直接使用返回的快捷 Bean，此时的正常执行顺序如下：<br>\nInstantiationAwareBeanPostProcessor 接口中的 postProcessBeforeInstantiation，在实例化之前调用。<br>\nBeanPostProcessor 接口中的 postProcessAfterInitialization，在实例化之后调用。</p>\n</blockquote>\n<p><img src=\"https://img-blog.csdnimg.cn/20210707233026943.png\" alt=\"createbean\"></p>\n<p><img src=\"/p/4c633c0c/20210707235533784.png\" alt=\"resolveBeforeInstantiation\"></p>\n<p><img src=\"/p/4c633c0c/20210708000228655.png\" alt=\"applyBean\"></p>\n<p>总之，postProcessBeforeInstantiation 在 doCreateBean 之前调用，也就是在 bean 实例化之前调用的，英文源码注释解释道该方法的返回值会替换原本的 Bean 作为代理，这也是 <a href=\"https://so.csdn.net/so/search?q=AOP&amp;spm=1001.2101.3001.7020\">AOP</a> 等功能实现的关键点。</p>\n<ul>\n<li><code>InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation</code>  调用点</li>\n</ul>\n<blockquote>\n<p>boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException<br>\n 正常情况下在实例化之后在执行 populateBean 之前调用<br>\n返回值：如果有指定的 bean 的时候返回 false，那么后续的属性填充和属性依赖注入【populateBean】将不会执行，同时后续的 postProcessPropertyValues 将不会执行，但是初始化和 BeanPostProcessor 的仍然会执行。</p>\n</blockquote>\n<p><img src=\"/p/4c633c0c/20210708005050274.png\" alt=\"populateBean\"></p>\n<p>public PropertyValues postProcessPropertyValues(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)<br>\n 实例化之后调用，在方法 applyPropertyValues【属性填充】之前<br>\n返回值：如果返回 null，那么将不会进行后续的属性填充，比如依赖注入等，如果返回的 pvs 额外的添加了属性，那么后续会填充到该类对应的属性中。<br>\npvs：PropertyValues 对象，用于封装指定类的对象，简单来说就是 PropertyValue 的集合，里面相当于以 key-value 形式存放类的属性和值。<br>\npds：PropertyDescriptor 对象数组，PropertyDescriptor 相当于存储类的属性，不过可以调用 set，get 方法设置和获取对应属性的值。</p>\n<p><img src=\"/p/4c633c0c/20210708010057366.png\" alt=\"postProcessPropertyValues\"></p>\n<p><strong>BeanPostProcessor 源码分析</strong></p>\n<blockquote>\n<p>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#doCreateBean</p>\n</blockquote>\n<p><img src=\"/p/4c633c0c/20210708232740951.png\" alt=\"在这里插入图片描述\"><br>\n进入初始化接口：</p>\n<p><img src=\"/p/4c633c0c/20210708233139731.png\" alt=\"在这里插入图片描述\"><br>\n我们先来看</p>\n<blockquote>\n<p>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#applyBeanPostProcessorsBeforeInitialization</p>\n</blockquote>\n<p><img src=\"/p/4c633c0c/20210708233742525.png\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li>首先获取到所有的后置处理器 getBeanPostProcessors ()</li>\n<li>在 for 循环中依次调用后置处理器的方法  <code>processor.postProcessBeforeInitialization(result, beanName);</code></li>\n<li>进入 postProcessBeforeInitialization 方法</li>\n</ul>\n<blockquote>\n<p>org.springframework.context.support.ApplicationContextAwareProcessor#postProcessBeforeInitialization</p>\n</blockquote>\n<p><img src=\"/p/4c633c0c/20210708234443215.png\" alt=\"在这里插入图片描述\"></p>\n<p>进入  <code>invokeAwareInterfaces(bean);</code>  方法，当前 bean 实现了 ApplicationContextAware 接口。</p>\n<p><img src=\"/p/4c633c0c/20210708234639952.png\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li><code>ApplicationContextAwareProcessor#postProcessBeforeInitialization</code>  首先判断此 bean 是不是各种的 Aware，如果是它列举的那几个 Aware 就获取 Bean 工厂的权限，可以向容器中导入相关的上下文环境，目的是为了 Bean 实例能够获取到相关的上下文，如果不是它列举的几个 Aware，那就调用  <code>invokeAwareInterfaces(bean)</code> ，向容器中添加相关接口的上下文环境。</li>\n</ul>\n<p><strong>3.3 工厂后处理器方法（BeanFactoryProcessor 一系列接口）</strong></p>\n<p>包括  <code>AspectJWeavingEnabler</code> 、 <code>CustomAutowireConfigurer</code> 、 <code>ConfigurationClassPostProcessor</code>  等。这些都是 Spring 框架中已经实现好的 BeanFactoryPostProcessor，用来实现某些特定的功能。</p>\n<p>我们知道 Spring IoC 容器初始化的关键环节就在  <code>org.springframework.context.support.AbstractApplicationContext#refresh</code>  方法中 ，容器创建的主体流程都在这个方法里面，这个方法是真的重要！！！</p>\n<p>对于工厂后处理器方法老周这里直接带你看  <code>invokeBeanFactoryPostProcessors(beanFactory);</code>  方法，这个方法处理的是  <code>BeanFactoryPostProcessor</code>  接口的 Bean。调用方法如下：</p>\n<p><img src=\"/p/4c633c0c/20210709231013239.png\" alt=\"在这里插入图片描述\"><br>\n跟到最重要的方法里去，代码虽长，但逻辑中规中矩。</p>\n<p><code>BeanFactoryPostProcessor</code> ：一切处理 BeanFactory 的父接口<br>\n <code>BeanDefinitionRegistryPostProcessor</code> ：实现了 BeanFactoryPostProcessor 接口的接口</p>\n<p><img src=\"/p/4c633c0c/20210709233225102.png\" alt=\"在这里插入图片描述\"><br>\n流程说明：</p>\n<ul>\n<li>调用 BeanDefinitionRegistryPostProcessor#postProcessBeanDefinitionRegistry (registry) 方法。参数 beanFactoryPostProcessors 传入的优先处理掉。然后获取容器注册的，对于这些 Bean 按照 PriorityOrdered 接口、Ordered、没有排序接口的实例分别进行处理。</li>\n<li>调用 BeanFactoryPostProcessor#postProcessBeanFactory (beanFactory) 方法。备注：BeanDefinitionRegistryPostProcessor 属于 BeanFactoryPostProcessor 子接口。先处理属于 BeanDefinitionRegistryPostProcessor 接口实例的 postProcessBeanFactory (beanFactory) 方法，然后获取容器注册的。对于这些 Bean 按照 PriorityOrdered 接口、Ordered、没有排序接口的实例分别进行处理。</li>\n</ul>\n","raw":null,"categories":[{"name":"Java","path":"api/categories/Java.json"}],"tags":[{"name":"Apollo","path":"api/tags/Apollo.json"},{"name":"Spring","path":"api/tags/Spring.json"}]},{"title":"从Apollo动态配置原理学Spring(一)","slug":"20230223","date":"2023-02-23T14:29:54.000Z","updated":"2023-03-12T14:09:38.924Z","comments":null,"realpath":null,"path":"api/articles/20230223.json","excerpt":"最近工作碰到需要写一个类似携程 Apollo 的动态配置功能，以此系统学习该原理，熟练掌握下 Spring 的各种机制Apollo 动态配置原理简述Apollo 配置中心动态生效机制，是基于 Http 长轮询请求和 Spring 扩展机制实现的，在 Spring 容器启动过程中，Apollo 通过自定义的 BeanPostProcessor  和 BeanFactoryPostProcessor  將参数中包含 $&#123;…&#125;  占位符和 @Value  注解的 Bean 注册到 Apollo 框架中定义的注册表中。然后通过 Http 长轮询不断的去获取服务端的配置信息，一旦配置发生变化，Apollo 会根据变化的配置的 Key 找到对应的 Bean，然后修改 Bean 的属性，从而实现了配置动态生效的特性。需要注意的是，Apollo 在配置变化后，只能修改 Bean 的属性，例如我们数据源的属性发生变化，新创建的 Connection 对象是没问题的，但是连接池中已经创建的 Connection 对象相关信息是不能动态修改的，所以依然需要重启应用。","keywords":"Apollo,Spring,动态配置","cover":"/p/e352a76e/image-20230223224050610.png","content":"<blockquote>\n<p>最近工作碰到需要写一个类似携程 Apollo 的动态配置功能，以此系统学习该原理，熟练掌握下 Spring 的各种机制</p>\n</blockquote>\n<p><strong>Apollo 动态配置原理简述</strong></p>\n<p>Apollo 配置中心动态生效机制，是基于 Http 长轮询请求和 Spring 扩展机制实现的，在 Spring 容器启动过程中，Apollo 通过自定义的 <code>BeanPostProcessor</code>  和 <code>BeanFactoryPostProcessor</code>  將参数中包含 <code>$&#123;…&#125;</code>  占位符和 <code>@Value</code>  注解的 Bean 注册到 Apollo 框架中定义的注册表中。然后通过 Http 长轮询不断的去获取服务端的配置信息，一旦配置发生变化，Apollo 会根据变化的配置的 Key 找到对应的 Bean，然后修改 Bean 的属性，从而实现了配置动态生效的特性。</p>\n<p>需要注意的是，Apollo 在配置变化后，只能修改 Bean 的属性，例如我们数据源的属性发生变化，新创建的 Connection 对象是没问题的，但是连接池中已经创建的 Connection 对象相关信息是不能动态修改的，所以依然需要重启应用。</p>\n<span id=\"more\"></span>\n<p>其中涉及到的 Spring 的扩展机制有：</p>\n<ul>\n<li>BeanFactoryPostProcessor</li>\n<li>BeanPostProcessor</li>\n<li>BeanDefinitionRegistry</li>\n<li>PropertySource</li>\n<li>ImportBeanDefinitionRegistrar</li>\n<li>PropertySourcesPlaceholderConfigurer</li>\n</ul>\n<p>…</p>\n<p>其中每一个都是非常关键的点，我们后续会一一进行学习。</p>\n<h2 id=\"apollo启动过程\"><a class=\"markdownIt-Anchor\" href=\"#apollo启动过程\">#</a> Apollo 启动过程</h2>\n<p>首先，我们先看一张图：</p>\n<p><img src=\"/p/e352a76e/image-20230223224050610.png\" alt=\"Apollo启动图\"></p>\n<ol>\n<li>\n<p>Spring 启动，扫描 bean，将相关变量参数注册到 Apollo 属性注册表</p>\n</li>\n<li>\n<p>通过 RemoteConfigRepository 获取配置，持久化本地，后续读取从本地读取，通过 <code>PropertySourcesProcessor</code>  执行如下步骤</p>\n</li>\n</ol>\n<p>（1）根据命名空间从配置中心获取配置信息，创建 RemoteConfigRepository 和 LocalFileConfigRepository 对象。RemoteConfigRepository 表示远程配置中心资源，LocalFileConfigRepository 表示本地缓存配置资源。</p>\n<p>（2）LocalFileConfigRepository 对象缓存配置信息到 C:\\opt\\data 或者 /opt/data 目录</p>\n<p>（3）RemoteConfigRepository 开启 HTTP 长轮询请求定时任务，默认 2s 请求一次。</p>\n<p>（4）將本地缓存配置信息转换为 PropertySource 对象（Apollo 自定义了 Spring 的 PropertySource），加载到 Spring 的 Environment 对象中。至此静态配置就已经加入到环境变量中</p>\n<p>（5）將自定义的 ConfigPropertySource 注册为观察者。一旦 RemoteConfigRepository 发现远程配置中心信息发生变化，ConfigPropertySource 对象会得到通知。</p>\n<ol start=\"3\">\n<li>\n<p>通过一个自定义监听器，监听对应事件</p>\n</li>\n<li>\n<p>后续通过长轮询请求监听到配置变化，根据配置读取注册表里面的 key 和对应的 bean，通过反射修改 bean 对应属性值</p>\n</li>\n</ol>\n<h2 id=\"apollo扩展点\"><a class=\"markdownIt-Anchor\" href=\"#apollo扩展点\">#</a> Apollo 扩展点</h2>\n<ol>\n<li><code>PropertySourcesProcessor</code>  初始化 Apollo 配置、接入 Spring environment，初始化 Apollo 监听器</li>\n<li><code>ApolloAnnotationProcessor</code>  提供 Apollo 一些注解支持 <code>@ApolloConfig</code> ， <code>@ApolloConfigChangeListener</code></li>\n<li><code>SpringValueProcessor</code>  提供对 <code>@Value</code>  动态生效能力 针对实例 bean</li>\n<li><code>SpringValueDefinitionProcessor</code>  提供对 <code>@Value</code>  动态生效能力 针对 bean 定义</li>\n<li><code>ApolloJsonValueProcessor</code>  提供对 <code>@ApolloJsonValue</code>  支持</li>\n</ol>\n<p>上述分别对应使用 Spring 的扩展能力 <code>BeanFactoryPostProcessor</code> 、 <code>BeanPostProcessor</code> 、 <code>BeanPostProcessor</code>  和 <code>BeanFactoryPostProcessor</code> 、 <code>BeanDefinitionRegistryPostProcessor</code> 、 <code>BeanPostProcessor</code></p>\n<p>我们这个系列也会对 apollo 基于 spring 提供的扩展点来嵌入自己的能力。主要为 BeanFactoryPostProcessor、BeanPostProcessor 这两个扩展点；先简单说一下：<em><strong>只需要知道，BeanFactoryPostProcessor、BeanDefinitionRegistryPostProcessor 在生成所有 beandefinition 之后调用，而 BeanPostProcessor 在通过 beandefinition 实例化 bean 的过程中调用即可。</strong></em></p>\n<p>那这些实现我们就下篇见了！！！</p>\n","raw":null,"categories":[{"name":"Java","path":"api/categories/Java.json"}],"tags":[{"name":"Apollo","path":"api/tags/Apollo.json"},{"name":"Spring","path":"api/tags/Spring.json"},{"name":"动态配置","path":"api/tags/动态配置.json"}]},{"title":"QQ上线了24周年注册全球排名这个活动","slug":"20230210","date":"2023-02-10T12:58:50.000Z","updated":"2023-03-12T14:09:38.924Z","comments":null,"realpath":null,"path":"api/articles/20230210.json","excerpt":"2023 年 2 月 10 日是 QQ24 周年的日子，在这天 QQ 上线了 24 周年注册全球排名这个活动，玩家可以在这里看到自己是什么时候创建的账号，并且还可以看到自己的排名信息哦。","keywords":"QQ,注册时间","cover":"/p/75466bf9/20230210161435_71813.jpg","content":"<p>2023 年 2 月 10 日是 QQ24 周年的日子，在这天 QQ 上线了 24 周年注册全球排名这个活动，玩家可以在这里看到自己是什么时候创建的账号，并且还可以看到自己的排名信息哦。</p>\n<span id=\"more\"></span>\n<p><img src=\"/p/75466bf9/20230210161435_71813.jpg\" alt=\"QQ\"></p>\n<h3 id=\"qq24周年全球排名查看攻略\"><a class=\"markdownIt-Anchor\" href=\"#qq24周年全球排名查看攻略\">#</a> QQ24 周年全球排名查看攻略</h3>\n<p>这个活动的查看有着两种方式，分别如下：</p>\n<p>1、点击链接（<strong>24 周年全球排名网址 &gt;&gt;</strong><a href=\"https://ti.qq.com/open_qq/newIndex.html?url=https%3A%2F%2Fti.qq.com%2Fact%2Fqq24th%2Findex.html%3F_wv%3D16777219%26_wwv%3D128%26source%3D2\"> 点击查看</a>）</p>\n<p>点击上方的 24 周年全球排名网址链接，这个会直接唤起 qq。</p>\n<p>点击立即查看我们就可以看到自己的排名，需要同意协议。</p>\n<p>下面是我的排名：</p>\n<p><img src=\"/p/75466bf9/IMG_0057.JPG\" alt=\"IMG_0057\"></p>\n","raw":null,"categories":[],"tags":[{"name":"QQ","path":"api/tags/QQ.json"},{"name":"那些年","path":"api/tags/那些年.json"}]},{"title":"元宵节，放了烟花","slug":"20230208","date":"2023-02-08T14:29:06.000Z","updated":"2023-03-12T14:09:38.920Z","comments":null,"realpath":null,"path":"api/articles/20230208.json","excerpt":"烟花又称 [花炮]、烟火、焰火、[炮仗]，根据《中国 [烟花爆竹] 标准 — 安全与质量》对烟花爆竹的定义为：以烟火药为原料，用于产生声光色的娱乐用品。中国劳动人民较早发明，常用于盛大的典礼或表演中。烟花其实和爆竹的结构类似，其结构都包含黑 [火药] 和药引。为了达到好的表演效果，[焰火] 和 [礼花弹] 中填充了大量用于发射以及爆炸的火药，例如，一个直径为 20 厘米的礼花弹在发射后，要上升到大概 200 米的高空才会爆炸，而这些星星点点覆盖的 [半径] 大约可以有 80 米左右。","keywords":"烟花,元宵节","cover":"/p/277fd0ba/IMG_0698_1.jpeg","content":"<p>烟花又称 [花炮]、烟火、焰火、[炮仗]，根据《中国 [烟花爆竹] 标准 — 安全与质量》对烟花爆竹的定义为：以烟火药为原料，用于产生声光色的娱乐用品。中国劳动人民较早发明，常用于盛大的典礼或表演中。</p>\n<p>烟花其实和爆竹的结构类似，其结构都包含黑 [火药] 和药引。为了达到好的表演效果，[焰火] 和 [礼花弹] 中填充了大量用于发射以及爆炸的火药，例如，一个直径为 20 厘米的礼花弹在发射后，要上升到大概 200 米的高空才会爆炸，而这些星星点点覆盖的 [半径] 大约可以有 80 米左右。</p>\n<span id=\"more\"></span>\n<p><img src=\"/p/277fd0ba/IMG_0698_1.jpeg\" alt=\"小区放烟花\"></p>\n<p>醴陵花炮起源最早可上溯至唐代，已经有着上千年的历史，以产地醴陵而被概括命名。当地是烟花的发祥地，也是花炮祖师李畋的故乡，被誉为名副其实的 “花炮之乡”。</p>\n<p>浏阳花炮，湖南省浏阳市特产，中国国家地理标志产品。<br>\n浏阳市是世界著名的花炮之乡。浏阳花炮造型美观，色彩鲜艳，质量可靠，素有 “浏阳花炮震天下” 的美名。2002 年 10 月，在浏阳闭幕的首届国际花炮合作与贸易大会上，浏阳成为国际花炮协会总部永久所在地。2007 年，“浏阳花炮” 被正式认定为中国驰名商标。 [3]<br>\n 2003 年 03 月 06 日，原国家质检总局批准对 “浏阳花炮” 实施地理标志产品保护。</p>\n<p>作为醴陵人，说实话，浏阳花炮的科技量要比醴陵花炮高，这几年醴陵也在紧追猛赶！加油！</p>\n","raw":null,"categories":[],"tags":[{"name":"烟花","path":"api/tags/烟花.json"},{"name":"元宵节","path":"api/tags/元宵节.json"}]},{"title":"2023兔年春节","slug":"20230204","date":"2023-02-04T07:27:08.000Z","updated":"2023-03-12T14:09:38.800Z","comments":null,"realpath":null,"path":"api/articles/20230204.json","excerpt":"# 1. 春节年前，家县城进行烟花表演： [Figure] 估计是增加了延迟拍摄","keywords":"春节,过年,合照,堵车","cover":"/p/ebb8427d/IMG_0650.PNG","content":"<h3 id=\"1-春节年前家县城进行烟花表演\"><a class=\"markdownIt-Anchor\" href=\"#1-春节年前家县城进行烟花表演\">#</a> 1. 春节年前，家县城进行烟花表演：</h3>\n<p><img src=\"/p/ebb8427d/IMG_0650.PNG\" alt=\"烟花表演1\"></p>\n<p>估计是增加了延迟拍摄</p>\n<span id=\"more\"></span>\n<p><img src=\"/p/ebb8427d/IMG_0651.PNG\" alt=\"烟花表演2\"></p>\n<p><img src=\"/p/ebb8427d/IMG_0652.PNG\" alt=\"烟花表演3\"></p>\n<p>还是得加滤镜啊</p>\n<p><img src=\"/p/ebb8427d/IMG_0653.PNG\" alt=\"烟花表演4\"></p>\n<h3 id=\"2-大伯家客厅搞了个灯\"><a class=\"markdownIt-Anchor\" href=\"#2-大伯家客厅搞了个灯\">#</a> 2. 大伯家客厅搞了个 “灯”</h3>\n<p><img src=\"/p/ebb8427d/IMG_0656.JPG\" alt=\"大伯家的“灯”\"></p>\n<h3 id=\"3-玩游戏的小外甥\"><a class=\"markdownIt-Anchor\" href=\"#3-玩游戏的小外甥\">#</a> 3. 玩游戏的小外甥</h3>\n<p><img src=\"/p/ebb8427d/IMG_0657.jpg\" alt=\"认真玩游戏\"></p>\n<h3 id=\"4-外婆家合照\"><a class=\"markdownIt-Anchor\" href=\"#4-外婆家合照\">#</a> 4. 外婆家合照</h3>\n<p><img src=\"/p/ebb8427d/IMG_0681.jpg\" alt=\"外婆家合照\"></p>\n<h3 id=\"5-老表们\"><a class=\"markdownIt-Anchor\" href=\"#5-老表们\">#</a> 5. 老表们</h3>\n<p><img src=\"/p/ebb8427d/IMG_1794.jpg\" alt=\"我和老表们\"></p>\n<h3 id=\"6-主公我是忠臣\"><a class=\"markdownIt-Anchor\" href=\"#6-主公我是忠臣\">#</a> 6. 主公，我是忠臣</h3>\n<p>特别说明：服务员也太不走心，少拍了一个人都说挺好，那个人是 “望叔”，给望叔郑重道歉！</p>\n<p><img src=\"/p/ebb8427d/IMG_0690.JPG\" alt=\"同学聚合照\"></p>\n<h3 id=\"7-王家码头\"><a class=\"markdownIt-Anchor\" href=\"#7-王家码头\">#</a> 7. 王家码头</h3>\n<p><img src=\"/p/ebb8427d/IMG_0691.JPG\" alt=\"王家码头\"></p>\n<h3 id=\"8-家族祠堂\"><a class=\"markdownIt-Anchor\" href=\"#8-家族祠堂\">#</a> 8. 家族祠堂</h3>\n<p><img src=\"/p/ebb8427d/IMG_0692.JPG\" alt=\"祠堂\"></p>\n<h3 id=\"9-返程堵车\"><a class=\"markdownIt-Anchor\" href=\"#9-返程堵车\">#</a> 9. 返程堵车</h3>\n<p>原本的 12h 变成 20 多小时，真是辛苦司机了。</p>\n<p><img src=\"/p/ebb8427d/IMG_0694.JPG\" alt=\"堵车\"></p>\n","raw":null,"categories":[{"name":"杂记","path":"api/categories/杂记.json"}],"tags":[{"name":"春节","path":"api/tags/春节.json"}]},{"title":"室友“羊”了","slug":"20221219","date":"2022-12-19T12:46:23.000Z","updated":"2023-03-12T14:09:38.796Z","comments":null,"realpath":null,"path":"api/articles/20221219.json","excerpt":"室友这几天不舒服，就测了，果不其然🐑了，我应该是很危险了。","keywords":"核酸,羊了","cover":"/p/850ce73f/image-20221219212509735.png","content":"<p>室友这几天不舒服，就测了，果不其然🐑了，我应该是很危险了。</p>\n<span id=\"more\"></span>\n<p><img src=\"/p/850ce73f/image-20221219212509735.png\" alt=\"抗原检测阳性\"></p>\n","raw":null,"categories":[{"name":"杂记","path":"api/categories/杂记.json"}],"tags":[{"name":"疫情","path":"api/tags/疫情.json"}]},{"title":"疫情三年，是时候结束了！","slug":"20221212","date":"2022-12-12T12:56:26.000Z","updated":"2023-03-12T14:09:38.784Z","comments":null,"realpath":null,"path":"api/articles/20221212.json","excerpt":"疫情三年，什么变化了？什么没有变化呢？疫情三年变化的是，出现了健康码、行程码、核酸检测疫情三年变化的是，到处都贴起了二维码、出行限制、经济发展滞缓","keywords":"疫情,新冠疫情,行程码,核酸检测","cover":"/p/d223f900/image-20221212210631735.png","content":"<blockquote>\n<p>疫情三年，什么变化了？什么没有变化呢？</p>\n</blockquote>\n<p>疫情三年变化的是，出现了健康码、行程码、核酸检测</p>\n<p>疫情三年变化的是，到处都贴起了二维码、出行限制、经济发展滞缓</p>\n<span id=\"more\"></span>\n<p><img src=\"/p/d223f900/image-20221212210631735.png\" alt=\"核酸检测点即将拆除\"></p>\n<p>三年疫情，突然放开，大家还是有些许不适应</p>\n<p>还是习惯的过门卡掏出手机，还是习惯每天准点测核酸</p>\n<p>三年疫情对国家也有很大冲击，国家开始发行国债，用来弥补这三年的核酸检测国家政府开支</p>\n<p>三年疫情对经济冲击夜很大，许多行业都开始收紧，业务调整，裁员潮，都开始 “过冬” 了</p>\n<p><img src=\"/p/d223f900/image-20221212210553921.png\" alt=\"行程码下线\"></p>\n<p>不变的是啥呢？</p>\n<p>唯一不变的估计是人吗？</p>\n","raw":null,"categories":[{"name":"杂记","path":"api/categories/杂记.json"}],"tags":[{"name":"疫情","path":"api/tags/疫情.json"}]},{"title":"被围绕的区域——LeetCode130","slug":"surrounded-regions","date":"2022-02-08T11:56:55.000Z","updated":"2023-03-12T14:09:39.028Z","comments":null,"realpath":null,"path":"api/articles/surrounded-regions.json","excerpt":"给你一个  m x n  的矩阵  board  ，由若干字符  'X'  和  'O'  ，找到所有被  'X'  围绕的区域，并将这些区域里所有的  'O'  用  'X'  填充。 [Figure] ","keywords":"矩阵,栈,深度遍历,广度遍历","cover":"/p/52a5c0f5/xogrid.jpg","content":"<p>给你一个  <code>m x n</code>  的矩阵  <code>board</code>  ，由若干字符  <code>'X'</code>  和  <code>'O'</code>  ，找到所有被  <code>'X'</code>  围绕的区域，并将这些区域里所有的  <code>'O'</code>  用  <code>'X'</code>  填充。</p>\n<p><img src=\"/p/52a5c0f5/xogrid.jpg\" alt=\"img\"></p>\n<span id=\"more\"></span>\n<p>示例 1</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\"data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：board = [[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;O&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;O&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;X&quot;,&quot;X&quot;]]</span><br><span class=\"line\">输出：[[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;X&quot;,&quot;X&quot;]]</span><br><span class=\"line\">解释：被围绕的区间不会存在于边界上，换句话说，任何边界上的 &#x27;O&#x27; 都不会被填充为 &#x27;X&#x27;。 任何不在边界上，或不与边界上的 &#x27;O&#x27; 相连的 &#x27;O&#x27; 最终都会被填充为 &#x27;X&#x27;。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。</span><br></pre></td></tr></table></figure></div>\n<p>示例 2</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\"data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：board = [[&quot;X&quot;]]</span><br><span class=\"line\">输出：[[&quot;X&quot;]]</span><br></pre></td></tr></table></figure></div>\n<p>提示：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\"data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">m == board.length</span><br><span class=\"line\">n == board[i].length</span><br><span class=\"line\">1 &lt;= m, n &lt;= 200</span><br><span class=\"line\">board[i][j] 为 &#x27;X&#x27; 或 &#x27;O&#x27;</span><br></pre></td></tr></table></figure></div>\n<h3 id=\"解题\"><a class=\"markdownIt-Anchor\" href=\"#解题\">#</a> 解题</h3>\n<p>写在前面<br>\n本题给定的矩阵中有三种元素：</p>\n<ul>\n<li>\n<p>字母 X；</p>\n</li>\n<li>\n<p>被字母 X 包围的字母 O；</p>\n</li>\n<li>\n<p>没有被字母 X 包围的字母 O。</p>\n</li>\n</ul>\n<p>本题要求将所有被字母 X 包围的字母 O 都变为字母 X ，但很难判断哪些 O 是被包围的，哪些 O 不是被包围的。</p>\n<p>注意到题目解释中提到： <code>任何边界上的 O 都不会被填充为 X</code> 。 我们可以想到，所有的不被包围的 O 都直接或间接与边界上的 O 相连。我们可以利用这个性质判断 O 是否在边界上，具体地说：</p>\n<ul>\n<li>对于每一个边界上的 O，我们以它为起点，标记所有与它直接或间接相连的字母 O；<br>\n最后我们遍历这个矩阵，对于每一个字母：</li>\n<li>如果该字母被标记过，则该字母为没有被字母 X 包围的字母 O，我们将其还原为字母 O；<br>\n如果该字母没有被标记过，则该字母为被字母 X 包围的字母 O，我们将其修改为字母 X。</li>\n</ul>\n<h3 id=\"方法一深度优先搜索\"><a class=\"markdownIt-Anchor\" href=\"#方法一深度优先搜索\">#</a> 方法一：深度优先搜索</h3>\n<h4 id=\"思路及解法\"><a class=\"markdownIt-Anchor\" href=\"#思路及解法\">#</a> 思路及解法</h4>\n<p>我们可以使用深度优先搜索实现标记操作。在下面的代码中，我们把标记过的字母 O 修改为字母 A。</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\"data-rel=\"JAVA\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n, m;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">solve</span><span class=\"params\">(<span class=\"type\">char</span>[][] board)</span> &#123;</span><br><span class=\"line\">        n = board.length;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        m = board[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            dfs(board, i, <span class=\"number\">0</span>);</span><br><span class=\"line\">            dfs(board, i, m - <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; m - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">            dfs(board, <span class=\"number\">0</span>, i);</span><br><span class=\"line\">            dfs(board, n - <span class=\"number\">1</span>, i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; m; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (board[i][j] == <span class=\"string\">&#x27;A&#x27;</span>) &#123;</span><br><span class=\"line\">                    board[i][j] = <span class=\"string\">&#x27;O&#x27;</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (board[i][j] == <span class=\"string\">&#x27;O&#x27;</span>) &#123;</span><br><span class=\"line\">                    board[i][j] = <span class=\"string\">&#x27;X&#x27;</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">dfs</span><span class=\"params\">(<span class=\"type\">char</span>[][] board, <span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x &lt; <span class=\"number\">0</span> || x &gt;= n || y &lt; <span class=\"number\">0</span> || y &gt;= m || board[x][y] != <span class=\"string\">&#x27;O&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        board[x][y] = <span class=\"string\">&#x27;A&#x27;</span>;</span><br><span class=\"line\">        dfs(board, x + <span class=\"number\">1</span>, y);</span><br><span class=\"line\">        dfs(board, x - <span class=\"number\">1</span>, y);</span><br><span class=\"line\">        dfs(board, x, y + <span class=\"number\">1</span>);</span><br><span class=\"line\">        dfs(board, x, y - <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<h4 id=\"复杂度分析\"><a class=\"markdownIt-Anchor\" href=\"#复杂度分析\">#</a> 复杂度分析</h4>\n<ul>\n<li>\n<p>时间复杂度： <code>O(n×m)</code> ，其中  <code>n</code>  和  <code>m </code> 分别为矩阵的行数和列数。深度优先搜索过程中，每一个点至多只会被标记一次。</p>\n</li>\n<li>\n<p>空间复杂度： <code>O(n×m)</code> ，其中  <code>n</code>  和  <code>m</code>  分别为矩阵的行数和列数。主要为深度优先搜索的栈的开销。</p>\n</li>\n</ul>\n<h3 id=\"方法二广度优先搜索\"><a class=\"markdownIt-Anchor\" href=\"#方法二广度优先搜索\">#</a> 方法二：广度优先搜索</h3>\n<h4 id=\"思路及解法-2\"><a class=\"markdownIt-Anchor\" href=\"#思路及解法-2\">#</a> 思路及解法</h4>\n<p>我们可以使用广度优先搜索实现标记操作。在下面的代码中，我们把标记过的字母  <code>O</code>  修改为字母  <code>A</code> 。</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\"data-rel=\"JAVA\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span>[] dx = &#123;<span class=\"number\">1</span>, -<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"type\">int</span>[] dy = &#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, -<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">solve</span><span class=\"params\">(<span class=\"type\">char</span>[][] board)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> board.length;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">m</span> <span class=\"operator\">=</span> board[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">        Queue&lt;<span class=\"type\">int</span>[]&gt; queue = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;<span class=\"type\">int</span>[]&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (board[i][<span class=\"number\">0</span>] == <span class=\"string\">&#x27;O&#x27;</span>) &#123;</span><br><span class=\"line\">                queue.offer(<span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[]&#123;i, <span class=\"number\">0</span>&#125;);</span><br><span class=\"line\">                board[i][<span class=\"number\">0</span>] = <span class=\"string\">&#x27;A&#x27;</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (board[i][m - <span class=\"number\">1</span>] == <span class=\"string\">&#x27;O&#x27;</span>) &#123;</span><br><span class=\"line\">                queue.offer(<span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[]&#123;i, m - <span class=\"number\">1</span>&#125;);</span><br><span class=\"line\">                board[i][m - <span class=\"number\">1</span>] = <span class=\"string\">&#x27;A&#x27;</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; m - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (board[<span class=\"number\">0</span>][i] == <span class=\"string\">&#x27;O&#x27;</span>) &#123;</span><br><span class=\"line\">                queue.offer(<span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[]&#123;<span class=\"number\">0</span>, i&#125;);</span><br><span class=\"line\">                board[<span class=\"number\">0</span>][i] = <span class=\"string\">&#x27;A&#x27;</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (board[n - <span class=\"number\">1</span>][i] == <span class=\"string\">&#x27;O&#x27;</span>) &#123;</span><br><span class=\"line\">                queue.offer(<span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[]&#123;n - <span class=\"number\">1</span>, i&#125;);</span><br><span class=\"line\">                board[n - <span class=\"number\">1</span>][i] = <span class=\"string\">&#x27;A&#x27;</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!queue.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span>[] cell = queue.poll();</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">x</span> <span class=\"operator\">=</span> cell[<span class=\"number\">0</span>], y = cell[<span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">mx</span> <span class=\"operator\">=</span> x + dx[i], my = y + dy[i];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mx &lt; <span class=\"number\">0</span> || my &lt; <span class=\"number\">0</span> || mx &gt;= n || my &gt;= m || board[mx][my] != <span class=\"string\">&#x27;O&#x27;</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                queue.offer(<span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[]&#123;mx, my&#125;);</span><br><span class=\"line\">                board[mx][my] = <span class=\"string\">&#x27;A&#x27;</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; m; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (board[i][j] == <span class=\"string\">&#x27;A&#x27;</span>) &#123;</span><br><span class=\"line\">                    board[i][j] = <span class=\"string\">&#x27;O&#x27;</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (board[i][j] == <span class=\"string\">&#x27;O&#x27;</span>) &#123;</span><br><span class=\"line\">                    board[i][j] = <span class=\"string\">&#x27;X&#x27;</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<h4 id=\"复杂度分析-2\"><a class=\"markdownIt-Anchor\" href=\"#复杂度分析-2\">#</a> 复杂度分析</h4>\n<ul>\n<li>\n<p>时间复杂度： <code>O(n×m)</code> ，其中  <code>n</code>  和  <code>m</code>  分别为矩阵的行数和列数。广度优先搜索过程中，每一个点至多只会被标记一次。</p>\n</li>\n<li>\n<p>空间复杂度： <code>O(n×m)</code> ，其中  <code>n</code>  和  <code>m</code>  分别为矩阵的行数和列数。主要为广度优先搜索的队列的开销。</p>\n</li>\n</ul>\n","raw":null,"categories":[{"name":"LeetCode","path":"api/categories/LeetCode.json"},{"name":"算法","path":"api/categories/算法.json"},{"name":"java","path":"api/categories/java.json"}],"tags":[{"name":"矩阵","path":"api/tags/矩阵.json"},{"name":"深度遍历","path":"api/tags/深度遍历.json"},{"name":"广度遍历","path":"api/tags/广度遍历.json"}]},{"title":"JVM调优——X参数,方法内联","slug":"jvm-params","date":"2022-01-12T15:06:08.000Z","updated":"2023-03-12T14:09:38.968Z","comments":null,"realpath":null,"path":"api/articles/jvm-params.json","excerpt":"JVM 的 -X  参数是非标准参数，在不同版本的 JVM 中，参数可能会有所不同，可以通过 java -X  查看非标准参数","keywords":"jvm调优,mixed,混合,xint,解释,comp,纯编译,方法内联","cover":"/p/638c83fa/logo","content":"<p>JVM 的 <code>-X</code>  参数是非标准参数，在不同版本的 JVM 中，参数可能会有所不同，可以通过 <code>java -X</code>  查看非标准参数</p>\n<span id=\"more\"></span>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\"data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; java -X</span><br><span class=\"line\"></span><br><span class=\"line\">    -Xbatch           禁用后台编译</span><br><span class=\"line\">    -Xbootclasspath/a:&lt;以 : 分隔的目录和 zip/jar 文件&gt;</span><br><span class=\"line\">                      附加在引导类路径末尾</span><br><span class=\"line\">    -Xcheck:jni       对 JNI 函数执行其他检查</span><br><span class=\"line\">    -Xcomp            强制在首次调用时编译方法</span><br><span class=\"line\">    -Xdebug           不执行任何操作。为实现向后兼容而提供。</span><br><span class=\"line\">    -Xdiag            显示附加诊断消息</span><br><span class=\"line\">    -Xfuture          启用最严格的检查，预期将来的默认值。</span><br><span class=\"line\">                      此选项已过时，可能会在</span><br><span class=\"line\">                      未来发行版中删除。</span><br><span class=\"line\">    -Xint             仅解释模式执行</span><br><span class=\"line\">    -Xinternalversion</span><br><span class=\"line\">                      显示比 -version 选项更详细的</span><br><span class=\"line\">                      JVM 版本信息</span><br><span class=\"line\">    -Xlog:&lt;opts&gt;      配置或启用采用 Java 虚拟</span><br><span class=\"line\">                      机 (Java Virtual Machine, JVM) 统一记录框架进行事件记录。使用 -Xlog:help</span><br><span class=\"line\">                      可了解详细信息。</span><br><span class=\"line\">    -Xloggc:&lt;file&gt;    将 GC 状态记录在文件中（带时间戳）。</span><br><span class=\"line\">                      此选项已过时，可能会在</span><br><span class=\"line\">                      将来的发行版中删除。它将替换为 -Xlog:gc:&lt;file&gt;。</span><br><span class=\"line\">    -Xmixed           混合模式执行（默认值）</span><br><span class=\"line\">    -Xmn&lt;size&gt;        为年轻代（新生代）设置初始和最大堆大小</span><br><span class=\"line\">                      （以字节为单位）</span><br><span class=\"line\">    -Xms&lt;size&gt;        设置初始 Java 堆大小</span><br><span class=\"line\">    -Xmx&lt;size&gt;        设置最大 Java 堆大小</span><br><span class=\"line\">    -Xnoclassgc       禁用类垃圾收集</span><br><span class=\"line\">    -Xrs              减少 Java/VM 对操作系统信号的使用（请参见文档）</span><br><span class=\"line\">    -Xshare:auto      在可能的情况下使用共享类数据（默认值）</span><br><span class=\"line\">    -Xshare:off       不尝试使用共享类数据</span><br><span class=\"line\">    -Xshare:on        要求使用共享类数据，否则将失败。</span><br><span class=\"line\">                      这是一个测试选项，可能导致间歇性</span><br><span class=\"line\">                      故障。不应在生产环境中使用它。</span><br><span class=\"line\">    -XshowSettings    显示所有设置并继续</span><br><span class=\"line\">    -XshowSettings:all</span><br><span class=\"line\">                      显示所有设置并继续</span><br><span class=\"line\">    -XshowSettings:locale</span><br><span class=\"line\">                      显示所有与区域设置相关的设置并继续</span><br><span class=\"line\">    -XshowSettings:properties</span><br><span class=\"line\">                      显示所有属性设置并继续</span><br><span class=\"line\">    -XshowSettings:vm</span><br><span class=\"line\">                      显示所有与 vm 相关的设置并继续</span><br><span class=\"line\">    -XshowSettings:system</span><br><span class=\"line\">                      （仅 Linux）显示主机系统或容器</span><br><span class=\"line\">                      配置并继续</span><br><span class=\"line\">    -Xss&lt;size&gt;        设置 Java 线程堆栈大小</span><br><span class=\"line\">    -Xverify          设置字节码验证器的模式</span><br><span class=\"line\">                      请注意，选项 -Xverify:none 已过时，</span><br><span class=\"line\">                      可能会在未来发行版中删除。</span><br><span class=\"line\">    --add-reads &lt;module&gt;=&lt;target-module&gt;(,&lt;target-module&gt;)*</span><br><span class=\"line\">                      更新 &lt;module&gt; 以读取 &lt;target-module&gt;，而无论</span><br><span class=\"line\">                      模块如何声明。</span><br><span class=\"line\">                      &lt;target-module&gt; 可以是 ALL-UNNAMED，将读取所有未命名</span><br><span class=\"line\">                      模块。</span><br><span class=\"line\">    --add-exports &lt;module&gt;/&lt;package&gt;=&lt;target-module&gt;(,&lt;target-module&gt;)*</span><br><span class=\"line\">                      更新 &lt;module&gt; 以将 &lt;package&gt; 导出到 &lt;target-module&gt;，</span><br><span class=\"line\">                      而无论模块如何声明。</span><br><span class=\"line\">                      &lt;target-module&gt; 可以是 ALL-UNNAMED，将导出到所有</span><br><span class=\"line\">                      未命名模块。</span><br><span class=\"line\">    --add-opens &lt;module&gt;/&lt;package&gt;=&lt;target-module&gt;(,&lt;target-module&gt;)*</span><br><span class=\"line\">                      更新 &lt;module&gt; 以在 &lt;target-module&gt; 中打开</span><br><span class=\"line\">                      &lt;package&gt;，而无论模块如何声明。</span><br><span class=\"line\">    --illegal-access=&lt;value&gt;</span><br><span class=\"line\">                      允许或拒绝通过未命名模块中的代码对命名模块中的</span><br><span class=\"line\">                      类型成员进行访问。</span><br><span class=\"line\">                      &lt;value&gt; 为 &quot;deny&quot;、&quot;permit&quot;、&quot;warn&quot; 或 &quot;debug&quot; 之一</span><br><span class=\"line\">                      此选项将在未来发行版中删除。</span><br><span class=\"line\">    --limit-modules &lt;module name&gt;[,&lt;module name&gt;...]</span><br><span class=\"line\">                      限制可观察模块的领域</span><br><span class=\"line\">    --patch-module &lt;module&gt;=&lt;file&gt;(:&lt;file&gt;)*</span><br><span class=\"line\">                      使用 JAR 文件或目录中的类和资源</span><br><span class=\"line\">                      覆盖或增强模块。</span><br><span class=\"line\">    --source &lt;version&gt;</span><br><span class=\"line\">                      设置源文件模式中源的版本。</span><br><span class=\"line\"></span><br><span class=\"line\">这些额外选项如有更改, 恕不另行通知。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">以下选项是特定于 macOS 的选项：</span><br><span class=\"line\">    -XstartOnFirstThread</span><br><span class=\"line\">                      在第一个 (AppKit) 线程上运行 main() 方法</span><br><span class=\"line\">    -Xdock:name=&lt;application name&gt;</span><br><span class=\"line\">                      覆盖停靠栏中显示的默认应用程序名称</span><br><span class=\"line\">    -Xdock:icon=&lt;path to icon file&gt;</span><br><span class=\"line\">                     覆盖停靠栏中显示的默认图标</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"-xint-xcomp与-xmixed参数\"><a class=\"markdownIt-Anchor\" href=\"#-xint-xcomp与-xmixed参数\">#</a> -Xint、-Xcomp 与 - Xmixed 参数</h2>\n<h3 id=\"-xint参数\"><a class=\"markdownIt-Anchor\" href=\"#-xint参数\">#</a> -Xint 参数</h3>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\"data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在解释模式（interpreted mode）下，-Xint标记会强制JVM执行所有的字节码，这当然会降低运行速度，通常低10倍或更多。</span><br></pre></td></tr></table></figure></div>\n<p><img src=\"/p/638c83fa/20190729122640228.png\" alt=\"interpreted-mode\"></p>\n<h3 id=\"-xcomp参数\"><a class=\"markdownIt-Anchor\" href=\"#-xcomp参数\">#</a> -Xcomp 参数</h3>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\"data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Xcomp参数与-Xint正好相反，JVM在第一次使用时会把所有的字节码编译成本地代码，从而带来最大程度的优化。</span><br></pre></td></tr></table></figure></div>\n<p><img src=\"/p/638c83fa/20190729122919297.png\" alt=\"compiled-mode\"></p>\n<p>然而，很多应用在使用 - Xcomp 也会有一些性能损失，当然这笔 - Xint 损失的少，原因是 - Xcomp 没有让 JVM 启用 JIT 编译器的全部功能。JIT 编译器可以对是否需要编译做出判断。如果所有代码都需要进行编译的话，对于一些只执行一次的代码就没有意义了。</p>\n<h3 id=\"-xmixed参数\"><a class=\"markdownIt-Anchor\" href=\"#-xmixed参数\">#</a> -Xmixed 参数</h3>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\"data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Xmixed是混合模式，将解释模式和变异模式进行混合使用，有JVM自己决定，这是JVM的默认模式，也是推荐模式</span><br></pre></td></tr></table></figure></div>\n<p><img src=\"/p/638c83fa/2019072913573773.png\" alt=\"mixed-model\"></p>\n<h2 id=\"jvm方法内联优化\"><a class=\"markdownIt-Anchor\" href=\"#jvm方法内联优化\">#</a> JVM 方法内联优化</h2>\n<h3 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\">#</a> 前言</h3>\n<p>在日常中工作中，我们时不时会代码进行一些优化，比如用新的算法，简化计算逻辑，减少计算量等。对于 java 程序来说，除了开发者本身对代码优化之外，还有一个 &quot;人&quot; 也在背后默默的优化我们的代码，这个 &quot;人&quot; 就是 jvm。jvm 会帮我们分析出热点代码，优化代码逻辑。其中 jvm 最常做的优化之一就是：方法内联优化。</p>\n<h3 id=\"方法内联\"><a class=\"markdownIt-Anchor\" href=\"#方法内联\">#</a> 方法内联</h3>\n<p>什么是方法内联？又可以叫做函数内联，java 中方法可等同于其它语言中的函数。关于方法内联维基百科上面解释是：</p>\n<blockquote>\n<p>在计算机科学中，内联函数（有时称作在线函数或编译时期展开函数）是一种编程语言结构，用来建议编译器对一些特殊函数进行内联扩展（有时称作在线扩展）；也就是说<strong>建议编译器将指定的函数体插入并取代每一处调用该函数的地方（上下文），从而节省了每次调用函数带来的额外时间开支。</strong></p>\n</blockquote>\n<p>简单通俗的讲就是把方法内部调用的其它方法的逻辑，嵌入到自身的方法中去，变成自身的一部分，之后不再调用该方法，从而节省调用函数带来的额外开支。</p>\n<h3 id=\"函数调用开销\"><a class=\"markdownIt-Anchor\" href=\"#函数调用开销\">#</a> 函数调用开销</h3>\n<p>之所以出现方法内联是因为函数调用除了执行自身逻辑的开销外，还有一些不为人知的额外开销。这部分额外的开销主要来自方法栈帧的生成、参数字段的压入、栈帧的弹出、还有指令执行地址的跳转。比如有下面这样代码：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\"data-rel=\"JAVA\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">function_A</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//do something</span></span><br><span class=\"line\">    function_B(a,b);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">function_B</span><span class=\"params\">(<span class=\"type\">int</span> c, <span class=\"type\">int</span> d)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//do something</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span>&#123;</span><br><span class=\"line\">     function_A(<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<p>则代码的执行过程如下：</p>\n<p><img src=\"/p/638c83fa/247487dfbaf1ec956441e9e5e2f85817_1440w.jpg\" alt=\"img\"></p>\n<p>所以如果 java 中方法调用嵌套过多或者方法过多，这种额外的开销就越多。</p>\n<p>试想一下想 get/set 这种方法调用：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\"data-rel=\"JAVA\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getI</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setI</span><span class=\"params\">(<span class=\"type\">int</span> i)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.i = i;</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure></div>\n<p>很可能自身执行逻辑的开销还比不上为了调用这个方法的额外开锁。如果类似的方法被频繁的调用，则真正相对执行效率就会很低，虽然这类方法的执行时间很短。这也是为什么 jvm 会在热点代码中执行方法内联的原因，这样的话就可以省去调用调用函数带来的额外开支。</p>\n<p>这里举个内联的可能形式：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\"data-rel=\"JAVA\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span>  <span class=\"title function_\">add</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b , <span class=\"type\">int</span> c, <span class=\"type\">int</span> d)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> add(a, b) + add(c, d);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">add</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<p>内联之后：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\"data-rel=\"JAVA\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span>  <span class=\"title function_\">add</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b , <span class=\"type\">int</span> c, <span class=\"type\">int</span> d)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> a + b + c + d;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<p>这样除了本身的相加逻辑的开销，比内联前减少了二次调用函数带来的额外开销。</p>\n<h3 id=\"内联条件\"><a class=\"markdownIt-Anchor\" href=\"#内联条件\">#</a> 内联条件</h3>\n<p>一个方法如果满足以下条件就很可能被 jvm 内联。</p>\n<p>1、热点代码： 如果一个方法的执行频率很高就表示优化的潜在价值就越大。那代码执行多少次才能确定为热点代码？这是根据编译器的编译模式来决定的。如果是客户端编译模式则次数是 1500，服务端编译模式是 10000。次数的大小可以通过 - XX:CompileThreshold 来调整。</p>\n<p>2、方法体不能太大：jvm 中被内联的方法会编译成机器码放在 code cache 中。如果方法体太大，则能缓存热点方法就少，反而会影响性能。</p>\n<p>3、如果希望方法被内联，尽量用 private、static、final 修饰，这样 jvm 可以直接内联。如果是 public、protected 修饰方法 jvm 则需要进行类型判断，因为这些方法可以被子类继承和覆盖，jvm 需要判断内联究竟内联是父类还是其中某个子类的方法。</p>\n<blockquote>\n<p>所以了解 jvm 方法内联机制之后，会有助于我们工作中写出能让 jvm 更容易优化的代码，有助于提升程序的性能。</p>\n</blockquote>\n","raw":null,"categories":[{"name":"java","path":"api/categories/java.json"}],"tags":[{"name":"jvm调优","path":"api/tags/jvm调优.json"},{"name":"混合模式","path":"api/tags/混合模式.json"},{"name":"解释模式","path":"api/tags/解释模式.json"},{"name":"纯编译模式","path":"api/tags/纯编译模式.json"}]},{"title":"巧妙使用正则——去除小数点后多余的零","slug":"js-regexp","date":"2022-01-10T13:51:44.000Z","updated":"2023-03-12T14:09:38.968Z","comments":null,"realpath":null,"path":"api/articles/js-regexp.json","excerpt":"直接上代码1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>const arr=[&#x27;1200.00100&#x27;,&#x27;1200.00000&#x27;,&#x27;1200.&#x27;,&#x27;1200&#x27;,&#x27;1200.10000&#x27;,&#x27;0.120010000&#x27;,&#x27;0.000011111&#x27;]<br>const regexp=/(?:\\.0*|(\\.\\d+?)0+)$/<br>arr.forEach((item)=&gt;&#123;<br>    console.log(item.replace(regexp,&#x27;$1&#x27;))<br>&#125;)<br><br>// &gt; 1200.001<br>// &gt; 1200<br>// &gt; 1200<br>// &gt; 1200<br>// &gt; 1200.1<br>// &gt; 0.12001<br>// &gt; 0.000011111<br>","keywords":"正则,js,去除零","cover":"/p/9195a466/image.svg","content":"<p>直接上代码</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\"data-rel=\"JSX\"><figure class=\"iseeu highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr=[<span class=\"string\">&#x27;1200.00100&#x27;</span>,<span class=\"string\">&#x27;1200.00000&#x27;</span>,<span class=\"string\">&#x27;1200.&#x27;</span>,<span class=\"string\">&#x27;1200&#x27;</span>,<span class=\"string\">&#x27;1200.10000&#x27;</span>,<span class=\"string\">&#x27;0.120010000&#x27;</span>,<span class=\"string\">&#x27;0.000011111&#x27;</span>]</span><br><span class=\"line\"><span class=\"keyword\">const</span> regexp=<span class=\"regexp\">/(?:\\.0*|(\\.\\d+?)0+)$/</span></span><br><span class=\"line\">arr.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">item</span>)=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(item.<span class=\"title function_\">replace</span>(regexp,<span class=\"string\">&#x27;$1&#x27;</span>))</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// &gt; 1200.001</span></span><br><span class=\"line\"><span class=\"comment\">// &gt; 1200</span></span><br><span class=\"line\"><span class=\"comment\">// &gt; 1200</span></span><br><span class=\"line\"><span class=\"comment\">// &gt; 1200</span></span><br><span class=\"line\"><span class=\"comment\">// &gt; 1200.1</span></span><br><span class=\"line\"><span class=\"comment\">// &gt; 0.12001</span></span><br><span class=\"line\"><span class=\"comment\">// &gt; 0.000011111</span></span><br></pre></td></tr></table></figure></div>\n<span id=\"more\"></span>\n<p>正则可视化：</p>\n<p><img src=\"/p/9195a466/image.svg\" alt=\"image\"></p>\n<p>推荐个可视化网址：<a href=\"https://regexper.com/\">https://regexper.com/</a></p>\n<!-- more -->\n<p>再解释下正则的意思 <code>(?:.0*|(.\\d+?)0+)$</code></p>\n<p>先分解成 4 部分</p>\n<ol>\n<li><code>(?:reg1|reg2)</code>  - 它是一个正则分组非捕获组，要么匹配 reg1，要么匹配 reg2，优先匹配 reg1，加上？: 不对捕获组记录</li>\n<li><code>.0*</code>  - 表示匹配一个。开头，后边跟着 0 或 0 个以上数量的 0，且不进行捕获，所以在填充 $1 时，就是个空值</li>\n<li><code>(.\\d+?)0+</code>  - 它是一个捕获组，匹配一个。开头后边跟着非贪婪（懒惰）匹配任意数字，接着在末尾尽可能多的匹配 0 这个字符，匹配完成后，生成一个捕获组内容</li>\n<li><code>$</code>  - 表示匹配结果需要以 0 作为结尾</li>\n</ol>\n<h2 id=\"正则分组\"><a class=\"markdownIt-Anchor\" href=\"#正则分组\">#</a> 正则分组</h2>\n<ul>\n<li>\n<p>普通捕获组</p>\n<p>从正则表达式左侧开始，每出现一个左括号 &quot;(&quot; 记做一个分组，分组编号从 1 开始。0 代表整个表达式。</p>\n<p>对于时间字符串：2017-04-25，表达式如下</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\"data-rel=\"JS\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(\\\\d&#123;<span class=\"number\">4</span>&#125;)-((\\\\d&#123;<span class=\"number\">2</span>&#125;)-(\\\\d&#123;<span class=\"number\">2</span>&#125;))</span><br></pre></td></tr></table></figure></div>\n<p>有 4 个左括号，所以有 4 个分组:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">编号</th>\n<th style=\"text-align:left\">捕获组</th>\n<th style=\"text-align:left\">匹配</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">0</td>\n<td style=\"text-align:left\">(\\d{4})-((\\d{2})-(\\d{2}))</td>\n<td style=\"text-align:left\">2017-04-25</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">(\\d{4})</td>\n<td style=\"text-align:left\">2017</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">((\\d{2})-(\\d{2}))</td>\n<td style=\"text-align:left\">04-25</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">3</td>\n<td style=\"text-align:left\">(\\d{2})</td>\n<td style=\"text-align:left\">04</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">4</td>\n<td style=\"text-align:left\">(\\d{2})</td>\n<td style=\"text-align:left\">25</td>\n</tr>\n</tbody>\n</table>\n</li>\n<li>\n<p>命名捕获组</p>\n<p>每个以左括号开始的捕获组，都紧跟着 <strong>?</strong>，而后才是正则表达式。</p>\n<p>对于时间字符串：2017-04-25，表达式如下:</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\"data-rel=\"JS\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(?&lt;year&gt;\\\\d&#123;<span class=\"number\">4</span>&#125;)-(?&lt;md&gt;(?&lt;month&gt;\\\\d&#123;<span class=\"number\">2</span>&#125;)-(?&lt;date&gt;\\\\d&#123;<span class=\"number\">2</span>&#125;))</span><br></pre></td></tr></table></figure></div>\n<p>有 4 个命名的捕获组，分别是:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">编号</th>\n<th style=\"text-align:left\">名称</th>\n<th style=\"text-align:left\">捕获组</th>\n<th style=\"text-align:left\">匹配</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">0</td>\n<td style=\"text-align:left\">0</td>\n<td style=\"text-align:left\">(?\\d{4})-(?(?\\d{2})-(?\\d{2}))</td>\n<td style=\"text-align:left\">2017-04-25</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">year</td>\n<td style=\"text-align:left\">(?\\d{4})-</td>\n<td style=\"text-align:left\">2017</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">md</td>\n<td style=\"text-align:left\">(?(?\\d{2})-(?\\d{2}))</td>\n<td style=\"text-align:left\">04-25</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">3</td>\n<td style=\"text-align:left\">month</td>\n<td style=\"text-align:left\">(?\\d{2})</td>\n<td style=\"text-align:left\">04</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">4</td>\n<td style=\"text-align:left\">date</td>\n<td style=\"text-align:left\">(?\\d{2})</td>\n<td style=\"text-align:left\">25</td>\n</tr>\n</tbody>\n</table>\n<p>命名的捕获组同样也可以使用编号获取相应值。</p>\n</li>\n</ul>\n<h2 id=\"非捕获组\"><a class=\"markdownIt-Anchor\" href=\"#非捕获组\">#</a> 非捕获组</h2>\n<p>在左括号后紧跟  <code>?:</code> ，而后再加上正则表达式，构成非捕获组 <strong>(?:Expression)</strong>。</p>\n<p>对于时间字符串：2017-04-25，表达式如下:</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\"data-rel=\"JS\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(?:\\\\d&#123;<span class=\"number\">4</span>&#125;)-((\\\\d&#123;<span class=\"number\">2</span>&#125;)-(\\\\d&#123;<span class=\"number\">2</span>&#125;))</span><br></pre></td></tr></table></figure></div>\n<p>这个正则表达式虽然有四个左括号，理论上有 4 个捕获组。但是第一组 <strong>(?:\\d{4})</strong>，其实是被忽略的。当使用 matcher.group (4) 时，系统会报错。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">编号</th>\n<th style=\"text-align:left\">捕获组</th>\n<th style=\"text-align:left\">匹配</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">0</td>\n<td style=\"text-align:left\">(\\d{4})-((\\d{2})-(\\d{2}))</td>\n<td style=\"text-align:left\">2017-04-25</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">((\\d{2})-(\\d{2}))</td>\n<td style=\"text-align:left\">04-25</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">(\\d{2})</td>\n<td style=\"text-align:left\">04</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">3</td>\n<td style=\"text-align:left\">(\\d{2})</td>\n<td style=\"text-align:left\">25</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"非贪婪懒惰匹配\"><a class=\"markdownIt-Anchor\" href=\"#非贪婪懒惰匹配\">#</a> 非贪婪 (懒惰) 匹配</h2>\n<p>** 贪婪匹配:** 正则表达式一般趋向于最大长度匹配，也就是所谓的贪婪匹配。如上面使用模式 p 匹配字符串 str，结果就是匹配到：<strong>abcaxc</strong>(ab*c)。</p>\n<p><strong>非贪婪匹配</strong>：就是匹配到结果就好，就少的匹配字符。如上面使用模式 p 匹配字符串 str，结果就是匹配到：<strong>abc</strong>(ab*c)。</p>\n<p>问号可以表示重复前面内容的 0 次或一次，也就是要么不出现，要么出现一次</p>\n<p>示例 1：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\"data-rel=\"JAVA\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">string</span> <span class=\"variable\">pattern1</span> <span class=\"operator\">=</span> @<span class=\"string\">&quot;a.*?c&quot;</span>;   <span class=\"comment\">// non-greedy match </span></span><br><span class=\"line\"><span class=\"type\">Regex</span> <span class=\"variable\">regex</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Regex</span>(pattern1);</span><br><span class=\"line\">regex.Match(<span class=\"string\">&quot;abcabc&quot;</span>); <span class=\"comment\">// return &quot;abc&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">## 结果：abc</span><br></pre></td></tr></table></figure></div>\n<p>示例 2：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\"data-rel=\"PYTHON\"><figure class=\"iseeu highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\">s=<span class=\"string\">&#x27;hello 1234567 world&#x27;</span></span><br><span class=\"line\">res = re.<span class=\"keyword\">match</span>(<span class=\"string\">&#x27;he.*?(\\d).*rld$&#x27;</span>,s)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(res.group(<span class=\"number\">1</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 结果：123456</span></span><br></pre></td></tr></table></figure></div>\n<p>常用非贪婪表达式</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\"data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*? 重复任意次，但尽可能少重复</span><br><span class=\"line\">+? 重复1次或更多次，但尽可能少重复</span><br><span class=\"line\">?? 重复0次或1次，但尽可能少重复</span><br><span class=\"line\">&#123;n,m&#125;? 重复n到m次，但尽可能少重复</span><br><span class=\"line\">&#123;n,&#125;? 重复n次以上，但尽可能少重复</span><br></pre></td></tr></table></figure></div>","raw":null,"categories":[{"name":"前端","path":"api/categories/前端.json"}],"tags":[{"name":"正则","path":"api/tags/正则.json"},{"name":"js","path":"api/tags/js.json"},{"name":"去除零","path":"api/tags/去除零.json"}]}]}