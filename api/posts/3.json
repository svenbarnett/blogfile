{"total":36,"pageSize":10,"pageCount":4,"data":[{"title":"gulp-imagemin在压缩图片","slug":"gulp-imagemin-use","date":"2021-11-16T14:35:58.000Z","updated":"2023-04-30T02:56:59.106Z","comments":null,"realpath":null,"path":"api/articles/gulp-imagemin-use.json","excerpt":"经过各种研（bai）究（du），找到了一种方案：采用 gulp + gulp-imagemin ，对图片进行压缩，结合 hexo 进行对应图片压缩。","keywords":"gulp-imagemin,压缩图片,gulp","cover":"/p/1009bbf4/ppp","content":"<html><head></head><body><p>经过各种研（bai）究（du），找到了一种方案：采用 <code>gulp + gulp-imagemin</code> ，对图片进行压缩，结合 hexo 进行对应图片压缩。</p>\n<span id=\"more\"></span>\n<h3 id=\"安装\"><a class=\"markdownIt-Anchor\" href=\"#安装\">#</a> 安装</h3>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"SH\"><figure class=\"iseeu highlight sh\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install gulp --save-dev</span><br><span class=\"line\">npm install gulp-imagemin --save-dev</span><br><span class=\"line\">npm install imagemin-pngquant --save-dev</span><br><span class=\"line\"><span class=\"comment\"># 当然也可以--save  记得要给gulp全局安装下，npm命令不行，就是用cnpm</span></span><br><span class=\"line\">npm install gulp -g <span class=\"comment\"># 只有gulp要全局安装下</span></span><br></pre></td></tr></tbody></table></figure></div>\n<h3 id=\"gulpfile\"><a class=\"markdownIt-Anchor\" href=\"#gulpfile\">#</a> gulpfile</h3>\n<p>在 package.json 同名目录下，增加 gulpfile.js 对应的入口 js 文件</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"JAVASCRIPT\"><figure class=\"iseeu highlight javascript\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> gulp <span class=\"keyword\">from</span> <span class=\"string\">'gulp'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> imagemin <span class=\"keyword\">from</span> <span class=\"string\">'gulp-imagemin'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> pngquant <span class=\"keyword\">from</span> <span class=\"string\">'imagemin-pngquant'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义一个任务 第一个参数为名称，后面时要执行的动作</span></span><br><span class=\"line\">gulp.<span class=\"title function_\">task</span>(<span class=\"string\">'minify-images'</span>, <span class=\"keyword\">function</span> (<span class=\"params\">done</span>) {</span><br><span class=\"line\">    gulp.<span class=\"title function_\">src</span>(<span class=\"string\">'public/p/**/*.{JPG,jpg,PNG,png,GIF,gif,SVG,svg,JPEG,jpeg}'</span>)</span><br><span class=\"line\">\t\t.<span class=\"title function_\">pipe</span>(<span class=\"title function_\">imagemin</span>({</span><br><span class=\"line\">\t\t\t<span class=\"attr\">optimizationLevel</span>: <span class=\"number\">3</span>,</span><br><span class=\"line\">\t\t\t<span class=\"attr\">progressive</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">\t\t\t<span class=\"attr\">usa</span>:[<span class=\"title function_\">pngquant</span>()]</span><br><span class=\"line\">\t\t}))</span><br><span class=\"line\">\t\t.<span class=\"title function_\">pipe</span>(gulp.<span class=\"title function_\">dest</span>(<span class=\"string\">'public/p/'</span>))</span><br><span class=\"line\">    <span class=\"title function_\">done</span>();</span><br><span class=\"line\">});</span><br><span class=\"line\"><span class=\"comment\">// 定义default ，后面将多个任务序列化并行执行，我们只有一个</span></span><br><span class=\"line\">gulp.<span class=\"title function_\">task</span>(<span class=\"string\">'default'</span>, gulp.<span class=\"title function_\">series</span>(gulp.<span class=\"title function_\">parallel</span>(<span class=\"string\">'minify-images'</span>)), <span class=\"keyword\">function</span> (<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">info</span>(<span class=\"string\">\"----------gulp Finished----------\"</span>);</span><br><span class=\"line\">});</span><br></pre></td></tr></tbody></table></figure></div>\n<p>执行命令 <code>gulp</code>  默认情况下，代表 <code>gulp default</code>  就执行你上面的 default 任务</p>\n<p>当然你也可以制定任务名称： <code>gulp minify-images</code>  执行指定 task</p>\n<p>然后再 hexo 状态下：</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"SH\"><figure class=\"iseeu highlight sh\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean </span><br><span class=\"line\">hexo g</span><br><span class=\"line\">gulp</span><br><span class=\"line\"><span class=\"comment\"># 输出如下：</span></span><br><span class=\"line\">[22:46:42] Using gulpfile ~/Desktop/blogfile/gulpfile.js</span><br><span class=\"line\">[22:46:42] Starting <span class=\"string\">'default'</span>...</span><br><span class=\"line\">[22:46:42] Starting <span class=\"string\">'minify-images'</span>...</span><br><span class=\"line\">[22:46:42] Finished <span class=\"string\">'minify-images'</span> after 74 ms</span><br><span class=\"line\">[22:46:42] Finished <span class=\"string\">'default'</span> after 99 ms</span><br></pre></td></tr></tbody></table></figure></div>\n<p>那说明成功了</p>\n<h3 id=\"遇到的坑\"><a class=\"markdownIt-Anchor\" href=\"#遇到的坑\">#</a> 遇到的坑</h3>\n<ul>\n<li>引入语法问题，插件需要使用 es6 语法，故此你的 package.json 需要增加一个参数 <code>  \"type\": \"module\"</code>  如此你可以再 gulpfile.js 中使用 es6 的 import 语法</li>\n</ul>\n</body></html>","raw":null,"categories":[],"tags":[{"name":"gulp","path":"api/tags/gulp.json"},{"name":"压缩图片","path":"api/tags/压缩图片.json"},{"name":"gulp-imagemin","path":"api/tags/gulp-imagemin.json"}]},{"title":"图记——今日午餐","slug":"today-life-lunach","date":"2021-11-14T04:29:41.000Z","updated":"2023-04-30T02:56:59.174Z","comments":null,"realpath":null,"path":"api/articles/today-life-lunach.json","excerpt":"","keywords":"生活,午餐","cover":"/p/dbbc4a4a/IMG_0073.JPG","content":"<html><head></head><body><p><img src=\"/p/dbbc4a4a/IMG_0073.JPG\" alt=\"今日午餐\"></p>\n</body></html>","raw":null,"categories":[],"tags":[{"name":"图记","path":"api/tags/图记.json"},{"name":"生活","path":"api/tags/生活.json"},{"name":"午餐","path":"api/tags/午餐.json"}]},{"title":"虚拟机类加载机制-类加载时机","slug":"jvm-classload","date":"2021-11-12T14:55:27.000Z","updated":"2023-04-30T02:56:59.106Z","comments":null,"realpath":null,"path":"api/articles/jvm-classload.json","excerpt":"在 Java 语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略虽然会令类加载时稍微增加一些性能开销，但是会为 Java 应用程序提供高度的灵活性，Java 里天生可以动态扩展的语言特性就是依赖于运行期动态加载和动态连接这个特点实现的。","keywords":"jvm,虚拟机,类加载,类加载时机","cover":"/p/8239/20160719124551909.jpeg","content":"<html><head></head><body><p>在 Java 语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略虽然会令类加载时稍微增加一些性能开销，但是会为 Java 应用程序提供高度的灵活性，Java 里天生可以动态扩展的语言特性就是依赖于运行期动态加载和动态连接这个特点实现的。</p>\n<span id=\"more\"></span>\n<p>例如，如果编写一个面向接口的应用程序，可以等到运行时再指定其实际的实现类；用户可以通过 Java 预定义的和自定义类加载器，让一个本地的应用程序可以在运行时从网络或其他地方加载一个二进制流作为程序代码的一部分，这种组装应用程序的方式目前已广泛应用于 Java 程序之中。从最基础的 Applet、JSP 到相对复杂的 OSGI 技术，都使用了 Java 语言运行期类加载的特性。</p>\n<h2 id=\"类加载机制\"><a class=\"markdownIt-Anchor\" href=\"#类加载机制\">#</a> 类加载机制</h2>\n<p>生命周期：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialzation）、使用（Using）和卸载（Unloading）7 个阶段。</p>\n<p><img src=\"/p/8239/20160719124551909.jpeg\" alt=\"生命周期\"></p>\n<p>什么情况下需要开始进行类加载过程的第一阶段呢？没有明确约束，虚拟机自由把握；</p>\n<p>而初始化阶段有严格规范，以下五种情况必须理解对类进行初始化。</p>\n<ol>\n<li>遇到 new（new 关键词实例化），getstatic（读取类的 static 字段），putstatic（设置类的 static 字段，被 final 修饰、已在编译期就把结果放入了常量池的字段除外），invokestatic（调用一个类的静态方法）</li>\n<li>使用 <code>java.lang.reflect</code>  包的方法对类进行反射调用</li>\n<li>初始化一个类，会先初始化它的父类</li>\n<li>虚拟机启动时，会先初始化执行的主类（main 方法）</li>\n<li>JDK1.7 的 <code>java.lang.invoke.MethodHandle</code>  的方法去获取句柄</li>\n</ol>\n<p><em><strong>有且仅有</strong></em>这五种情况，除此之外都是被动引用，不会触发初始化，举 3 个例子</p>\n<ul>\n<li>对于静态字段，只有定义这个字段的类才会被初始化，例如父类定义的静态字段，通过子类去使用父类的静态字段，那么只有父类会初始化，子类不会</li>\n<li>数组类型定义使用时，类似 <code>SubClass[]</code>  不会进行初始化</li>\n<li>被 finla 修饰的静态字段，会进行常量传播优化，实际上这个字段已经和这个类没啥关系了</li>\n</ul>\n<p>初始化第三种情况下，对于接口有个特例情况：一个类初始化时要求父类全部初始化，而接口，不要求其父接口全部都完成初始化，只有在使用到才会初始化。</p>\n</body></html>","raw":null,"categories":[],"tags":[{"name":"jvm","path":"api/tags/jvm.json"},{"name":"类加载","path":"api/tags/类加载.json"}]},{"title":"环形链表——LeetCode141","slug":"linked-list-cycle","date":"2021-11-12T13:17:10.000Z","updated":"2023-04-30T02:56:59.110Z","comments":null,"realpath":null,"path":"api/articles/linked-list-cycle.json","excerpt":"给定一个链表，判断链表中是否有环。如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。<br>如果链表中存在环，则返回 true 。 否则，返回 false 。<br>LeetCode-141 链接：https://leetcode-cn.com/problems/linked-list-cycle","keywords":"环形链表,快慢指针","cover":"/p/1426/circularlinkedlist.png","content":"<html><head></head><body><p>给定一个链表，判断链表中是否有环。</p>\n<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。<br>\n如果链表中存在环，则返回 true 。 否则，返回 false 。<br>\nLeetCode-141 链接：<a href=\"https://leetcode-cn.com/problems/linked-list-cycle\">https://leetcode-cn.com/problems/linked-list-cycle</a></p>\n<span id=\"more\"></span> \n<p>示例 1：</p>\n<p><img src=\"/p/1426/circularlinkedlist.png\" alt=\"环形链表-示例1\"></p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"BASH\"><figure class=\"iseeu highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：<span class=\"built_in\">head</span> = [3,2,0,-4], pos = 1</span><br><span class=\"line\">输出：<span class=\"literal\">true</span></span><br><span class=\"line\">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></tbody></table></figure></div>\n<p>示例 2：</p>\n<p><img src=\"/p/1426/circularlinkedlist_test2.png\" alt=\"环形链表-示例2\"></p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"BASH\"><figure class=\"iseeu highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：<span class=\"built_in\">head</span> = [1,2], pos = 0</span><br><span class=\"line\">输出：<span class=\"literal\">true</span></span><br><span class=\"line\">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></tbody></table></figure></div>\n<p>示例 3：</p>\n<p><img src=\"/p/1426/circularlinkedlist_test3.png\" alt=\"环形链表-示例3\"></p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"BASH\"><figure class=\"iseeu highlight bash\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：<span class=\"built_in\">head</span> = [1], pos = -1</span><br><span class=\"line\">输出：<span class=\"literal\">false</span></span><br><span class=\"line\">解释：链表中没有环。</span><br></pre></td></tr></tbody></table></figure></div>\n<p>提示：</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"REASONML\"><figure class=\"iseeu highlight reasonml\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">链表中节点的数目范围是 <span class=\"literal\">[<span class=\"number\">0</span>, <span class=\"number\">104</span>]</span></span><br><span class=\"line\">-<span class=\"number\">105</span> &lt;= <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Node</span>.</span></span><span class=\"keyword\">val</span> &lt;= <span class=\"number\">105</span></span><br><span class=\"line\">pos 为 -<span class=\"number\">1</span> 或者链表中的一个 有效索引 。</span><br></pre></td></tr></tbody></table></figure></div>\n<h3 id=\"解题\"><a class=\"markdownIt-Anchor\" href=\"#解题\">#</a> 解题</h3>\n<ol>\n<li>Hash 表</li>\n</ol>\n<p>最容易想到的方法是遍历所有节点，每次遍历到一个节点时，判断该节点此前是否被访问过。</p>\n<p>具体地，我们可以使用哈希表来存储所有已经访问过的节点。每次我们到达一个节点，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。重复这一过程，直到我们遍历完整个链表即可。</p>\n<p>代码实现：</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"JAVA\"><figure class=\"iseeu highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> {</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">hasCycle</span><span class=\"params\">(ListNode head)</span> {</span><br><span class=\"line\">        Set&lt;ListNode&gt; seen = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;ListNode&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (head != <span class=\"literal\">null</span>) {</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!seen.add(head)) {</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            }</span><br><span class=\"line\">            head = head.next;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure></div>\n<p>复杂度分析</p>\n<p>时间复杂度： <code>O(N)</code> ，其中  <code>N </code> 是链表中的节点数。最坏情况下我们需要遍历每个节点一次。<br>\n空间复杂度： <code>O(N)</code> ，其中 <code>N </code> 是链表中的节点数。主要为哈希表的开销，最坏情况下我们需要将每个节点插入到哈希表中一次。</p>\n<ol start=\"2\">\n<li>快慢指针</li>\n</ol>\n<p>方法需要读者对「Floyd 判圈算法」（又称龟兔赛跑算法）有所了解。</p>\n<p>假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。</p>\n<p>我们可以根据上述思路来解决本题。具体地，我们定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。</p>\n<p><img src=\"/p/1426/2.png\" alt=\"龟兔赛跑\"></p>\n<blockquote>\n<p>为什么我们要规定初始时慢指针在位置 head，快指针在位置 head.next，而不是两个指针都在位置 head（即与「乌龟」和「兔子」中的叙述相同）？</p>\n</blockquote>\n<ul>\n<li>观察下面的代码，我们使用的是 while 循环，循环条件先于循环体。由于循环条件一定是判断快慢指针是否重合，如果我们将两个指针初始都置于 head，那么 while 循环就不会执行。因此，我们可以假想一个在 head 之前的虚拟节点，慢指针从虚拟节点移动一步到达 head，快指针从虚拟节点移动两步到达 head.next，这样我们就可以使用 while 循环了。</li>\n<li>当然，我们也可以使用 do-while 循环。此时，我们就可以把快慢指针的初始值都置为 head。</li>\n</ul>\n<p>代码实现：</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"JAVA\"><figure class=\"iseeu highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> {</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">hasCycle</span><span class=\"params\">(ListNode head)</span> {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head == <span class=\"literal\">null</span> || head.next == <span class=\"literal\">null</span>) {</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">slow</span> <span class=\"operator\">=</span> head;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">fast</span> <span class=\"operator\">=</span> head.next;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (slow != fast) {</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (fast == <span class=\"literal\">null</span> || fast.next == <span class=\"literal\">null</span>) {</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            }</span><br><span class=\"line\">            slow = slow.next;</span><br><span class=\"line\">            fast = fast.next.next;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure></div>\n<p>复杂度分析</p>\n<p>时间复杂度： <code>O(N)</code> ，其中  <code>N</code>  是链表中的节点数。<br>\n当链表中不存在环时，快指针将先于慢指针到达链表尾部，链表中每个节点至多被访问两次。<br>\n当链表中存在环时，每一轮移动后，快慢指针的距离将减小一。而初始距离为环的长度，因此至多移动<br>\n <code>N</code>  轮。<br>\n空间复杂度： <code>O(1)</code> 。我们只使用了两个指针的额外空间。</p>\n</body></html>","raw":null,"categories":[],"tags":[{"name":"算法","path":"api/tags/算法.json"},{"name":"快慢指针","path":"api/tags/快慢指针.json"},{"name":"环形链表","path":"api/tags/环形链表.json"}]},{"title":"寻找重复数——LeetCode287","slug":"find-the-duplicate-number","date":"2021-11-11T13:02:11.000Z","updated":"2023-04-30T02:56:59.106Z","comments":null,"realpath":null,"path":"api/articles/find-the-duplicate-number.json","excerpt":"给定一个包含 n + 1 个整数的数组 nums ，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。<br>假设 nums 只有 一个重复的整数 ，找出 这个重复的数 。<br>你设计的解决方案必须不修改数组 nums 且只用常量级 O (1) 的额外空间。<br>Leetcode-287 链接：https://leetcode-cn.com/problems/find-the-duplicate-number","keywords":"寻找重复数,二分法,算法,leetcode","cover":"","content":"<html><head></head><body><p>给定一个包含 n + 1 个整数的数组 nums ，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。<br>\n假设 nums 只有 一个重复的整数 ，找出 这个重复的数 。<br>\n你设计的解决方案必须不修改数组 nums 且只用常量级 O (1) 的额外空间。<br>\nLeetcode-287 链接：<a href=\"https://leetcode-cn.com/problems/find-the-duplicate-number\">https://leetcode-cn.com/problems/find-the-duplicate-number</a></p>\n<span id=\"more\"></span>\n<p>示例 1：</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"SH\"><figure class=\"iseeu highlight sh\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,3,4,2,2]</span><br><span class=\"line\">输出：2</span><br></pre></td></tr></tbody></table></figure></div>\n<p>示例 2：</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"SH\"><figure class=\"iseeu highlight sh\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [3,1,3,4,2]</span><br><span class=\"line\">输出：3</span><br></pre></td></tr></tbody></table></figure></div>\n<p>示例 3：</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"SH\"><figure class=\"iseeu highlight sh\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,1]</span><br><span class=\"line\">输出：1</span><br></pre></td></tr></tbody></table></figure></div>\n<p>示例 4：</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"FIX\"><figure class=\"iseeu highlight fix\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">输入：nums </span>=<span class=\"string\"> [1,1,2]</span></span><br><span class=\"line\"><span class=\"string\">输出：1</span></span><br></pre></td></tr></tbody></table></figure></div>\n<p>提示：</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"SH\"><figure class=\"iseeu highlight sh\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 &lt;= n &lt;= 105</span><br><span class=\"line\">nums.length == n + 1</span><br><span class=\"line\">1 &lt;= nums[i] &lt;= n</span><br></pre></td></tr></tbody></table></figure></div>\n<p>nums 中 只有一个整数 出现 两次或多次 ，其余整数均只出现 一次</p>\n<h3 id=\"解题\"><a class=\"markdownIt-Anchor\" href=\"#解题\">#</a> 解题</h3>\n<ol>\n<li>二分法</li>\n</ol>\n<p>针对用例 <code>[1,3,4,2,2]</code></p>\n<p>定义一个 <code>cnt</code>  数组用来存储小于等于 索引  <code>i</code>  的总数</p>\n<p>如果知道 cnt 数组随数字 index 逐渐增大具有单调性，那么当 num [index] 那么我们就可以直接利用二分查找来找到重复的数</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">nums</th>\n<th style=\"text-align:center\">1</th>\n<th style=\"text-align:center\">2</th>\n<th style=\"text-align:center\">3</th>\n<th style=\"text-align:center\">4</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">cnt</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">5</td>\n</tr>\n</tbody>\n</table>\n<p>小于等于 1 的一个</p>\n<p>小于等于 2 的三个</p>\n<p>小于等于 3 的四个</p>\n<p>小于等于 4 的五个</p>\n<p>由此可见：我们的目标是 2，target 满足: target 前面的  <code>cnt[i] &lt;=  i</code> , 目标值 target 之后的  <code>cnt[i] &gt; i</code></p>\n<p>实际上可以归纳为：</p>\n<ul>\n<li>\n<p>如果测试用例的数组中  <code>target</code>  出现了两次，其余的数各出现了一次，这个时候肯定满足上文提及的性质，因为小于  <code>target</code>  的数 i 满足  <code>cnt[i]=i</code> ，大于等于  <code>target</code>  的数  <code>j</code>  满足  <code>cnt[j]=j+1</code> 。</p>\n</li>\n<li>\n<p>如果测试用例的数组中 <code>target </code> 出现了三次及以上，那么必然有一些数不在  <code>nums</code>  数组中了，这个时候相当于我们用 <code>target</code>  去替换了这些数，我们考虑替换的时候对 <code>cnt[] </code> 数组的影响。如果替换的数 <code>i</code>  小于  <code>target</code>  ，那么在数 <code>i</code>  到 <code>target</code>  区间的值，均减一，其他不变，满足条件。如果替换的数  <code>j</code>  大于等于  <code>target</code> ，那么 <code>target</code>  到 数 <code>j</code>  区间内值均加一，其他不变，亦满足条件。</p>\n</li>\n</ul>\n<p>因此不管多个重复还是两个重复，数组都满足那个性质。</p>\n<p>代码实现：</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"JAVA\"><figure class=\"iseeu highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> {</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">findDuplicate</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> {</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> nums.length;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">l</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>, r = n - <span class=\"number\">1</span>, ans = -<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (l &lt;= r) {</span><br><span class=\"line\">           # 右移动一位，相关于除以<span class=\"number\">2</span>，取中间值</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">mid</span> <span class=\"operator\">=</span> (l + r) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">cnt</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; ++i) {</span><br><span class=\"line\">              # 将小于等于中间值都加起来  </span><br><span class=\"line\">              <span class=\"keyword\">if</span> (nums[i] &lt;= mid) {</span><br><span class=\"line\">                    cnt++;</span><br><span class=\"line\">                }</span><br><span class=\"line\">            }</span><br><span class=\"line\">           # 如果此时的cnt总数小于等于mid，那说明不在mid左边</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cnt &lt;= mid) {</span><br><span class=\"line\">               # 把左边拉到中间</span><br><span class=\"line\">                l = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">                # 否则把右边拉到中间</span><br><span class=\"line\">                r = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">                # 记录答案</span><br><span class=\"line\">                ans = mid;</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure></div>\n<p>复杂度分析</p>\n<p>时间复杂度： <code>O(n * logn)</code> ，其中 n 为 nums 数组的长度。二分查找最多需要二分 <code>O(logn) </code> 次，每次判断的时候需要 <code>O(n)</code>  遍历 nums 数组求解小于等于 mid 的数的个数，因此总时间复杂度为 <code>O(n * logn)</code> 。</p>\n<p>空间复杂度： <code>O(1)</code> 。我们只需要常数空间存放若干变量。</p>\n<ol start=\"2\">\n<li>快慢指针</li>\n</ol>\n<p>我们对 nums 数组建图，每个位置  <code>i</code>  连一条  <code>i→nums[i]</code>  的边。由于存在的重复的数字<br>\n <code>target</code>  因此  <code>target </code> 这个位置一定有起码两条指向它的边，因此整张图一定存在环，且我们要找到的<br>\n <code>target</code>  就是这个环的入口.</p>\n<p>我们先设置慢指针 <code>slow 和快指针</code>   <code>fast</code>  ，慢指针每次走一步，快指针每次走两步，根据「Floyd 判圈算法」两个指针在有环的情况下一定会相遇，此时我们再将  <code>slow</code>  放置起点 <code>0</code> ，两个指针每次同时移动一步，相遇的点就是答案。</p>\n<p>代码实现：</p>\n<div class=\"highlight-wrap\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\" data-rel=\"JAVA\"><figure class=\"iseeu highlight java\"><table><tbody><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> {</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">findDuplicate</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> {</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">slow</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, fast = <span class=\"number\">0</span>;</span><br><span class=\"line\">      \t# 找环的入口</span><br><span class=\"line\">        <span class=\"keyword\">do</span> {</span><br><span class=\"line\">            slow = nums[slow];</span><br><span class=\"line\">            fast = nums[nums[fast]];</span><br><span class=\"line\">        } <span class=\"keyword\">while</span> (slow != fast);</span><br><span class=\"line\">        # 重置slow为起点</span><br><span class=\"line\">        slow = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (slow != fast) {</span><br><span class=\"line\">            slow = nums[slow];</span><br><span class=\"line\">            fast = nums[fast];</span><br><span class=\"line\">        }</span><br><span class=\"line\">        # 再次相遇 就是环入口</span><br><span class=\"line\">        <span class=\"keyword\">return</span> slow;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></tbody></table></figure></div>\n<p>复杂度分析</p>\n<p>时间复杂度： <code>O(n)</code> 。「Floyd 判圈算法」时间复杂度为线性的时间复杂度。<br>\n空间复杂度： <code>O(1)</code> 。我们只需要常数空间存放若干变量。</p>\n</body></html>","raw":null,"categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"},{"name":"二分法","path":"api/tags/二分法.json"},{"name":"快慢指针","path":"api/tags/快慢指针.json"}]},{"title":"图记——晚霞的尾巴","slug":"pic-shenzhen-1","date":"2021-08-27T10:50:09.000Z","updated":"2023-04-30T02:56:59.154Z","comments":null,"realpath":null,"path":"api/articles/pic-shenzhen-1.json","excerpt":"","keywords":"晚霞,天安云谷","cover":"/p/4ee64d66/IMG_0027.jpg","content":"<html><head></head><body><p><img src=\"/p/4ee64d66/IMG_0027.jpg\" alt=\"晚霞的尾巴\"></p>\n</body></html>","raw":null,"categories":[],"tags":[{"name":"晚霞","path":"api/tags/晚霞.json"},{"name":"云谷","path":"api/tags/云谷.json"}]},{"title":"图记——武康大楼","slug":"pic-shanghai-1","date":"2021-05-16T05:50:28.000Z","updated":"2023-04-30T02:56:59.122Z","comments":null,"realpath":null,"path":"api/articles/pic-shanghai-1.json","excerpt":"","keywords":"武康大楼,上海,图记","cover":"/p/9b051724/IMG_4609.jpg","content":"<html><head></head><body><p><img src=\"/p/9b051724/IMG_4609.jpg\" alt=\"武康大楼\"></p>\n</body></html>","raw":null,"categories":[],"tags":[{"name":"武康大楼","path":"api/tags/武康大楼.json"},{"name":"上海","path":"api/tags/上海.json"}]},{"title":"往昔时光-我们","slug":"olden-days-4","date":"2021-02-12T05:43:18.000Z","updated":"2023-04-30T02:56:59.122Z","comments":null,"realpath":null,"path":"api/articles/olden-days-4.json","excerpt":"","keywords":"往昔时光,我们,传承","cover":"/p/51719/IMG_4766.JPG","content":"<html><head></head><body><p><img src=\"/p/51719/IMG_4766.JPG\" alt=\"今夕\"></p>\n<p>小时候我们唯一的合照</p>\n</body></html>","raw":null,"categories":[],"tags":[{"name":"我们","path":"api/tags/我们.json"},{"name":"年轻","path":"api/tags/年轻.json"},{"name":"年幼","path":"api/tags/年幼.json"}]},{"title":"图记——上海外滩","slug":"pic-shanghai-4","date":"2020-05-20T13:35:39.000Z","updated":"2023-04-30T02:56:59.150Z","comments":null,"realpath":null,"path":"api/articles/pic-shanghai-4.json","excerpt":"","keywords":"上海外滩,夜景","cover":"/p/ec5868f5/IMG_4615.JPG","content":"<html><head></head><body><p><img src=\"/p/ec5868f5/IMG_4615.JPG\" alt=\"朦胧的外滩\"></p>\n</body></html>","raw":null,"categories":[],"tags":[{"name":"上海外滩","path":"api/tags/上海外滩.json"},{"name":"夜景","path":"api/tags/夜景.json"}]},{"title":"图记——直插云霄","slug":"pic-shanghai-3","date":"2019-12-30T11:50:56.000Z","updated":"2023-04-30T02:56:59.146Z","comments":null,"realpath":null,"path":"api/articles/pic-shanghai-3.json","excerpt":"","keywords":"上海,图记,上海中心大厦","cover":"/p/6617d304/IMG_4526.JPG","content":"<html><head></head><body><p><img src=\"/p/6617d304/IMG_4526.JPG\" alt=\"直插云霄\"></p>\n</body></html>","raw":null,"categories":[],"tags":[{"name":"上海","path":"api/tags/上海.json"},{"name":"三叉戟","path":"api/tags/三叉戟.json"}]}]}