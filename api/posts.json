{"total":27,"pageSize":10,"pageCount":3,"data":[{"title":"室友“羊”了","slug":"20221219","date":"2022-12-19T12:46:23.000Z","updated":"2023-02-04T06:41:58.436Z","comments":null,"realpath":null,"path":"api/articles/20221219.json","excerpt":"室友这几天不舒服，就测了，果不其然🐑了，我应该是很危险了。","keywords":"核酸,羊了","cover":"/p/850ce73f/image-20221219212509735.png","content":"<p>室友这几天不舒服，就测了，果不其然🐑了，我应该是很危险了。</p>\n<span id=\"more\"></span>\n<p><img src=\"/p/850ce73f/image-20221219212509735.png\" alt=\"抗原检测阳性\"></p>\n","raw":null,"categories":[{"name":"杂记","path":"api/categories/杂记.json"}],"tags":[{"name":"疫情","path":"api/tags/疫情.json"}]},{"title":"疫情三年，是时候结束了！","slug":"20221212","date":"2022-12-12T12:56:26.000Z","updated":"2023-02-04T06:41:58.424Z","comments":null,"realpath":null,"path":"api/articles/20221212.json","excerpt":"疫情三年，什么变化了？什么没有变化呢？疫情三年变化的是，出现了健康码、行程码、核酸检测疫情三年变化的是，到处都贴起了二维码、出行限制、经济发展滞缓","keywords":"疫情,新冠疫情,行程码,核酸检测","cover":"/p/d223f900/image-20221212210631735.png","content":"<blockquote>\n<p>疫情三年，什么变化了？什么没有变化呢？</p>\n</blockquote>\n<p>疫情三年变化的是，出现了健康码、行程码、核酸检测</p>\n<p>疫情三年变化的是，到处都贴起了二维码、出行限制、经济发展滞缓</p>\n<span id=\"more\"></span>\n<p><img src=\"/p/d223f900/image-20221212210631735.png\" alt=\"核酸检测点即将拆除\"></p>\n<p>三年疫情，突然放开，大家还是有些许不适应</p>\n<p>还是习惯的过门卡掏出手机，还是习惯每天准点测核酸</p>\n<p>三年疫情对国家也有很大冲击，国家开始发行国债，用来弥补这三年的核酸检测国家政府开支</p>\n<p>三年疫情对经济冲击夜很大，许多行业都开始收紧，业务调整，裁员潮，都开始 “过冬” 了</p>\n<p><img src=\"/p/d223f900/image-20221212210553921.png\" alt=\"行程码下线\"></p>\n<p>不变的是啥呢？</p>\n<p>唯一不变的估计是人吗？</p>\n","raw":null,"categories":[{"name":"杂记","path":"api/categories/杂记.json"}],"tags":[{"name":"疫情","path":"api/tags/疫情.json"}]},{"title":"被围绕的区域——LeetCode130","slug":"surrounded-regions","date":"2022-02-08T11:56:55.000Z","updated":"2023-02-04T06:41:58.512Z","comments":null,"realpath":null,"path":"api/articles/surrounded-regions.json","excerpt":null,"keywords":"矩阵,栈,深度遍历,广度遍历","cover":"/p/52a5c0f5/xogrid.jpg","content":"<p>给你一个  <code>m x n</code>  的矩阵  <code>board</code>  ，由若干字符  <code>'X'</code>  和  <code>'O'</code>  ，找到所有被  <code>'X'</code>  围绕的区域，并将这些区域里所有的  <code>'O'</code>  用  <code>'X'</code>  填充。</p>\n<p><img src=\"/p/52a5c0f5/xogrid.jpg\" alt=\"img\"></p>\n<p>示例 1</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：board = [[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;O&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;O&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;X&quot;,&quot;X&quot;]]</span><br><span class=\"line\">输出：[[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;X&quot;,&quot;X&quot;]]</span><br><span class=\"line\">解释：被围绕的区间不会存在于边界上，换句话说，任何边界上的 &#x27;O&#x27; 都不会被填充为 &#x27;X&#x27;。 任何不在边界上，或不与边界上的 &#x27;O&#x27; 相连的 &#x27;O&#x27; 最终都会被填充为 &#x27;X&#x27;。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。</span><br></pre></td></tr></table></figure>\n<p>示例 2</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：board = [[&quot;X&quot;]]</span><br><span class=\"line\">输出：[[&quot;X&quot;]]</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">m == board.length</span><br><span class=\"line\">n == board[i].length</span><br><span class=\"line\">1 &lt;= m, n &lt;= 200</span><br><span class=\"line\">board[i][j] 为 &#x27;X&#x27; 或 &#x27;O&#x27;</span><br></pre></td></tr></table></figure>\n<h3 id=\"解题\"><a class=\"markdownIt-Anchor\" href=\"#解题\">#</a> 解题</h3>\n<p>写在前面<br>\n本题给定的矩阵中有三种元素：</p>\n<ul>\n<li>\n<p>字母 X；</p>\n</li>\n<li>\n<p>被字母 X 包围的字母 O；</p>\n</li>\n<li>\n<p>没有被字母 X 包围的字母 O。</p>\n</li>\n</ul>\n<p>本题要求将所有被字母 X 包围的字母 O 都变为字母 X ，但很难判断哪些 O 是被包围的，哪些 O 不是被包围的。</p>\n<p>注意到题目解释中提到： <code>任何边界上的 O 都不会被填充为 X</code> 。 我们可以想到，所有的不被包围的 O 都直接或间接与边界上的 O 相连。我们可以利用这个性质判断 O 是否在边界上，具体地说：</p>\n<ul>\n<li>对于每一个边界上的 O，我们以它为起点，标记所有与它直接或间接相连的字母 O；<br>\n最后我们遍历这个矩阵，对于每一个字母：</li>\n<li>如果该字母被标记过，则该字母为没有被字母 X 包围的字母 O，我们将其还原为字母 O；<br>\n如果该字母没有被标记过，则该字母为被字母 X 包围的字母 O，我们将其修改为字母 X。</li>\n</ul>\n<h3 id=\"方法一深度优先搜索\"><a class=\"markdownIt-Anchor\" href=\"#方法一深度优先搜索\">#</a> 方法一：深度优先搜索</h3>\n<h4 id=\"思路及解法\"><a class=\"markdownIt-Anchor\" href=\"#思路及解法\">#</a> 思路及解法</h4>\n<p>我们可以使用深度优先搜索实现标记操作。在下面的代码中，我们把标记过的字母 O 修改为字母 A。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> n, m;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">solve</span><span class=\"params\">(<span class=\"type\">char</span>[][] board)</span> &#123;</span><br><span class=\"line\">        n = board.length;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        m = board[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            dfs(board, i, <span class=\"number\">0</span>);</span><br><span class=\"line\">            dfs(board, i, m - <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; m - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">            dfs(board, <span class=\"number\">0</span>, i);</span><br><span class=\"line\">            dfs(board, n - <span class=\"number\">1</span>, i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; m; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (board[i][j] == <span class=\"string\">&#x27;A&#x27;</span>) &#123;</span><br><span class=\"line\">                    board[i][j] = <span class=\"string\">&#x27;O&#x27;</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (board[i][j] == <span class=\"string\">&#x27;O&#x27;</span>) &#123;</span><br><span class=\"line\">                    board[i][j] = <span class=\"string\">&#x27;X&#x27;</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">dfs</span><span class=\"params\">(<span class=\"type\">char</span>[][] board, <span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x &lt; <span class=\"number\">0</span> || x &gt;= n || y &lt; <span class=\"number\">0</span> || y &gt;= m || board[x][y] != <span class=\"string\">&#x27;O&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        board[x][y] = <span class=\"string\">&#x27;A&#x27;</span>;</span><br><span class=\"line\">        dfs(board, x + <span class=\"number\">1</span>, y);</span><br><span class=\"line\">        dfs(board, x - <span class=\"number\">1</span>, y);</span><br><span class=\"line\">        dfs(board, x, y + <span class=\"number\">1</span>);</span><br><span class=\"line\">        dfs(board, x, y - <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"复杂度分析\"><a class=\"markdownIt-Anchor\" href=\"#复杂度分析\">#</a> 复杂度分析</h4>\n<ul>\n<li>\n<p>时间复杂度： <code>O(n×m)</code> ，其中  <code>n</code>  和  <code>m </code> 分别为矩阵的行数和列数。深度优先搜索过程中，每一个点至多只会被标记一次。</p>\n</li>\n<li>\n<p>空间复杂度： <code>O(n×m)</code> ，其中  <code>n</code>  和  <code>m</code>  分别为矩阵的行数和列数。主要为深度优先搜索的栈的开销。</p>\n</li>\n</ul>\n<h3 id=\"方法二广度优先搜索\"><a class=\"markdownIt-Anchor\" href=\"#方法二广度优先搜索\">#</a> 方法二：广度优先搜索</h3>\n<h4 id=\"思路及解法-2\"><a class=\"markdownIt-Anchor\" href=\"#思路及解法-2\">#</a> 思路及解法</h4>\n<p>我们可以使用广度优先搜索实现标记操作。在下面的代码中，我们把标记过的字母  <code>O</code>  修改为字母  <code>A</code> 。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span>[] dx = &#123;<span class=\"number\">1</span>, -<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"type\">int</span>[] dy = &#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, -<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">solve</span><span class=\"params\">(<span class=\"type\">char</span>[][] board)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> board.length;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">m</span> <span class=\"operator\">=</span> board[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">        Queue&lt;<span class=\"type\">int</span>[]&gt; queue = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;<span class=\"type\">int</span>[]&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (board[i][<span class=\"number\">0</span>] == <span class=\"string\">&#x27;O&#x27;</span>) &#123;</span><br><span class=\"line\">                queue.offer(<span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[]&#123;i, <span class=\"number\">0</span>&#125;);</span><br><span class=\"line\">                board[i][<span class=\"number\">0</span>] = <span class=\"string\">&#x27;A&#x27;</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (board[i][m - <span class=\"number\">1</span>] == <span class=\"string\">&#x27;O&#x27;</span>) &#123;</span><br><span class=\"line\">                queue.offer(<span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[]&#123;i, m - <span class=\"number\">1</span>&#125;);</span><br><span class=\"line\">                board[i][m - <span class=\"number\">1</span>] = <span class=\"string\">&#x27;A&#x27;</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; m - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (board[<span class=\"number\">0</span>][i] == <span class=\"string\">&#x27;O&#x27;</span>) &#123;</span><br><span class=\"line\">                queue.offer(<span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[]&#123;<span class=\"number\">0</span>, i&#125;);</span><br><span class=\"line\">                board[<span class=\"number\">0</span>][i] = <span class=\"string\">&#x27;A&#x27;</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (board[n - <span class=\"number\">1</span>][i] == <span class=\"string\">&#x27;O&#x27;</span>) &#123;</span><br><span class=\"line\">                queue.offer(<span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[]&#123;n - <span class=\"number\">1</span>, i&#125;);</span><br><span class=\"line\">                board[n - <span class=\"number\">1</span>][i] = <span class=\"string\">&#x27;A&#x27;</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!queue.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span>[] cell = queue.poll();</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">x</span> <span class=\"operator\">=</span> cell[<span class=\"number\">0</span>], y = cell[<span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++) &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">mx</span> <span class=\"operator\">=</span> x + dx[i], my = y + dy[i];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mx &lt; <span class=\"number\">0</span> || my &lt; <span class=\"number\">0</span> || mx &gt;= n || my &gt;= m || board[mx][my] != <span class=\"string\">&#x27;O&#x27;</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                queue.offer(<span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[]&#123;mx, my&#125;);</span><br><span class=\"line\">                board[mx][my] = <span class=\"string\">&#x27;A&#x27;</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; m; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (board[i][j] == <span class=\"string\">&#x27;A&#x27;</span>) &#123;</span><br><span class=\"line\">                    board[i][j] = <span class=\"string\">&#x27;O&#x27;</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (board[i][j] == <span class=\"string\">&#x27;O&#x27;</span>) &#123;</span><br><span class=\"line\">                    board[i][j] = <span class=\"string\">&#x27;X&#x27;</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"复杂度分析-2\"><a class=\"markdownIt-Anchor\" href=\"#复杂度分析-2\">#</a> 复杂度分析</h4>\n<ul>\n<li>\n<p>时间复杂度： <code>O(n×m)</code> ，其中  <code>n</code>  和  <code>m</code>  分别为矩阵的行数和列数。广度优先搜索过程中，每一个点至多只会被标记一次。</p>\n</li>\n<li>\n<p>空间复杂度： <code>O(n×m)</code> ，其中  <code>n</code>  和  <code>m</code>  分别为矩阵的行数和列数。主要为广度优先搜索的队列的开销。</p>\n</li>\n</ul>\n","raw":null,"categories":[{"name":"LeetCode","path":"api/categories/LeetCode.json"},{"name":"算法","path":"api/categories/算法.json"},{"name":"java","path":"api/categories/java.json"}],"tags":[{"name":"矩阵","path":"api/tags/矩阵.json"},{"name":"深度遍历","path":"api/tags/深度遍历.json"},{"name":"广度遍历","path":"api/tags/广度遍历.json"}]},{"title":"JVM调优——X参数,方法内联","slug":"jvm-params","date":"2022-01-12T15:06:08.000Z","updated":"2023-02-04T06:41:58.444Z","comments":null,"realpath":null,"path":"api/articles/jvm-params.json","excerpt":"JVM 的 -X  参数是非标准参数，在不同版本的 JVM 中，参数可能会有所不同，可以通过 java -X  查看非标准参数","keywords":"jvm调优,mixed,混合,xint,解释,comp,纯编译,方法内联","cover":"/p/638c83fa/logo","content":"<p>JVM 的 <code>-X</code>  参数是非标准参数，在不同版本的 JVM 中，参数可能会有所不同，可以通过 <code>java -X</code>  查看非标准参数</p>\n<span id=\"more\"></span>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; java -X</span><br><span class=\"line\"></span><br><span class=\"line\">    -Xbatch           禁用后台编译</span><br><span class=\"line\">    -Xbootclasspath/a:&lt;以 : 分隔的目录和 zip/jar 文件&gt;</span><br><span class=\"line\">                      附加在引导类路径末尾</span><br><span class=\"line\">    -Xcheck:jni       对 JNI 函数执行其他检查</span><br><span class=\"line\">    -Xcomp            强制在首次调用时编译方法</span><br><span class=\"line\">    -Xdebug           不执行任何操作。为实现向后兼容而提供。</span><br><span class=\"line\">    -Xdiag            显示附加诊断消息</span><br><span class=\"line\">    -Xfuture          启用最严格的检查，预期将来的默认值。</span><br><span class=\"line\">                      此选项已过时，可能会在</span><br><span class=\"line\">                      未来发行版中删除。</span><br><span class=\"line\">    -Xint             仅解释模式执行</span><br><span class=\"line\">    -Xinternalversion</span><br><span class=\"line\">                      显示比 -version 选项更详细的</span><br><span class=\"line\">                      JVM 版本信息</span><br><span class=\"line\">    -Xlog:&lt;opts&gt;      配置或启用采用 Java 虚拟</span><br><span class=\"line\">                      机 (Java Virtual Machine, JVM) 统一记录框架进行事件记录。使用 -Xlog:help</span><br><span class=\"line\">                      可了解详细信息。</span><br><span class=\"line\">    -Xloggc:&lt;file&gt;    将 GC 状态记录在文件中（带时间戳）。</span><br><span class=\"line\">                      此选项已过时，可能会在</span><br><span class=\"line\">                      将来的发行版中删除。它将替换为 -Xlog:gc:&lt;file&gt;。</span><br><span class=\"line\">    -Xmixed           混合模式执行（默认值）</span><br><span class=\"line\">    -Xmn&lt;size&gt;        为年轻代（新生代）设置初始和最大堆大小</span><br><span class=\"line\">                      （以字节为单位）</span><br><span class=\"line\">    -Xms&lt;size&gt;        设置初始 Java 堆大小</span><br><span class=\"line\">    -Xmx&lt;size&gt;        设置最大 Java 堆大小</span><br><span class=\"line\">    -Xnoclassgc       禁用类垃圾收集</span><br><span class=\"line\">    -Xrs              减少 Java/VM 对操作系统信号的使用（请参见文档）</span><br><span class=\"line\">    -Xshare:auto      在可能的情况下使用共享类数据（默认值）</span><br><span class=\"line\">    -Xshare:off       不尝试使用共享类数据</span><br><span class=\"line\">    -Xshare:on        要求使用共享类数据，否则将失败。</span><br><span class=\"line\">                      这是一个测试选项，可能导致间歇性</span><br><span class=\"line\">                      故障。不应在生产环境中使用它。</span><br><span class=\"line\">    -XshowSettings    显示所有设置并继续</span><br><span class=\"line\">    -XshowSettings:all</span><br><span class=\"line\">                      显示所有设置并继续</span><br><span class=\"line\">    -XshowSettings:locale</span><br><span class=\"line\">                      显示所有与区域设置相关的设置并继续</span><br><span class=\"line\">    -XshowSettings:properties</span><br><span class=\"line\">                      显示所有属性设置并继续</span><br><span class=\"line\">    -XshowSettings:vm</span><br><span class=\"line\">                      显示所有与 vm 相关的设置并继续</span><br><span class=\"line\">    -XshowSettings:system</span><br><span class=\"line\">                      （仅 Linux）显示主机系统或容器</span><br><span class=\"line\">                      配置并继续</span><br><span class=\"line\">    -Xss&lt;size&gt;        设置 Java 线程堆栈大小</span><br><span class=\"line\">    -Xverify          设置字节码验证器的模式</span><br><span class=\"line\">                      请注意，选项 -Xverify:none 已过时，</span><br><span class=\"line\">                      可能会在未来发行版中删除。</span><br><span class=\"line\">    --add-reads &lt;module&gt;=&lt;target-module&gt;(,&lt;target-module&gt;)*</span><br><span class=\"line\">                      更新 &lt;module&gt; 以读取 &lt;target-module&gt;，而无论</span><br><span class=\"line\">                      模块如何声明。</span><br><span class=\"line\">                      &lt;target-module&gt; 可以是 ALL-UNNAMED，将读取所有未命名</span><br><span class=\"line\">                      模块。</span><br><span class=\"line\">    --add-exports &lt;module&gt;/&lt;package&gt;=&lt;target-module&gt;(,&lt;target-module&gt;)*</span><br><span class=\"line\">                      更新 &lt;module&gt; 以将 &lt;package&gt; 导出到 &lt;target-module&gt;，</span><br><span class=\"line\">                      而无论模块如何声明。</span><br><span class=\"line\">                      &lt;target-module&gt; 可以是 ALL-UNNAMED，将导出到所有</span><br><span class=\"line\">                      未命名模块。</span><br><span class=\"line\">    --add-opens &lt;module&gt;/&lt;package&gt;=&lt;target-module&gt;(,&lt;target-module&gt;)*</span><br><span class=\"line\">                      更新 &lt;module&gt; 以在 &lt;target-module&gt; 中打开</span><br><span class=\"line\">                      &lt;package&gt;，而无论模块如何声明。</span><br><span class=\"line\">    --illegal-access=&lt;value&gt;</span><br><span class=\"line\">                      允许或拒绝通过未命名模块中的代码对命名模块中的</span><br><span class=\"line\">                      类型成员进行访问。</span><br><span class=\"line\">                      &lt;value&gt; 为 &quot;deny&quot;、&quot;permit&quot;、&quot;warn&quot; 或 &quot;debug&quot; 之一</span><br><span class=\"line\">                      此选项将在未来发行版中删除。</span><br><span class=\"line\">    --limit-modules &lt;module name&gt;[,&lt;module name&gt;...]</span><br><span class=\"line\">                      限制可观察模块的领域</span><br><span class=\"line\">    --patch-module &lt;module&gt;=&lt;file&gt;(:&lt;file&gt;)*</span><br><span class=\"line\">                      使用 JAR 文件或目录中的类和资源</span><br><span class=\"line\">                      覆盖或增强模块。</span><br><span class=\"line\">    --source &lt;version&gt;</span><br><span class=\"line\">                      设置源文件模式中源的版本。</span><br><span class=\"line\"></span><br><span class=\"line\">这些额外选项如有更改, 恕不另行通知。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">以下选项是特定于 macOS 的选项：</span><br><span class=\"line\">    -XstartOnFirstThread</span><br><span class=\"line\">                      在第一个 (AppKit) 线程上运行 main() 方法</span><br><span class=\"line\">    -Xdock:name=&lt;application name&gt;</span><br><span class=\"line\">                      覆盖停靠栏中显示的默认应用程序名称</span><br><span class=\"line\">    -Xdock:icon=&lt;path to icon file&gt;</span><br><span class=\"line\">                     覆盖停靠栏中显示的默认图标</span><br></pre></td></tr></table></figure>\n<h2 id=\"-xint-xcomp与-xmixed参数\"><a class=\"markdownIt-Anchor\" href=\"#-xint-xcomp与-xmixed参数\">#</a> -Xint、-Xcomp 与 - Xmixed 参数</h2>\n<h3 id=\"-xint参数\"><a class=\"markdownIt-Anchor\" href=\"#-xint参数\">#</a> -Xint 参数</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在解释模式（interpreted mode）下，-Xint标记会强制JVM执行所有的字节码，这当然会降低运行速度，通常低10倍或更多。</span><br></pre></td></tr></table></figure>\n<p><img src=\"/p/638c83fa/20190729122640228.png\" alt=\"interpreted-mode\"></p>\n<h3 id=\"-xcomp参数\"><a class=\"markdownIt-Anchor\" href=\"#-xcomp参数\">#</a> -Xcomp 参数</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Xcomp参数与-Xint正好相反，JVM在第一次使用时会把所有的字节码编译成本地代码，从而带来最大程度的优化。</span><br></pre></td></tr></table></figure>\n<p><img src=\"/p/638c83fa/20190729122919297.png\" alt=\"compiled-mode\"></p>\n<p>然而，很多应用在使用 - Xcomp 也会有一些性能损失，当然这笔 - Xint 损失的少，原因是 - Xcomp 没有让 JVM 启用 JIT 编译器的全部功能。JIT 编译器可以对是否需要编译做出判断。如果所有代码都需要进行编译的话，对于一些只执行一次的代码就没有意义了。</p>\n<h3 id=\"-xmixed参数\"><a class=\"markdownIt-Anchor\" href=\"#-xmixed参数\">#</a> -Xmixed 参数</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-Xmixed是混合模式，将解释模式和变异模式进行混合使用，有JVM自己决定，这是JVM的默认模式，也是推荐模式</span><br></pre></td></tr></table></figure>\n<p><img src=\"/p/638c83fa/2019072913573773.png\" alt=\"mixed-model\"></p>\n<h2 id=\"jvm方法内联优化\"><a class=\"markdownIt-Anchor\" href=\"#jvm方法内联优化\">#</a> JVM 方法内联优化</h2>\n<h3 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\">#</a> 前言</h3>\n<p>在日常中工作中，我们时不时会代码进行一些优化，比如用新的算法，简化计算逻辑，减少计算量等。对于 java 程序来说，除了开发者本身对代码优化之外，还有一个 &quot;人&quot; 也在背后默默的优化我们的代码，这个 &quot;人&quot; 就是 jvm。jvm 会帮我们分析出热点代码，优化代码逻辑。其中 jvm 最常做的优化之一就是：方法内联优化。</p>\n<h3 id=\"方法内联\"><a class=\"markdownIt-Anchor\" href=\"#方法内联\">#</a> 方法内联</h3>\n<p>什么是方法内联？又可以叫做函数内联，java 中方法可等同于其它语言中的函数。关于方法内联维基百科上面解释是：</p>\n<blockquote>\n<p>在计算机科学中，内联函数（有时称作在线函数或编译时期展开函数）是一种编程语言结构，用来建议编译器对一些特殊函数进行内联扩展（有时称作在线扩展）；也就是说<strong>建议编译器将指定的函数体插入并取代每一处调用该函数的地方（上下文），从而节省了每次调用函数带来的额外时间开支。</strong></p>\n</blockquote>\n<p>简单通俗的讲就是把方法内部调用的其它方法的逻辑，嵌入到自身的方法中去，变成自身的一部分，之后不再调用该方法，从而节省调用函数带来的额外开支。</p>\n<h3 id=\"函数调用开销\"><a class=\"markdownIt-Anchor\" href=\"#函数调用开销\">#</a> 函数调用开销</h3>\n<p>之所以出现方法内联是因为函数调用除了执行自身逻辑的开销外，还有一些不为人知的额外开销。这部分额外的开销主要来自方法栈帧的生成、参数字段的压入、栈帧的弹出、还有指令执行地址的跳转。比如有下面这样代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">function_A</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//do something</span></span><br><span class=\"line\">    function_B(a,b);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">function_B</span><span class=\"params\">(<span class=\"type\">int</span> c, <span class=\"type\">int</span> d)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//do something</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span>&#123;</span><br><span class=\"line\">     function_A(<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>则代码的执行过程如下：</p>\n<p><img src=\"/p/638c83fa/247487dfbaf1ec956441e9e5e2f85817_1440w.jpg\" alt=\"img\"></p>\n<p>所以如果 java 中方法调用嵌套过多或者方法过多，这种额外的开销就越多。</p>\n<p>试想一下想 get/set 这种方法调用：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getI</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setI</span><span class=\"params\">(<span class=\"type\">int</span> i)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.i = i;</span><br><span class=\"line\">&#125; </span><br></pre></td></tr></table></figure>\n<p>很可能自身执行逻辑的开销还比不上为了调用这个方法的额外开锁。如果类似的方法被频繁的调用，则真正相对执行效率就会很低，虽然这类方法的执行时间很短。这也是为什么 jvm 会在热点代码中执行方法内联的原因，这样的话就可以省去调用调用函数带来的额外开支。</p>\n<p>这里举个内联的可能形式：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span>  <span class=\"title function_\">add</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b , <span class=\"type\">int</span> c, <span class=\"type\">int</span> d)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> add(a, b) + add(c, d);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">add</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>内联之后：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"type\">int</span>  <span class=\"title function_\">add</span><span class=\"params\">(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b , <span class=\"type\">int</span> c, <span class=\"type\">int</span> d)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> a + b + c + d;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样除了本身的相加逻辑的开销，比内联前减少了二次调用函数带来的额外开销。</p>\n<h3 id=\"内联条件\"><a class=\"markdownIt-Anchor\" href=\"#内联条件\">#</a> 内联条件</h3>\n<p>一个方法如果满足以下条件就很可能被 jvm 内联。</p>\n<p>1、热点代码： 如果一个方法的执行频率很高就表示优化的潜在价值就越大。那代码执行多少次才能确定为热点代码？这是根据编译器的编译模式来决定的。如果是客户端编译模式则次数是 1500，服务端编译模式是 10000。次数的大小可以通过 - XX:CompileThreshold 来调整。</p>\n<p>2、方法体不能太大：jvm 中被内联的方法会编译成机器码放在 code cache 中。如果方法体太大，则能缓存热点方法就少，反而会影响性能。</p>\n<p>3、如果希望方法被内联，尽量用 private、static、final 修饰，这样 jvm 可以直接内联。如果是 public、protected 修饰方法 jvm 则需要进行类型判断，因为这些方法可以被子类继承和覆盖，jvm 需要判断内联究竟内联是父类还是其中某个子类的方法。</p>\n<blockquote>\n<p>所以了解 jvm 方法内联机制之后，会有助于我们工作中写出能让 jvm 更容易优化的代码，有助于提升程序的性能。</p>\n</blockquote>\n","raw":null,"categories":[{"name":"java","path":"api/categories/java.json"}],"tags":[{"name":"jvm调优","path":"api/tags/jvm调优.json"},{"name":"混合模式","path":"api/tags/混合模式.json"},{"name":"解释模式","path":"api/tags/解释模式.json"},{"name":"纯编译模式","path":"api/tags/纯编译模式.json"}]},{"title":"巧妙使用正则——去除小数点后多余的零","slug":"js-regexp","date":"2022-01-10T13:51:44.000Z","updated":"2023-02-04T06:41:58.444Z","comments":null,"realpath":null,"path":"api/articles/js-regexp.json","excerpt":"直接上代码1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>const arr=[&#x27;1200.00100&#x27;,&#x27;1200.00000&#x27;,&#x27;1200.&#x27;,&#x27;1200&#x27;,&#x27;1200.10000&#x27;,&#x27;0.120010000&#x27;,&#x27;0.000011111&#x27;]<br>const regexp=/(?:\\.0*|(\\.\\d+?)0+)$/<br>arr.forEach((item)=&gt;&#123;<br>    console.log(item.replace(regexp,&#x27;$1&#x27;))<br>&#125;)<br><br>// &gt; 1200.001<br>// &gt; 1200<br>// &gt; 1200<br>// &gt; 1200<br>// &gt; 1200.1<br>// &gt; 0.12001<br>// &gt; 0.000011111<br>","keywords":"正则,js,去除零","cover":"/p/9195a466/image.svg","content":"<p>直接上代码</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr=[<span class=\"string\">&#x27;1200.00100&#x27;</span>,<span class=\"string\">&#x27;1200.00000&#x27;</span>,<span class=\"string\">&#x27;1200.&#x27;</span>,<span class=\"string\">&#x27;1200&#x27;</span>,<span class=\"string\">&#x27;1200.10000&#x27;</span>,<span class=\"string\">&#x27;0.120010000&#x27;</span>,<span class=\"string\">&#x27;0.000011111&#x27;</span>]</span><br><span class=\"line\"><span class=\"keyword\">const</span> regexp=<span class=\"regexp\">/(?:\\.0*|(\\.\\d+?)0+)$/</span></span><br><span class=\"line\">arr.<span class=\"title function_\">forEach</span>(<span class=\"function\">(<span class=\"params\">item</span>)=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(item.<span class=\"title function_\">replace</span>(regexp,<span class=\"string\">&#x27;$1&#x27;</span>))</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// &gt; 1200.001</span></span><br><span class=\"line\"><span class=\"comment\">// &gt; 1200</span></span><br><span class=\"line\"><span class=\"comment\">// &gt; 1200</span></span><br><span class=\"line\"><span class=\"comment\">// &gt; 1200</span></span><br><span class=\"line\"><span class=\"comment\">// &gt; 1200.1</span></span><br><span class=\"line\"><span class=\"comment\">// &gt; 0.12001</span></span><br><span class=\"line\"><span class=\"comment\">// &gt; 0.000011111</span></span><br></pre></td></tr></table></figure>\n<span id=\"more\"></span>\n<p>正则可视化：</p>\n<p><img src=\"/p/9195a466/image.svg\" alt=\"image\"></p>\n<p>推荐个可视化网址：<a href=\"https://regexper.com/\">https://regexper.com/</a></p>\n<p>再解释下正则的意思 <code>(?:.0*|(.\\d+?)0+)$</code></p>\n<p>先分解成 4 部分</p>\n<ol>\n<li><code>(?:reg1|reg2)</code>  - 它是一个正则分组非捕获组，要么匹配 reg1，要么匹配 reg2，优先匹配 reg1，加上？: 不对捕获组记录</li>\n<li><code>.0*</code>  - 表示匹配一个。开头，后边跟着 0 或 0 个以上数量的 0，且不进行捕获，所以在填充 $1 时，就是个空值</li>\n<li><code>(.\\d+?)0+</code>  - 它是一个捕获组，匹配一个。开头后边跟着非贪婪（懒惰）匹配任意数字，接着在末尾尽可能多的匹配 0 这个字符，匹配完成后，生成一个捕获组内容</li>\n<li><code>$</code>  - 表示匹配结果需要以 0 作为结尾</li>\n</ol>\n<h2 id=\"正则分组\"><a class=\"markdownIt-Anchor\" href=\"#正则分组\">#</a> 正则分组</h2>\n<ul>\n<li>\n<p>普通捕获组</p>\n<p>从正则表达式左侧开始，每出现一个左括号 &quot;(&quot; 记做一个分组，分组编号从 1 开始。0 代表整个表达式。</p>\n<p>对于时间字符串：2017-04-25，表达式如下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(\\\\d&#123;<span class=\"number\">4</span>&#125;)-((\\\\d&#123;<span class=\"number\">2</span>&#125;)-(\\\\d&#123;<span class=\"number\">2</span>&#125;))</span><br></pre></td></tr></table></figure>\n<p>有 4 个左括号，所以有 4 个分组:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">编号</th>\n<th style=\"text-align:left\">捕获组</th>\n<th style=\"text-align:left\">匹配</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">0</td>\n<td style=\"text-align:left\">(\\d{4})-((\\d{2})-(\\d{2}))</td>\n<td style=\"text-align:left\">2017-04-25</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">(\\d{4})</td>\n<td style=\"text-align:left\">2017</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">((\\d{2})-(\\d{2}))</td>\n<td style=\"text-align:left\">04-25</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">3</td>\n<td style=\"text-align:left\">(\\d{2})</td>\n<td style=\"text-align:left\">04</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">4</td>\n<td style=\"text-align:left\">(\\d{2})</td>\n<td style=\"text-align:left\">25</td>\n</tr>\n</tbody>\n</table>\n</li>\n<li>\n<p>命名捕获组</p>\n<p>每个以左括号开始的捕获组，都紧跟着 <strong>?</strong>，而后才是正则表达式。</p>\n<p>对于时间字符串：2017-04-25，表达式如下:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(?&lt;year&gt;\\\\d&#123;<span class=\"number\">4</span>&#125;)-(?&lt;md&gt;(?&lt;month&gt;\\\\d&#123;<span class=\"number\">2</span>&#125;)-(?&lt;date&gt;\\\\d&#123;<span class=\"number\">2</span>&#125;))</span><br></pre></td></tr></table></figure>\n<p>有 4 个命名的捕获组，分别是:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">编号</th>\n<th style=\"text-align:left\">名称</th>\n<th style=\"text-align:left\">捕获组</th>\n<th style=\"text-align:left\">匹配</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">0</td>\n<td style=\"text-align:left\">0</td>\n<td style=\"text-align:left\">(?\\d{4})-(?(?\\d{2})-(?\\d{2}))</td>\n<td style=\"text-align:left\">2017-04-25</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">year</td>\n<td style=\"text-align:left\">(?\\d{4})-</td>\n<td style=\"text-align:left\">2017</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">md</td>\n<td style=\"text-align:left\">(?(?\\d{2})-(?\\d{2}))</td>\n<td style=\"text-align:left\">04-25</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">3</td>\n<td style=\"text-align:left\">month</td>\n<td style=\"text-align:left\">(?\\d{2})</td>\n<td style=\"text-align:left\">04</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">4</td>\n<td style=\"text-align:left\">date</td>\n<td style=\"text-align:left\">(?\\d{2})</td>\n<td style=\"text-align:left\">25</td>\n</tr>\n</tbody>\n</table>\n<p>命名的捕获组同样也可以使用编号获取相应值。</p>\n</li>\n</ul>\n<h2 id=\"非捕获组\"><a class=\"markdownIt-Anchor\" href=\"#非捕获组\">#</a> 非捕获组</h2>\n<p>在左括号后紧跟  <code>?:</code> ，而后再加上正则表达式，构成非捕获组 <strong>(?:Expression)</strong>。</p>\n<p>对于时间字符串：2017-04-25，表达式如下:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(?:\\\\d&#123;<span class=\"number\">4</span>&#125;)-((\\\\d&#123;<span class=\"number\">2</span>&#125;)-(\\\\d&#123;<span class=\"number\">2</span>&#125;))</span><br></pre></td></tr></table></figure>\n<p>这个正则表达式虽然有四个左括号，理论上有 4 个捕获组。但是第一组 <strong>(?:\\d{4})</strong>，其实是被忽略的。当使用 matcher.group (4) 时，系统会报错。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">编号</th>\n<th style=\"text-align:left\">捕获组</th>\n<th style=\"text-align:left\">匹配</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">0</td>\n<td style=\"text-align:left\">(\\d{4})-((\\d{2})-(\\d{2}))</td>\n<td style=\"text-align:left\">2017-04-25</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">((\\d{2})-(\\d{2}))</td>\n<td style=\"text-align:left\">04-25</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">(\\d{2})</td>\n<td style=\"text-align:left\">04</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">3</td>\n<td style=\"text-align:left\">(\\d{2})</td>\n<td style=\"text-align:left\">25</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"非贪婪懒惰匹配\"><a class=\"markdownIt-Anchor\" href=\"#非贪婪懒惰匹配\">#</a> 非贪婪 (懒惰) 匹配</h2>\n<p>** 贪婪匹配:** 正则表达式一般趋向于最大长度匹配，也就是所谓的贪婪匹配。如上面使用模式 p 匹配字符串 str，结果就是匹配到：<strong>abcaxc</strong>(ab*c)。</p>\n<p><strong>非贪婪匹配</strong>：就是匹配到结果就好，就少的匹配字符。如上面使用模式 p 匹配字符串 str，结果就是匹配到：<strong>abc</strong>(ab*c)。</p>\n<p>问号可以表示重复前面内容的 0 次或一次，也就是要么不出现，要么出现一次</p>\n<p>示例 1：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">string</span> <span class=\"variable\">pattern1</span> <span class=\"operator\">=</span> @<span class=\"string\">&quot;a.*?c&quot;</span>;   <span class=\"comment\">// non-greedy match </span></span><br><span class=\"line\"><span class=\"type\">Regex</span> <span class=\"variable\">regex</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Regex</span>(pattern1);</span><br><span class=\"line\">regex.Match(<span class=\"string\">&quot;abcabc&quot;</span>); <span class=\"comment\">// return &quot;abc&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">## 结果：abc</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\">s=<span class=\"string\">&#x27;hello 1234567 world&#x27;</span></span><br><span class=\"line\">res = re.<span class=\"keyword\">match</span>(<span class=\"string\">&#x27;he.*?(\\d).*rld$&#x27;</span>,s)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(res.group(<span class=\"number\">1</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 结果：123456</span></span><br></pre></td></tr></table></figure>\n<p>常用非贪婪表达式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*? 重复任意次，但尽可能少重复</span><br><span class=\"line\">+? 重复1次或更多次，但尽可能少重复</span><br><span class=\"line\">?? 重复0次或1次，但尽可能少重复</span><br><span class=\"line\">&#123;n,m&#125;? 重复n到m次，但尽可能少重复</span><br><span class=\"line\">&#123;n,&#125;? 重复n次以上，但尽可能少重复</span><br></pre></td></tr></table></figure>","raw":null,"categories":[{"name":"前端","path":"api/categories/前端.json"}],"tags":[{"name":"正则","path":"api/tags/正则.json"},{"name":"js","path":"api/tags/js.json"},{"name":"去除零","path":"api/tags/去除零.json"}]},{"title":"单词接龙——leetcode127","slug":"word-ladder","date":"2022-01-09T10:38:08.000Z","updated":"2023-02-04T06:41:58.536Z","comments":null,"realpath":null,"path":"api/articles/word-ladder.json","excerpt":null,"keywords":"算法,leetcode,单词接龙","cover":"/p/fbb9fe6d/leetcode127.png","content":"<h1 id=\"题目描述\"><a class=\"markdownIt-Anchor\" href=\"#题目描述\">#</a> 题目描述</h1>\n<p>字典 wordList 中从单词 beginWord 和 endWord 的 转换序列 是一个按下述规格形成的序列：<br>\n序列中第一个单词是  <code>beginWord</code>  。<br>\n序列中最后一个单词是  <code>endWord</code> 。<br>\n每次转换只能改变一个字母。<br>\n转换过程中的中间单词必须是字典  <code>wordList</code>  中的单词。<br>\n给你两个单词  <code>beginWord</code>  和  <code>endWord</code>  和一个字典  <code>wordList</code>  ，找到从  <code>beginWord </code> 到  <code>endWord</code>  的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回  <code>0</code> 。</p>\n<p>示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class=\"line\">输出：5</span><br><span class=\"line\">解释：一个最短转换序列是 &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;, 返回它的长度 5。</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class=\"line\">输出：0</span><br><span class=\"line\">解释：endWord &quot;cog&quot; 不在字典中，所以无法进行转换。</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 &lt;= beginWord.length &lt;= 10</span><br><span class=\"line\">endWord.length == beginWord.length</span><br><span class=\"line\">1 &lt;= wordList.length &lt;= 5000</span><br><span class=\"line\">wordList[i].length == beginWord.length</span><br><span class=\"line\">beginWord、endWord 和 wordList[i] 由小写英文字母组成</span><br><span class=\"line\">beginWord != endWord</span><br><span class=\"line\">wordList 中的所有字符串 互不相同</span><br></pre></td></tr></table></figure>\n<h1 id=\"解题\"><a class=\"markdownIt-Anchor\" href=\"#解题\">#</a> 解题</h1>\n<h3 id=\"方法一广度优先搜索-优化建图\"><a class=\"markdownIt-Anchor\" href=\"#方法一广度优先搜索-优化建图\">#</a> 方法一：广度优先搜索 + 优化建图</h3>\n<h4 id=\"思路\"><a class=\"markdownIt-Anchor\" href=\"#思路\">#</a> 思路</h4>\n<p>本题要求的是最短转换序列的长度，看到最短首先想到的就是广度优先搜索。想到广度优先搜索自然而然的就能想到图，但是本题并没有直截了当的给出图的模型，因此我们需要把它抽象成图的模型。</p>\n<p>我们可以把每个单词都抽象为一个点，如果两个单词可以只改变一个字母进行转换，那么说明他们之间有一条双向边。因此我们只需要把满足转换条件的点相连，就形成了一张图。</p>\n<p>基于该图，我们以 beginWord 为图的起点，以 endWord 为终点进行广度优先搜索，寻找 beginWord 到 endWord 的最短路径。</p>\n<h4 id=\"算法\"><a class=\"markdownIt-Anchor\" href=\"#算法\">#</a> 算法</h4>\n<p>基于上面的思路我们考虑如何编程实现。</p>\n<p>首先为了方便表示，我们先给每一个单词标号，即给每个单词分配一个 id。创建一个由单词 word 到 id 对应的映射 wordId，并将 beginWord 与 wordList 中所有的单词都加入这个映射中。之后我们检查 endWord 是否在该映射内，若不存在，则输入无解。我们可以使用哈希表实现上面的映射关系。</p>\n<p>然后我们需要建图，依据朴素的思路，我们可以枚举每一对单词的组合，判断它们是否恰好相差一个字符，以判断这两个单词对应的节点是否能够相连。但是这样效率太低，我们可以优化建图。</p>\n<p>具体地，我们可以创建虚拟节点。对于单词 hit，我们创建三个虚拟节点 <em>it、h</em>t、hi*，并让 hit 向这三个虚拟节点分别连一条边即可。如果一个单词能够转化为 hit，那么该单词必然会连接到这三个虚拟节点之一。对于每一个单词，我们枚举它连接到的虚拟节点，把该单词对应的 id 与这些虚拟节点对应的 id 相连即可。</p>\n<p>最后我们将起点加入队列开始广度优先搜索，当搜索到终点时，我们就找到了最短路径的长度。注意因为添加了虚拟节点，所以我们得到的距离为实际最短路径长度的两倍。同时我们并未计算起点对答案的贡献，所以我们应当返回距离的一半再加一的结果。</p>\n<h4 id=\"代码\"><a class=\"markdownIt-Anchor\" href=\"#代码\">#</a> 代码</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    Map&lt;String, Integer&gt; wordId = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;String, Integer&gt;();</span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; edge = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">nodeNum</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">ladderLength</span><span class=\"params\">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String word : wordList) &#123;</span><br><span class=\"line\">            addEdge(word);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        addEdge(beginWord);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!wordId.containsKey(endWord)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] dis = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[nodeNum];</span><br><span class=\"line\">        Arrays.fill(dis, Integer.MAX_VALUE);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">beginId</span> <span class=\"operator\">=</span> wordId.get(beginWord), endId = wordId.get(endWord);</span><br><span class=\"line\">        dis[beginId] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        Queue&lt;Integer&gt; que = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;Integer&gt;();</span><br><span class=\"line\">        que.offer(beginId);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!que.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">x</span> <span class=\"operator\">=</span> que.poll();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (x == endId) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> dis[endId] / <span class=\"number\">2</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> it : edge.get(x)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (dis[it] == Integer.MAX_VALUE) &#123;</span><br><span class=\"line\">                    dis[it] = dis[x] + <span class=\"number\">1</span>;</span><br><span class=\"line\">                    que.offer(it);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">addEdge</span><span class=\"params\">(String word)</span> &#123;</span><br><span class=\"line\">        addWord(word);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">id1</span> <span class=\"operator\">=</span> wordId.get(word);</span><br><span class=\"line\">        <span class=\"type\">char</span>[] array = word.toCharArray();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">length</span> <span class=\"operator\">=</span> array.length;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; length; ++i) &#123;</span><br><span class=\"line\">            <span class=\"type\">char</span> <span class=\"variable\">tmp</span> <span class=\"operator\">=</span> array[i];</span><br><span class=\"line\">            array[i] = <span class=\"string\">&#x27;*&#x27;</span>;</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">newWord</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(array);</span><br><span class=\"line\">            addWord(newWord);</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">id2</span> <span class=\"operator\">=</span> wordId.get(newWord);</span><br><span class=\"line\">            edge.get(id1).add(id2);</span><br><span class=\"line\">            edge.get(id2).add(id1);</span><br><span class=\"line\">            array[i] = tmp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">addWord</span><span class=\"params\">(String word)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!wordId.containsKey(word)) &#123;</span><br><span class=\"line\">            wordId.put(word, nodeNum++);</span><br><span class=\"line\">            edge.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;Integer&gt;());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"复杂度分析\"><a class=\"markdownIt-Anchor\" href=\"#复杂度分析\">#</a> 复杂度分析</h4>\n<ul>\n<li>时间复杂度： <code>O(N×C2)</code> 。其中  N 为 wordList 的长度， C 为列表中单词的长度。</li>\n</ul>\n<p>建图过程中，对于每一个单词，我们需要枚举它连接到的所有虚拟节点，时间复杂度为   <code>O(C)</code> ，将这些单词加入到哈希表中，时间复杂度为  <code>O(N×C)</code> ，因此总时间复杂度为  <code>O(N×C)</code> 。</p>\n<p>广度优先搜索的时间复杂度最坏情况下是 O (N \\times C) O (N×C)。每一个单词需要拓展出 O©O© 个虚拟节点，因此节点数 O (N \\times C) O (N×C)。</p>\n<ul>\n<li>空间复杂度： <code>O(N×C2)</code> 。其中 N 为 wordList 的长度，C 为列表中单词的长度。哈希表中包含  <code>O(N×C)</code>  个节点，每个节点占用空间  <code>O(C)</code> ，因此总的空间复杂度为  <code>O(N×C^2)</code> 。</li>\n</ul>\n","raw":null,"categories":[{"name":"算法","path":"api/categories/算法.json"}],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"},{"name":"单词接龙","path":"api/tags/单词接龙.json"}]},{"title":"买卖股票的最佳时机 II——LeetCode122","slug":"best-time-to-buy-and-sell-stock-ii","date":"2022-01-06T15:28:13.000Z","updated":"2023-02-04T06:41:58.440Z","comments":null,"realpath":null,"path":"api/articles/best-time-to-buy-and-sell-stock-ii.json","excerpt":"# 题目描述给定一个数组 prices ，其中 prices [i] 是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。","keywords":"leetcode,算法,贪心算法,动态规划","cover":"/p/f883163f/2022-01-06%2023.30.34.png","content":"<h1 id=\"题目描述\"><a class=\"markdownIt-Anchor\" href=\"#题目描述\">#</a> 题目描述</h1>\n<p>给定一个数组 prices ，其中 prices [i] 是一支给定股票第 i 天的价格。</p>\n<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>\n<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>\n<span id=\"more\"></span>\n<p>示例 1:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: prices = [7,1,5,3,6,4]</span><br><span class=\"line\">输出: 7</span><br></pre></td></tr></table></figure>\n<p>解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出，这笔交易所能获得利润 = 5-1 = 4 。<br>\n随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，这笔交易所能获得利润 = 6-3 = 3 。<br>\n <br>\n示例 2:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: prices = [1,2,3,4,5]</span><br><span class=\"line\">输出: 4</span><br></pre></td></tr></table></figure>\n<p>解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出，这笔交易所能获得利润 = 5-1 = 4 。<br>\n注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</p>\n<p>示例 3:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: prices = [7,6,4,3,1]</span><br><span class=\"line\">输出: 0</span><br></pre></td></tr></table></figure>\n<p>解释：在这种情况下，没有交易完成，所以最大利润为 0。</p>\n<p>提示：<br>\n]<br>\n1 &lt;= prices.length &lt;= 3 * 10^4<br>\n0 &lt;= prices[i] &lt;= 10^4</p>\n<h1 id=\"解题\"><a class=\"markdownIt-Anchor\" href=\"#解题\">#</a> 解题</h1>\n<h2 id=\"解法一动态规划\"><a class=\"markdownIt-Anchor\" href=\"#解法一动态规划\">#</a> 解法一：动态规划</h2>\n<h3 id=\"思路\"><a class=\"markdownIt-Anchor\" href=\"#思路\">#</a> 思路</h3>\n<p>虑到「不能同时参与多笔交易」，因此每天交易结束后只可能存在手里有一支股票或者没有股票的状态。</p>\n<p>定义状态 <code>dp[i][0]</code>  表示第 i 天交易完后手里没有股票的最大利润， <code>dp[i][1]</code>  表示第 i 天交易完后手里持有一支股票的最大利润（i 从 0 开始）。(<strong>定义状态</strong>)</p>\n<p>考虑 <code>dp[i][0]</code>  的转移方程，如果这一天交易完后手里没有股票，那么可能的转移状态为前一天已经没有股票，即  <code>dp[i−1][0]</code> ，或者前一天结束的时候手里持有一支股票，即  <code>dp[i−1][1]</code> ，这时候我们要将其卖出，并获得  <code>prices[i]</code>  的收益。因此为了收益最大化，我们列出如下的转移方程：</p>\n<p><code>dp[i][0] = max&#123; dp[i−1][0] , dp[i−1][1] + prices[i]&#125;</code></p>\n<p>再来考虑 <code>dp[i][1]</code> ，按照同样的方式考虑转移状态，那么可能的转移状态为前一天已经持有一支股票，即 <code>dp[i−1][1]</code> ，或者前一天结束时还没有股票，即  <code>dp[i−1][0]</code> ，这时候我们要将其买入，并减少 <code>prices[i]</code>  的收益。可以列出如下的转移方程：</p>\n<p><code>dp[i][1] = max&#123; dp[i−1][1], dp[i−1][0]−prices[i] &#125;</code></p>\n<p>对于初始状态，根据状态定义我们可以知道第 00 天交易结束的时候  <code>dp[0][0]=0</code> ， <code>dp[0][1]=−prices[0]</code> 。</p>\n<p>因此，我们只要从前往后依次计算状态即可。由于全部交易结束后，持有股票的收益一定低于不持有股票的收益，因此这时候  <code>dp[n−1][0]</code>  的收益必然是大于 <code>dp[n−1][1]</code>  的，最后的答案即为  <code>dp[n−1][0]</code> 。</p>\n<h3 id=\"解题-2\"><a class=\"markdownIt-Anchor\" href=\"#解题-2\">#</a> 解题</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxProfit</span><span class=\"params\">(<span class=\"type\">int</span>[] prices)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> prices.length;</span><br><span class=\"line\">        <span class=\"comment\">// 状态定义 x为天数  y为0为当天不持有 1为当天持有</span></span><br><span class=\"line\">        <span class=\"type\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n][<span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"comment\">// 定义起始状态</span></span><br><span class=\"line\">        <span class=\"comment\">// 第一天 不持有，不花钱 收益为0</span></span><br><span class=\"line\">        dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 第一天 持有，花钱 收益为当天买股票的钱</span></span><br><span class=\"line\">        dp[<span class=\"number\">0</span>][<span class=\"number\">1</span>] = - prices[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"comment\">// 从第二天开始递推哈</span></span><br><span class=\"line\">        <span class=\"comment\">//</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">d</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; d &lt; n; d++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 第二天不持有股票：</span></span><br><span class=\"line\">            <span class=\"comment\">// 第一天不持有股票的收益 + （没买）0  |  第一天持有股票 + （卖出）第二天价格 ；</span></span><br><span class=\"line\">            dp[d][<span class=\"number\">0</span>] = Math.max(dp[d-<span class=\"number\">1</span>][<span class=\"number\">0</span>], dp[d-<span class=\"number\">1</span>][<span class=\"number\">1</span>] + prices[d]);</span><br><span class=\"line\">            <span class=\"comment\">// 第二天持有股票：</span></span><br><span class=\"line\">            <span class=\"comment\">// 第一天不持有股票的收益 + 买入第二天价格  |  第一天持有股票 + 没买也没卖 ；</span></span><br><span class=\"line\">            dp[d][<span class=\"number\">1</span>] = Math.max(dp[d-<span class=\"number\">1</span>][<span class=\"number\">0</span>] - prices[d], dp[d-<span class=\"number\">1</span>][<span class=\"number\">1</span>]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 持有股票的收益必定小于不持有股票</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n-<span class=\"number\">1</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意到上面的状态转移方程中，每一天的状态只与前一天的状态有关，而与更早的状态都无关，因此我们不必存储这些无关的状态，只需要将 <code>dp[i−1][0] </code> 和 <code>dp[i−1][1]</code>  存放在两个变量中，通过它们计算出 <code>dp[i][0]</code>  和 <code>dp[i][1]</code>  并存回对应的变量，以便于第 <code>i+1</code>  天的状态转移即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxProfit</span><span class=\"params\">(<span class=\"type\">int</span>[] prices)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> prices.length;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">dp0</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, dp1 = -prices[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">newDp0</span> <span class=\"operator\">=</span> Math.max(dp0, dp1 + prices[i]);</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">newDp1</span> <span class=\"operator\">=</span> Math.max(dp1, dp0 - prices[i]);</span><br><span class=\"line\">            dp0 = newDp0;</span><br><span class=\"line\">            dp1 = newDp1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"复杂度分析\"><a class=\"markdownIt-Anchor\" href=\"#复杂度分析\">#</a> 复杂度分析</h3>\n<ul>\n<li>\n<p>时间复杂度： <code>O(n)</code> ，其中 n 为数组的长度。一共有 2n 个状态，每次状态转移的时间复杂度为  <code>O(1)</code> ，因此时间复杂度为 <code>O(2n)=O(n)</code> 。</p>\n</li>\n<li>\n<p>空间复杂度： <code>O(n)</code> 。我们需要开辟 <code>O(n)</code>  空间存储动态规划中的所有状态。如果使用空间优化，空间复杂度可以优化至  <code>O(1)</code> 。</p>\n</li>\n</ul>\n<h2 id=\"解法二贪心\"><a class=\"markdownIt-Anchor\" href=\"#解法二贪心\">#</a> 解法二：贪心</h2>\n<h3 id=\"思路-2\"><a class=\"markdownIt-Anchor\" href=\"#思路-2\">#</a> 思路</h3>\n<h3 id=\"解题-3\"><a class=\"markdownIt-Anchor\" href=\"#解题-3\">#</a> 解题</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxProfit</span><span class=\"params\">(<span class=\"type\">int</span>[] prices)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">ans</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> prices.length;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            ans += Math.max(<span class=\"number\">0</span>, prices[i] - prices[i - <span class=\"number\">1</span>]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"复杂度分析-2\"><a class=\"markdownIt-Anchor\" href=\"#复杂度分析-2\">#</a> 复杂度分析</h3>\n","raw":null,"categories":[{"name":"java","path":"api/categories/java.json"}],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"},{"name":"贪心","path":"api/tags/贪心.json"},{"name":"动态规划","path":"api/tags/动态规划.json"}]},{"title":"路径总和 II——LeetCode113","slug":"path-sum-ii","date":"2022-01-05T14:27:28.000Z","updated":"2023-02-04T06:41:58.456Z","comments":null,"realpath":null,"path":"api/articles/path-sum-ii.json","excerpt":"# 题目描述给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。叶子节点 是指没有子节点的节点。","keywords":"二叉树,dfs,bfs,leetcode","cover":"/p/7d31a8bc/u=193842663,8061252&fm=26&fmt=auto.jpeg","content":"<h1 id=\"题目描述\"><a class=\"markdownIt-Anchor\" href=\"#题目描述\">#</a> 题目描述</h1>\n<p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p>\n<p>叶子节点 是指没有子节点的节点。</p>\n<span id=\"more\"></span>\n<p>示例 1：</p>\n<p><img src=\"/p/7d31a8bc/pathsumii1.jpg\" alt></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22</span><br><span class=\"line\">输出：[[5,4,11,2],[5,8,4,5]]</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<p><img src=\"/p/7d31a8bc/pathsum2.jpg\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：root = [1,2,3], targetSum = 5</span><br><span class=\"line\">输出：[]</span><br></pre></td></tr></table></figure>\n<p>示例 3：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：root = [1,2], targetSum = 0</span><br><span class=\"line\">输出：[]</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<p>树中节点总数在范围 [0, 5000] 内<br>\n - 1000 &lt;= Node.val &lt;= 1000<br>\n-1000 &lt;= targetSum &lt;= 1000</p>\n<h1 id=\"解题\"><a class=\"markdownIt-Anchor\" href=\"#解题\">#</a> 解题</h1>\n<h2 id=\"dfs解法\"><a class=\"markdownIt-Anchor\" href=\"#dfs解法\">#</a> dfs 解法</h2>\n<ul>\n<li>\n<p>前言<br>\n注意到本题的要求是，找到所有满足从「根节点」到某个「叶子节点」经过的路径上的节点之和等于目标和的路径。核心思想是对树进行一次遍历，在遍历时记录从根节点到当前节点的路径和，以防止重复计算。</p>\n</li>\n<li>\n<p>思路及算法</p>\n<p>我们可以采用深度优先搜索的方式，枚举每一条从根节点到叶子节点的路径。当我们遍历到叶子节点，且此时路径和恰为目标和时，我们就找到了一条满足条件的路径。</p>\n</li>\n<li>\n<p>代码实现</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; ret = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class=\"line\">    Deque&lt;Integer&gt; path = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;Integer&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">pathSum</span><span class=\"params\">(TreeNode root, <span class=\"type\">int</span> targetSum)</span> &#123;</span><br><span class=\"line\">        dfs(root, targetSum);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">dfs</span><span class=\"params\">(TreeNode root, <span class=\"type\">int</span> targetSum)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        path.offerLast(root.val);</span><br><span class=\"line\">        targetSum -= root.val;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root.left == <span class=\"literal\">null</span> &amp;&amp; root.right == <span class=\"literal\">null</span> &amp;&amp; targetSum == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            ret.add(<span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;Integer&gt;(path));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dfs(root.left, targetSum);</span><br><span class=\"line\">        dfs(root.right, targetSum);</span><br><span class=\"line\">        path.pollLast();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>复杂度分析</li>\n</ul>\n<p>复杂度分析</p>\n<p>时间复杂度： <code>O(N^2)</code> ・，其中 N 是树的节点数。在最坏情况下，树的上半部分为链状，下半部分为完全二叉树，并且从根节点到每一个叶子节点的路径都符合题目要求。此时，路径的数目为  <code>O(N)</code> ，并且每一条路径的节点个数也为 O (N) O (N)，因此要将这些路径全部添加进答案中，时间复杂度为  <code>O(N^2)</code></p>\n<p>空间复杂度： <code>O(N)</code> ，其中 N 是树的节点数。空间复杂度主要取决于栈空间的开销，栈中的元素个数不会超过树的节点数。</p>\n<h2 id=\"bfs解法\"><a class=\"markdownIt-Anchor\" href=\"#bfs解法\">#</a> bfs 解法</h2>\n<ul>\n<li>思路及算法</li>\n</ul>\n<p>我们也可以采用广度优先搜索的方式，遍历这棵树。当我们遍历到叶子节点，且此时路径和恰为目标和时，我们就找到了一条满足条件的路径。</p>\n<p>为了节省空间，我们使用哈希表记录树中的每一个节点的父节点。每次找到一个满足条件的节点，我们就从该节点出发不断向父节点迭代，即可还原出从根节点到当前节点的路径。</p>\n<ul>\n<li>代码实现</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; ret = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class=\"line\">    Map&lt;TreeNode, TreeNode&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;TreeNode, TreeNode&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">pathSum</span><span class=\"params\">(TreeNode root, <span class=\"type\">int</span> targetSum)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Queue&lt;TreeNode&gt; queueNode = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class=\"line\">        Queue&lt;Integer&gt; queueSum = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;Integer&gt;();</span><br><span class=\"line\">        queueNode.offer(root);</span><br><span class=\"line\">        queueSum.offer(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!queueNode.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"type\">TreeNode</span> <span class=\"variable\">node</span> <span class=\"operator\">=</span> queueNode.poll();</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">rec</span> <span class=\"operator\">=</span> queueSum.poll() + node.val;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node.left == <span class=\"literal\">null</span> &amp;&amp; node.right == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (rec == targetSum) &#123;</span><br><span class=\"line\">                    getPath(node);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (node.left != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                    map.put(node.left, node);</span><br><span class=\"line\">                    queueNode.offer(node.left);</span><br><span class=\"line\">                    queueSum.offer(rec);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (node.right != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                    map.put(node.right, node);</span><br><span class=\"line\">                    queueNode.offer(node.right);</span><br><span class=\"line\">                    queueSum.offer(rec);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getPath</span><span class=\"params\">(TreeNode node)</span> &#123;</span><br><span class=\"line\">        List&lt;Integer&gt; temp = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;Integer&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (node != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            temp.add(node.val);</span><br><span class=\"line\">            node = map.get(node);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Collections.reverse(temp);</span><br><span class=\"line\">        ret.add(<span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;Integer&gt;(temp));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>复杂度分析</li>\n</ul>\n<p>时间复杂度： <code>O(N^2)</code> ，其中 NN 是树的节点数。分析思路与方法一相同。</p>\n<p>空间复杂度： <code>O(N)</code> ，其中 NN 是树的节点数。空间复杂度主要取决于哈希表和队列空间的开销，哈希表需要存储除根节点外的每个节点的父节点，队列中的元素个数不会超过树的节点数</p>\n","raw":null,"categories":[{"name":"java","path":"api/categories/java.json"}],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"树","path":"api/tags/树.json"},{"name":"dfs","path":"api/tags/dfs.json"},{"name":"bfs","path":"api/tags/bfs.json"}]},{"title":"复原IP地址——LeetCode93","slug":"restore-ip-addresses","date":"2022-01-04T13:58:27.000Z","updated":"2023-02-04T06:41:58.512Z","comments":null,"realpath":null,"path":"api/articles/restore-ip-addresses.json","excerpt":"# 题目描述有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。例如：“0.1.2.201” 和 “192.168.1.1” 是 有效 IP 地址，但是 “0.011.255.245”、“192.168.1.312” 和 “192.168@1.1” 是 无效 IP 地址。<br>给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 ‘.’ 来形成。你不能重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。","keywords":"算法,leetcode,ip,地址,回溯","cover":"/p/ab179abd/leetcode.jpeg","content":"<h1 id=\"题目描述\"><a class=\"markdownIt-Anchor\" href=\"#题目描述\">#</a> 题目描述</h1>\n<p>有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。</p>\n<p>例如：“0.1.2.201” 和 “192.168.1.1” 是 有效 IP 地址，但是 “0.011.255.245”、“192.168.1.312” 和 “192.168@1.1” 是 无效 IP 地址。<br>\n给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 ‘.’ 来形成。你不能重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。</p>\n<span id=\"more\"></span>\n<h2 id=\"用例\"><a class=\"markdownIt-Anchor\" href=\"#用例\">#</a> 用例</h2>\n<p>示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;25525511135&quot;</span><br><span class=\"line\">输出：[&quot;255.255.11.135&quot;,&quot;255.255.111.35&quot;]</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;0000&quot;</span><br><span class=\"line\">输出：[&quot;0.0.0.0&quot;]</span><br></pre></td></tr></table></figure>\n<p>示例 3：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;1111&quot;</span><br><span class=\"line\">输出：[&quot;1.1.1.1&quot;]</span><br></pre></td></tr></table></figure>\n<p>示例 4：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;010010&quot;</span><br><span class=\"line\">输出：[&quot;0.10.0.10&quot;,&quot;0.100.1.0&quot;]</span><br></pre></td></tr></table></figure>\n<p>示例 5：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;101023&quot;</span><br><span class=\"line\">输出：[&quot;1.0.10.23&quot;,&quot;1.0.102.3&quot;,&quot;10.1.0.23&quot;,&quot;10.10.2.3&quot;,&quot;101.0.2.3&quot;]</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<p>0 &lt;= s.length &lt;= 20<br>\ns 仅由数字组成</p>\n<h1 id=\"解题\"><a class=\"markdownIt-Anchor\" href=\"#解题\">#</a> 解题</h1>\n<h2 id=\"解题思路\"><a class=\"markdownIt-Anchor\" href=\"#解题思路\">#</a> 解题思路</h2>\n<p>由于我们需要找出所有可能复原出的 IP 地址，因此可以考虑使用<strong>回溯</strong>的方法，对<strong>所有可能的字符串分隔方式</strong>进行搜索，并筛选出满足要求的作为答案。</p>\n<p>设题目中给出的字符串为 s。我们用递归函数  <code>dfs(segId,segStart)</code>  表示我们正在从 <code>s[segStart] </code> 的位置开始，搜索 IP 地址中的第 segId 段，其中 <code>segId∈&#123;0,1,2,3&#125;</code> 。由于 IP 地址的每一段必须是  <code>[0, 255] </code> 中的整数，因此我们从 segStart 开始，从小到大依次枚举当前这一段 IP 地址的结束位置 segEnd。如果满足要求，就递归地进行下一段搜索，调用递归函数 <code>dfs(segId+1,segEnd+1)</code> 。</p>\n<p>特别地，由于 IP 地址的每一段不能有前导零，因此如果  <code>s[segStart]</code>  等于字符 0，那么 IP 地址的第 segId 段只能为 0，需要作为特殊情况进行考虑。</p>\n<p>在搜索的过程中，如果我们已经得到了全部的 4 段 IP 地址（即 segId=4），并且遍历完了整个字符串（即  <code>segStart=∣s∣</code> ，其中  <code>|s|</code>  表示字符串 s 的长度），那么就复原出了一种满足题目要求的 IP 地址，我们将其加入答案。在其它的时刻，如果提前遍历完了整个字符串，那么我们需要结束搜索，回溯到上一步。</p>\n<h2 id=\"代码实现\"><a class=\"markdownIt-Anchor\" href=\"#代码实现\">#</a> 代码实现</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">SEG_COUNT</span> <span class=\"operator\">=</span> <span class=\"number\">4</span>;</span><br><span class=\"line\">    List&lt;String&gt; ans = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;String&gt;();</span><br><span class=\"line\">    <span class=\"type\">int</span>[] segments = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[SEG_COUNT];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;String&gt; <span class=\"title function_\">restoreIpAddresses</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">        segments = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[SEG_COUNT];</span><br><span class=\"line\">        dfs(s, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">dfs</span><span class=\"params\">(String s, <span class=\"type\">int</span> segId, <span class=\"type\">int</span> segStart)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果找到了 4 段 IP 地址并且遍历完了字符串，那么就是一种答案</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (segId == SEG_COUNT) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (segStart == s.length()) &#123;</span><br><span class=\"line\">                <span class=\"type\">StringBuffer</span> <span class=\"variable\">ipAddr</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuffer</span>();</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; SEG_COUNT; ++i) &#123;</span><br><span class=\"line\">                    ipAddr.append(segments[i]);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (i != SEG_COUNT - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                        ipAddr.append(<span class=\"string\">&#x27;.&#x27;</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                ans.add(ipAddr.toString());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果还没有找到 4 段 IP 地址就已经遍历完了字符串，那么提前回溯</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (segStart == s.length()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 由于不能有前导零，如果当前数字为 0，那么这一段 IP 地址只能为 0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.charAt(segStart) == <span class=\"string\">&#x27;0&#x27;</span>) &#123;</span><br><span class=\"line\">            segments[segId] = <span class=\"number\">0</span>;</span><br><span class=\"line\">            dfs(s, segId + <span class=\"number\">1</span>, segStart + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 一般情况，枚举每一种可能性并递归</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">addr</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">segEnd</span> <span class=\"operator\">=</span> segStart; segEnd &lt; s.length(); ++segEnd) &#123;</span><br><span class=\"line\">            addr = addr * <span class=\"number\">10</span> + (s.charAt(segEnd) - <span class=\"string\">&#x27;0&#x27;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (addr &gt; <span class=\"number\">0</span> &amp;&amp; addr &lt;= <span class=\"number\">0xFF</span>) &#123;</span><br><span class=\"line\">                segments[segId] = addr;</span><br><span class=\"line\">                dfs(s, segId + <span class=\"number\">1</span>, segEnd + <span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"复杂度分析\"><a class=\"markdownIt-Anchor\" href=\"#复杂度分析\">#</a> 复杂度分析</h2>\n<p>复杂度分析</p>\n<p>我们用 SEG_COUNT=4 表示 IP 地址的段数。</p>\n<p>时间复杂度： <code>O(3^SEG_COUNT × ∣s∣)</code> 。由于 IP 地址的每一段的位数不会超过 3，因此在递归的每一层，我们最多只会深入到下一层的 33 种情况。由于 SEG_COUNT=4，对应着递归的最大层数。如果我们复原出了一种满足题目要求的 IP 地址，那么需要  <code>O(∣s∣) </code> 的时间将其加入答案数组中，因此总时间复杂度为 <code>O(3 ^SEG_COUNT ×∣s∣)</code> 。</p>\n<p>空间复杂度： <code>O(SEG_COUNT)</code> ，这里只计入除了用来存储答案数组以外的额外空间复杂度。递归使用的空间与递归的最大深度 \\text {SEG_COUNT} SEG_COUNT 成正比。并且在上面的代码中，我们只额外使用了长度为  <code>SEG_COUNT</code>  的数组  <code>segments</code>  存储已经搜索过的 IP 地址，因此空间复杂度为 <code>O(SEG_COUNT)</code> 。</p>\n","raw":null,"categories":[{"name":"java","path":"api/categories/java.json"}],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"},{"name":"回溯","path":"api/tags/回溯.json"}]},{"title":"最长回文子串——Leetcode5","slug":"longest-palindromic-substring","date":"2022-01-03T06:28:19.000Z","updated":"2023-02-04T06:41:58.448Z","comments":null,"realpath":null,"path":"api/articles/longest-palindromic-substring.json","excerpt":"# 题目描述给你一个字符串 s，找到 s 中最长的回文子串。","keywords":"回文子串,leetcode5","cover":"/p/dfd6ab93/image-20220103143944443.png","content":"<h1 id=\"题目描述\"><a class=\"markdownIt-Anchor\" href=\"#题目描述\">#</a> 题目描述</h1>\n<p>给你一个字符串 s，找到 s 中最长的回文子串。</p>\n<span id=\"more\"></span>\n<p>示例 1：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;babad&quot;</span><br><span class=\"line\">输出：&quot;bab&quot;</span><br><span class=\"line\">解释：&quot;aba&quot; 同样是符合题意的答案。</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;cbbd&quot;</span><br><span class=\"line\">输出：&quot;bb&quot;</span><br></pre></td></tr></table></figure>\n<p>示例 3：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;a&quot;</span><br><span class=\"line\">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure>\n<p>示例 4：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;ac&quot;</span><br><span class=\"line\">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<p><code>1 &lt;= s.length &lt;= 1000</code> <br>\ns 仅由数字和英文字母（大写和 / 或小写）组成</p>\n<h1 id=\"解题\"><a class=\"markdownIt-Anchor\" href=\"#解题\">#</a> 解题</h1>\n<h2 id=\"解题思路\"><a class=\"markdownIt-Anchor\" href=\"#解题思路\">#</a> 解题思路</h2>\n<p>对于一个子串而言，如果它是回文串，并且长度大于 22，那么将它首尾的两个字母去除之后，它仍然是个回文串。例如对于字符串 “ababa”，如果我们已经知道 “bab” 是回文串，那么 “ababa” 一定是回文串，这是因为它的首尾两个字母都是 “a”。</p>\n<p>根据这样的思路，我们就可以用动态规划的方法解决本题。我们用  <code>P(i,j) </code> 表示字符串 s 的第 i 到 j 个字母组成的串（下文表示成  <code>s[i:j]</code> ）是否为回文串：如果字符串 s 从 i 到 j 是回文串，那么 <code>P(i,j)= true</code> ，否则为 <code>P(i,j)= true</code> ；</p>\n<p>这里的「否」包含两种可能性：</p>\n<ul>\n<li>\n<p><code>s[i,j]</code>  本身不是一个回文串；</p>\n</li>\n<li>\n<p><code>i&gt;j</code> ，此时  <code>s[i,j]</code>  本身不合法。</p>\n</li>\n</ul>\n<p>那么我们就可以写出动态规划的状态转移方程：</p>\n<p><img src=\"/p/dfd6ab93/image-20220104210656306.png\" alt=\"状态转移方程\"></p>\n<p>也就是说，只有  <code>s[i+1:j−1] </code> 是回文串，并且  <code>s</code>  的第 <code>i</code>  和  <code>j</code>  个字母相同时， <code>s[i:j]</code>  才会是回文串。</p>\n<p>上文的所有讨论是建立在子串长度大于 2 的前提之上的，我们还需要考虑动态规划中的<strong>边界条件</strong>，即子串的长度为 1 或 2。</p>\n<ul>\n<li>\n<p>对于长度为 1 的子串，它显然是个回文串；</p>\n</li>\n<li>\n<p>对于长度为 2 的子串，只要它的两个字母相同，它就是一个回文串。</p>\n</li>\n</ul>\n<p>因此我们就可以写出动态规划的边界条件：</p>\n<p><img src=\"/p/dfd6ab93/image-20220104210730308.png\" alt=\"边界条件\"></p>\n<p>根据这个思路，我们就可以完成动态规划了，最终的答案即为所有 <code> P(i, j) = true</code>  中  <code>j−i+1</code> （即子串长度）的最大值。注意：在状态转移方程中，我们是从长度较短的字符串向长度较长的字符串进行转移的，因此一定要注意动态规划的循环顺序。</p>\n<h2 id=\"代码实现\"><a class=\"markdownIt-Anchor\" href=\"#代码实现\">#</a> 代码实现</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">longestPalindrome</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> s.length();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (len &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">maxLen</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">begin</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// dp[i][j] 表示 s[i..j] 是否是回文串</span></span><br><span class=\"line\">        <span class=\"type\">boolean</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">boolean</span>[len][len];</span><br><span class=\"line\">        <span class=\"comment\">// 初始化：所有长度为 1 的子串都是回文串</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">            dp[i][i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">char</span>[] charArray = s.toCharArray();</span><br><span class=\"line\">        <span class=\"comment\">// 递推开始</span></span><br><span class=\"line\">        <span class=\"comment\">// 先枚举子串长度</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">L</span> <span class=\"operator\">=</span> <span class=\"number\">2</span>; L &lt;= len; L++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 枚举左边界，左边界的上限设置可以宽松一些</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得</span></span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> L + i - <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"comment\">// 如果右边界越界，就可以退出当前循环</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (j &gt;= len) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (charArray[i] != charArray[j]) &#123;</span><br><span class=\"line\">                    dp[i][j] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (j - i &lt; <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">                        dp[i][j] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        dp[i][j] = dp[i + <span class=\"number\">1</span>][j - <span class=\"number\">1</span>];</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (dp[i][j] &amp;&amp; j - i + <span class=\"number\">1</span> &gt; maxLen) &#123;</span><br><span class=\"line\">                    maxLen = j - i + <span class=\"number\">1</span>;</span><br><span class=\"line\">                    begin = i;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s.substring(begin, begin + maxLen);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"复杂度分析\"><a class=\"markdownIt-Anchor\" href=\"#复杂度分析\">#</a> 复杂度分析</h2>\n<p>时间复杂度： <code>O(n^2) </code> 其中 n 是字符串的长度。动态规划的状态总数为  <code>O(n^2)</code>  对于每个状态，我们需要转移的时间为  <code>O(1)</code> 。</p>\n<p>空间复杂度： <code>O(n^2)</code> ，即存储动态规划状态需要的空间。</p>\n","raw":null,"categories":[{"name":"java","path":"api/categories/java.json"}],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"},{"name":"动态规划","path":"api/tags/动态规划.json"}]}]}