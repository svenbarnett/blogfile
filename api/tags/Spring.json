{"name":"Spring","postlist":[{"title":"从Apollo动态配置原理学Spring(一)","slug":"20230223","date":"2023-02-23T14:29:54.000Z","updated":"2023-03-29T12:38:20.934Z","comments":null,"realpath":null,"path":"api/articles/20230223.json","excerpt":"最近工作碰到需要写一个类似携程 Apollo 的动态配置功能，以此系统学习该原理，熟练掌握下 Spring 的各种机制Apollo 动态配置原理简述Apollo 配置中心动态生效机制，是基于 Http 长轮询请求和 Spring 扩展机制实现的，在 Spring 容器启动过程中，Apollo 通过自定义的 BeanPostProcessor  和 BeanFactoryPostProcessor  將参数中包含 $&#123;…&#125;  占位符和 @Value  注解的 Bean 注册到 Apollo 框架中定义的注册表中。然后通过 Http 长轮询不断的去获取服务端的配置信息，一旦配置发生变化，Apollo 会根据变化的配置的 Key 找到对应的 Bean，然后修改 Bean 的属性，从而实现了配置动态生效的特性。需要注意的是，Apollo 在配置变化后，只能修改 Bean 的属性，例如我们数据源的属性发生变化，新创建的 Connection 对象是没问题的，但是连接池中已经创建的 Connection 对象相关信息是不能动态修改的，所以依然需要重启应用。","keywords":"Apollo,Spring,动态配置","cover":"/p/e352a76e/image-20230223224050610.png","content":"<blockquote>\n<p>最近工作碰到需要写一个类似携程 Apollo 的动态配置功能，以此系统学习该原理，熟练掌握下 Spring 的各种机制</p>\n</blockquote>\n<p><strong>Apollo 动态配置原理简述</strong></p>\n<p>Apollo 配置中心动态生效机制，是基于 Http 长轮询请求和 Spring 扩展机制实现的，在 Spring 容器启动过程中，Apollo 通过自定义的 <code>BeanPostProcessor</code>  和 <code>BeanFactoryPostProcessor</code>  將参数中包含 <code>$&#123;…&#125;</code>  占位符和 <code>@Value</code>  注解的 Bean 注册到 Apollo 框架中定义的注册表中。然后通过 Http 长轮询不断的去获取服务端的配置信息，一旦配置发生变化，Apollo 会根据变化的配置的 Key 找到对应的 Bean，然后修改 Bean 的属性，从而实现了配置动态生效的特性。</p>\n<p>需要注意的是，Apollo 在配置变化后，只能修改 Bean 的属性，例如我们数据源的属性发生变化，新创建的 Connection 对象是没问题的，但是连接池中已经创建的 Connection 对象相关信息是不能动态修改的，所以依然需要重启应用。</p>\n<span id=\"more\"></span>\n<p>其中涉及到的 Spring 的扩展机制有：</p>\n<ul>\n<li>BeanFactoryPostProcessor</li>\n<li>BeanPostProcessor</li>\n<li>BeanDefinitionRegistry</li>\n<li>PropertySource</li>\n<li>ImportBeanDefinitionRegistrar</li>\n<li>PropertySourcesPlaceholderConfigurer</li>\n</ul>\n<p>…</p>\n<p>其中每一个都是非常关键的点，我们后续会一一进行学习。</p>\n<h2 id=\"apollo启动过程\"><a class=\"markdownIt-Anchor\" href=\"#apollo启动过程\">#</a> Apollo 启动过程</h2>\n<p>首先，我们先看一张图：</p>\n<p><img src=\"/p/e352a76e/image-20230223224050610.png\" alt=\"Apollo启动图\"></p>\n<ol>\n<li>\n<p>Spring 启动，扫描 bean，将相关变量参数注册到 Apollo 属性注册表</p>\n</li>\n<li>\n<p>通过 RemoteConfigRepository 获取配置，持久化本地，后续读取从本地读取，通过 <code>PropertySourcesProcessor</code>  执行如下步骤</p>\n</li>\n</ol>\n<p>（1）根据命名空间从配置中心获取配置信息，创建 RemoteConfigRepository 和 LocalFileConfigRepository 对象。RemoteConfigRepository 表示远程配置中心资源，LocalFileConfigRepository 表示本地缓存配置资源。</p>\n<p>（2）LocalFileConfigRepository 对象缓存配置信息到 C:\\opt\\data 或者 /opt/data 目录</p>\n<p>（3）RemoteConfigRepository 开启 HTTP 长轮询请求定时任务，默认 2s 请求一次。</p>\n<p>（4）將本地缓存配置信息转换为 PropertySource 对象（Apollo 自定义了 Spring 的 PropertySource），加载到 Spring 的 Environment 对象中。至此静态配置就已经加入到环境变量中</p>\n<p>（5）將自定义的 ConfigPropertySource 注册为观察者。一旦 RemoteConfigRepository 发现远程配置中心信息发生变化，ConfigPropertySource 对象会得到通知。</p>\n<ol start=\"3\">\n<li>\n<p>通过一个自定义监听器，监听对应事件</p>\n</li>\n<li>\n<p>后续通过长轮询请求监听到配置变化，根据配置读取注册表里面的 key 和对应的 bean，通过反射修改 bean 对应属性值</p>\n</li>\n</ol>\n<h2 id=\"apollo扩展点\"><a class=\"markdownIt-Anchor\" href=\"#apollo扩展点\">#</a> Apollo 扩展点</h2>\n<ol>\n<li><code>PropertySourcesProcessor</code>  初始化 Apollo 配置、接入 Spring environment，初始化 Apollo 监听器</li>\n<li><code>ApolloAnnotationProcessor</code>  提供 Apollo 一些注解支持 <code>@ApolloConfig</code> ， <code>@ApolloConfigChangeListener</code></li>\n<li><code>SpringValueProcessor</code>  提供对 <code>@Value</code>  动态生效能力 针对实例 bean</li>\n<li><code>SpringValueDefinitionProcessor</code>  提供对 <code>@Value</code>  动态生效能力 针对 bean 定义</li>\n<li><code>ApolloJsonValueProcessor</code>  提供对 <code>@ApolloJsonValue</code>  支持</li>\n</ol>\n<p>上述分别对应使用 Spring 的扩展能力 <code>BeanFactoryPostProcessor</code> 、 <code>BeanPostProcessor</code> 、 <code>BeanPostProcessor</code>  和 <code>BeanFactoryPostProcessor</code> 、 <code>BeanDefinitionRegistryPostProcessor</code> 、 <code>BeanPostProcessor</code></p>\n<p>我们这个系列也会对 apollo 基于 spring 提供的扩展点来嵌入自己的能力。主要为 BeanFactoryPostProcessor、BeanPostProcessor 这两个扩展点；先简单说一下：<em><strong>只需要知道，BeanFactoryPostProcessor、BeanDefinitionRegistryPostProcessor 在生成所有 beandefinition 之后调用，而 BeanPostProcessor 在通过 beandefinition 实例化 bean 的过程中调用即可。</strong></em></p>\n<p>那这些实现我们就下篇见了！！！</p>\n","raw":null,"categories":[{"name":"Java","path":"api/categories/Java.json"}],"tags":[{"name":"Apollo","path":"api/tags/Apollo.json"},{"name":"Spring","path":"api/tags/Spring.json"},{"name":"动态配置","path":"api/tags/动态配置.json"}]},{"title":"从Apollo动态配置原理学Spring(二)","slug":"20230226","date":"2023-02-26T12:39:24.000Z","updated":"2023-03-29T12:38:20.942Z","comments":null,"realpath":null,"path":"api/articles/20230226.json","excerpt":"Apollo 动态配置其实本质就是利用 Spring Bean 的生命周期的扩展点，这个扩展点超级多，不可能全部列出来，只说核心的扩展点。这也就是为什么 Spring 的扩展性很好的原因，开了很多的口子，尽可能让某个功能高内聚松耦合，用户需要哪个功能就用哪个，而不是直接来一个大而全的东西。我们先通过学习核心的，然后后续对照 Apollo 用到了哪些再对照，就会发现很多地方就能理解的很好了","keywords":"Spring生命周期","cover":"/p/4c633c0c/20210707002134280.png","content":"<blockquote>\n<p>Apollo 动态配置其实本质就是利用 Spring Bean 的生命周期的扩展点，这个扩展点超级多，不可能全部列出来，只说核心的扩展点。这也就是为什么 Spring 的扩展性很好的原因，开了很多的口子，尽可能让某个功能高内聚松耦合，用户需要哪个功能就用哪个，而不是直接来一个大而全的东西。</p>\n</blockquote>\n<p>我们先通过学习核心的，然后后续对照 Apollo 用到了哪些再对照，就会发现很多地方就能理解的很好了</p>\n<span id=\"more\"></span>\n<p><strong>什么是 Spring Bean 的生命周期</strong></p>\n<p>对于普通的 Java 对象，当 new 的时候创建对象，然后该对象就能够使用了。一旦该对象不再被使用，则由 Java 自动进行垃圾回收。</p>\n<p>而 Spring 中的对象是 bean，bean 和普通的 Java 对象没啥大的区别，只不过 Spring 不再自己去 new 对象了，而是由 IoC 容器去帮助我们实例化对象并且管理它，我们需要哪个对象，去问 IoC 容器要即可。IoC 其实就是解决对象之间的耦合问题，Spring Bean 的生命周期完全由容器控制。</p>\n<h2 id=\"spring-bean-的生命周期\"><a class=\"markdownIt-Anchor\" href=\"#spring-bean-的生命周期\">#</a> Spring Bean 的生命周期</h2>\n<p>这里要提一下，这里我们说的 Spring Bean 的生命周期主要指的是 singleton bean，对于 prototype 的 bean ，Spring 在创建好交给使用者之后则不会再管理后续的生命周期。</p>\n<p>我们也来复习下 Spring 中的 bean 的作用域有哪些？</p>\n<ul>\n<li><code>singleton</code>  : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。</li>\n<li><code>prototype</code>  : 每次请求都会创建一个新的 bean 实例。</li>\n<li><code>request</code>  : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。</li>\n<li><code>session</code>  : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。</li>\n<li><code>global-session</code> ： 全局 session 作用域，仅仅在基于 Portlet 的 web 应用中才有意义，Spring5 已经没有了。Portlet 是能够生成语义代码（例如：HTML）片段的小型 Java Web 插件。它们基于 portlet 容器，可以像 servlet 一样处理 HTTP 请求。但是，与 servlet 不同，每个 portlet 都有不同的会话。</li>\n</ul>\n<p>我们知道对于普通的 Java 对象来说，它们的生命周期就是：</p>\n<ul>\n<li>实例化</li>\n<li>该对象不再被使用时通过垃圾回收机制进行回收</li>\n</ul>\n<p>而对于 Spring Bean 的生命周期来说：</p>\n<ul>\n<li>实例化 Instantiation</li>\n<li>属性赋值 Populate</li>\n<li>初始化 Initialization</li>\n<li>销毁 Destruction</li>\n</ul>\n<p>实例化 -&gt; 属性赋值 -&gt; 初始化 -&gt; 销毁</p>\n<p>只有四个步骤，这样拆解的话是不是感觉也不难？不像其他人写的那样直接一上来就各种 BeanPostProcessor、BeanFactoryPostProcessor 全部怼进流程里去，别说读者看着头大，自己写的可能短时间内还记得流程，隔个一段时间，你可能都不知道自己写了个啥。</p>\n<p>通过 Bean 创建流程入口 <code>AbstractApplicationContext#refresh()</code>  方法的  <code>finishBeanFactoryInitialization(beanFactory)</code>  处带大家跟一下源码，想了想还是不带入过多的代码进来，直接给到最终的主要逻辑。</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\"data-rel=\"JAVA\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protected</span> Object <span class=\"title function_\">doCreateBean</span><span class=\"params\">(String beanName, RootBeanDefinition mbd, <span class=\"meta\">@Nullable</span> Object[] args)</span> <span class=\"keyword\">throws</span> BeanCreationException &#123;</span><br><span class=\"line\">    <span class=\"type\">BeanWrapper</span> <span class=\"variable\">instanceWrapper</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mbd.isSingleton()) &#123;</span><br><span class=\"line\">        instanceWrapper = (BeanWrapper)<span class=\"built_in\">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (instanceWrapper == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 实例化阶段</span></span><br><span class=\"line\">        instanceWrapper = <span class=\"built_in\">this</span>.createBeanInstance(beanName, mbd, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"type\">Object</span> <span class=\"variable\">exposedObject</span> <span class=\"operator\">=</span> bean;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    \t<span class=\"comment\">// 属性赋值阶段</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.populateBean(beanName, mbd, instanceWrapper);</span><br><span class=\"line\">        <span class=\"comment\">// 初始化阶段</span></span><br><span class=\"line\">        exposedObject = <span class=\"built_in\">this</span>.initializeBean(beanName, exposedObject, mbd);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable var18) &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<p>至于销毁，是在容器关闭时调用的，详见  <code>ConfigurableApplicationContext#close()</code></p>\n<p>是不是很清爽了？至于 BeanPostProcessor、BeanFactoryPostProcessor 以及其他的类，只不过是对主流程四个步骤的一系列扩展点而已。</p>\n<h2 id=\"spring-bean-的生命周期的扩展点\"><a class=\"markdownIt-Anchor\" href=\"#spring-bean-的生命周期的扩展点\">#</a> Spring Bean 的生命周期的扩展点</h2>\n<p>Spring Bean 的生命周期的扩展点超级多，老周这里不可能全部列出来，只说核心的扩展点。这也就是为什么 Spring 的扩展性很好的原因，开了很多的口子，尽可能让某个功能高内聚松耦合，用户需要哪个功能就用哪个，而不是直接来一个大而全的东西。</p>\n<p><strong>Bean 自身的方法</strong></p>\n<p>比如构造函数、getter/setter 以及 init-method 和 destory-method 所指定的方法等，也就对应着上文说的实例化 -&gt; 属性赋值 -&gt; 初始化 -&gt; 销毁四个阶段。</p>\n<p><img src=\"/p/4c633c0c/20210707002134280.png\" alt=\"阶段示意图\"></p>\n<p><strong>容器级的方法（BeanPostProcessor 一系列接口）</strong></p>\n<p>主要是后处理器方法，比如下图的  <code>InstantiationAwareBeanPostProcessor</code> 、 <code>BeanPostProcessor</code>  接口方法。这些接口的实现类是独立于 Bean 的，并且会注册到 Spring 容器中。在 Spring 容器创建任何 Bean 的时候，这些后处理器都会发生作用。</p>\n<p><img src=\"/p/4c633c0c/20210707225212729.png\" alt=\"扩展点\"></p>\n<p><strong>InstantiationAwareBeanPostProcessor 源码分析</strong></p>\n<p>我们翻一下源码发现 InstantiationAwareBeanPostProcessor 是继承了 BeanPostProcessor</p>\n<p><img src=\"/p/4c633c0c/20210707230505579.png\" alt=\"InstantiationAwareBeanPostProcessor \"></p>\n<p><img src=\"/p/4c633c0c/20210707230919307.png\" alt=\"BeanPostProcessor\"></p>\n<ul>\n<li><code>InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation</code>  调用点</li>\n</ul>\n<blockquote>\n<p>Object postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName)<br>\n 返回值：如果返回的不为 null，那么后续的 Bean 的创建流程【实例化、初始化 afterProperties】都不会执行，而是直接使用返回的快捷 Bean，此时的正常执行顺序如下：<br>\nInstantiationAwareBeanPostProcessor 接口中的 postProcessBeforeInstantiation，在实例化之前调用。<br>\nBeanPostProcessor 接口中的 postProcessAfterInitialization，在实例化之后调用。</p>\n</blockquote>\n<p><img src=\"https://img-blog.csdnimg.cn/20210707233026943.png\" alt=\"createbean\"></p>\n<p><img src=\"/p/4c633c0c/20210707235533784.png\" alt=\"resolveBeforeInstantiation\"></p>\n<p><img src=\"/p/4c633c0c/20210708000228655.png\" alt=\"applyBean\"></p>\n<p>总之，postProcessBeforeInstantiation 在 doCreateBean 之前调用，也就是在 bean 实例化之前调用的，英文源码注释解释道该方法的返回值会替换原本的 Bean 作为代理，这也是 <a href=\"https://so.csdn.net/so/search?q=AOP&amp;spm=1001.2101.3001.7020\">AOP</a> 等功能实现的关键点。</p>\n<ul>\n<li><code>InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation</code>  调用点</li>\n</ul>\n<blockquote>\n<p>boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException<br>\n 正常情况下在实例化之后在执行 populateBean 之前调用<br>\n返回值：如果有指定的 bean 的时候返回 false，那么后续的属性填充和属性依赖注入【populateBean】将不会执行，同时后续的 postProcessPropertyValues 将不会执行，但是初始化和 BeanPostProcessor 的仍然会执行。</p>\n</blockquote>\n<p><img src=\"/p/4c633c0c/20210708005050274.png\" alt=\"populateBean\"></p>\n<p>public PropertyValues postProcessPropertyValues(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)<br>\n 实例化之后调用，在方法 applyPropertyValues【属性填充】之前<br>\n返回值：如果返回 null，那么将不会进行后续的属性填充，比如依赖注入等，如果返回的 pvs 额外的添加了属性，那么后续会填充到该类对应的属性中。<br>\npvs：PropertyValues 对象，用于封装指定类的对象，简单来说就是 PropertyValue 的集合，里面相当于以 key-value 形式存放类的属性和值。<br>\npds：PropertyDescriptor 对象数组，PropertyDescriptor 相当于存储类的属性，不过可以调用 set，get 方法设置和获取对应属性的值。</p>\n<p><img src=\"/p/4c633c0c/20210708010057366.png\" alt=\"postProcessPropertyValues\"></p>\n<p><strong>BeanPostProcessor 源码分析</strong></p>\n<blockquote>\n<p>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#doCreateBean</p>\n</blockquote>\n<p><img src=\"/p/4c633c0c/20210708232740951.png\" alt=\"在这里插入图片描述\"><br>\n进入初始化接口：</p>\n<p><img src=\"/p/4c633c0c/20210708233139731.png\" alt=\"在这里插入图片描述\"><br>\n我们先来看</p>\n<blockquote>\n<p>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#applyBeanPostProcessorsBeforeInitialization</p>\n</blockquote>\n<p><img src=\"/p/4c633c0c/20210708233742525.png\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li>首先获取到所有的后置处理器 getBeanPostProcessors ()</li>\n<li>在 for 循环中依次调用后置处理器的方法  <code>processor.postProcessBeforeInitialization(result, beanName);</code></li>\n<li>进入 postProcessBeforeInitialization 方法</li>\n</ul>\n<blockquote>\n<p>org.springframework.context.support.ApplicationContextAwareProcessor#postProcessBeforeInitialization</p>\n</blockquote>\n<p><img src=\"/p/4c633c0c/20210708234443215.png\" alt=\"在这里插入图片描述\"></p>\n<p>进入  <code>invokeAwareInterfaces(bean);</code>  方法，当前 bean 实现了 ApplicationContextAware 接口。</p>\n<p><img src=\"/p/4c633c0c/20210708234639952.png\" alt=\"在这里插入图片描述\"></p>\n<ul>\n<li><code>ApplicationContextAwareProcessor#postProcessBeforeInitialization</code>  首先判断此 bean 是不是各种的 Aware，如果是它列举的那几个 Aware 就获取 Bean 工厂的权限，可以向容器中导入相关的上下文环境，目的是为了 Bean 实例能够获取到相关的上下文，如果不是它列举的几个 Aware，那就调用  <code>invokeAwareInterfaces(bean)</code> ，向容器中添加相关接口的上下文环境。</li>\n</ul>\n<p><strong>3.3 工厂后处理器方法（BeanFactoryProcessor 一系列接口）</strong></p>\n<p>包括  <code>AspectJWeavingEnabler</code> 、 <code>CustomAutowireConfigurer</code> 、 <code>ConfigurationClassPostProcessor</code>  等。这些都是 Spring 框架中已经实现好的 BeanFactoryPostProcessor，用来实现某些特定的功能。</p>\n<p>我们知道 Spring IoC 容器初始化的关键环节就在  <code>org.springframework.context.support.AbstractApplicationContext#refresh</code>  方法中 ，容器创建的主体流程都在这个方法里面，这个方法是真的重要！！！</p>\n<p>对于工厂后处理器方法老周这里直接带你看  <code>invokeBeanFactoryPostProcessors(beanFactory);</code>  方法，这个方法处理的是  <code>BeanFactoryPostProcessor</code>  接口的 Bean。调用方法如下：</p>\n<p><img src=\"/p/4c633c0c/20210709231013239.png\" alt=\"在这里插入图片描述\"><br>\n跟到最重要的方法里去，代码虽长，但逻辑中规中矩。</p>\n<p><code>BeanFactoryPostProcessor</code> ：一切处理 BeanFactory 的父接口<br>\n <code>BeanDefinitionRegistryPostProcessor</code> ：实现了 BeanFactoryPostProcessor 接口的接口</p>\n<p><img src=\"/p/4c633c0c/20210709233225102.png\" alt=\"在这里插入图片描述\"><br>\n流程说明：</p>\n<ul>\n<li>调用 BeanDefinitionRegistryPostProcessor#postProcessBeanDefinitionRegistry (registry) 方法。参数 beanFactoryPostProcessors 传入的优先处理掉。然后获取容器注册的，对于这些 Bean 按照 PriorityOrdered 接口、Ordered、没有排序接口的实例分别进行处理。</li>\n<li>调用 BeanFactoryPostProcessor#postProcessBeanFactory (beanFactory) 方法。备注：BeanDefinitionRegistryPostProcessor 属于 BeanFactoryPostProcessor 子接口。先处理属于 BeanDefinitionRegistryPostProcessor 接口实例的 postProcessBeanFactory (beanFactory) 方法，然后获取容器注册的。对于这些 Bean 按照 PriorityOrdered 接口、Ordered、没有排序接口的实例分别进行处理。</li>\n</ul>\n","raw":null,"categories":[{"name":"Java","path":"api/categories/Java.json"}],"tags":[{"name":"Apollo","path":"api/tags/Apollo.json"},{"name":"Spring","path":"api/tags/Spring.json"}]}]}