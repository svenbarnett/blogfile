{"name":"dfs","postlist":[{"title":"路径总和 II——LeetCode113","slug":"path-sum-ii","date":"2022-01-05T14:27:28.000Z","updated":"2023-02-04T06:19:42.868Z","comments":null,"realpath":null,"path":"api/articles/path-sum-ii.json","excerpt":"# 题目描述给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。叶子节点 是指没有子节点的节点。","keywords":"二叉树,dfs,bfs,leetcode","cover":"/p/7d31a8bc/u=193842663,8061252&fm=26&fmt=auto.jpeg","content":"<h1 id=\"题目描述\"><a class=\"markdownIt-Anchor\" href=\"#题目描述\">#</a> 题目描述</h1>\n<p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。</p>\n<p>叶子节点 是指没有子节点的节点。</p>\n<span id=\"more\"></span>\n<p>示例 1：</p>\n<p><img src=\"/p/7d31a8bc/pathsumii1.jpg\" alt></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22</span><br><span class=\"line\">输出：[[5,4,11,2],[5,8,4,5]]</span><br></pre></td></tr></table></figure>\n<p>示例 2：</p>\n<p><img src=\"/p/7d31a8bc/pathsum2.jpg\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：root = [1,2,3], targetSum = 5</span><br><span class=\"line\">输出：[]</span><br></pre></td></tr></table></figure>\n<p>示例 3：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：root = [1,2], targetSum = 0</span><br><span class=\"line\">输出：[]</span><br></pre></td></tr></table></figure>\n<p>提示：</p>\n<p>树中节点总数在范围 [0, 5000] 内<br>\n - 1000 &lt;= Node.val &lt;= 1000<br>\n-1000 &lt;= targetSum &lt;= 1000</p>\n<h1 id=\"解题\"><a class=\"markdownIt-Anchor\" href=\"#解题\">#</a> 解题</h1>\n<h2 id=\"dfs解法\"><a class=\"markdownIt-Anchor\" href=\"#dfs解法\">#</a> dfs 解法</h2>\n<ul>\n<li>\n<p>前言<br>\n注意到本题的要求是，找到所有满足从「根节点」到某个「叶子节点」经过的路径上的节点之和等于目标和的路径。核心思想是对树进行一次遍历，在遍历时记录从根节点到当前节点的路径和，以防止重复计算。</p>\n</li>\n<li>\n<p>思路及算法</p>\n<p>我们可以采用深度优先搜索的方式，枚举每一条从根节点到叶子节点的路径。当我们遍历到叶子节点，且此时路径和恰为目标和时，我们就找到了一条满足条件的路径。</p>\n</li>\n<li>\n<p>代码实现</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; ret = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class=\"line\">    Deque&lt;Integer&gt; path = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;Integer&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">pathSum</span><span class=\"params\">(TreeNode root, <span class=\"type\">int</span> targetSum)</span> &#123;</span><br><span class=\"line\">        dfs(root, targetSum);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">dfs</span><span class=\"params\">(TreeNode root, <span class=\"type\">int</span> targetSum)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        path.offerLast(root.val);</span><br><span class=\"line\">        targetSum -= root.val;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root.left == <span class=\"literal\">null</span> &amp;&amp; root.right == <span class=\"literal\">null</span> &amp;&amp; targetSum == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            ret.add(<span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;Integer&gt;(path));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dfs(root.left, targetSum);</span><br><span class=\"line\">        dfs(root.right, targetSum);</span><br><span class=\"line\">        path.pollLast();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>复杂度分析</li>\n</ul>\n<p>复杂度分析</p>\n<p>时间复杂度： <code>O(N^2)</code> ・，其中 N 是树的节点数。在最坏情况下，树的上半部分为链状，下半部分为完全二叉树，并且从根节点到每一个叶子节点的路径都符合题目要求。此时，路径的数目为  <code>O(N)</code> ，并且每一条路径的节点个数也为 O (N) O (N)，因此要将这些路径全部添加进答案中，时间复杂度为  <code>O(N^2)</code></p>\n<p>空间复杂度： <code>O(N)</code> ，其中 N 是树的节点数。空间复杂度主要取决于栈空间的开销，栈中的元素个数不会超过树的节点数。</p>\n<h2 id=\"bfs解法\"><a class=\"markdownIt-Anchor\" href=\"#bfs解法\">#</a> bfs 解法</h2>\n<ul>\n<li>思路及算法</li>\n</ul>\n<p>我们也可以采用广度优先搜索的方式，遍历这棵树。当我们遍历到叶子节点，且此时路径和恰为目标和时，我们就找到了一条满足条件的路径。</p>\n<p>为了节省空间，我们使用哈希表记录树中的每一个节点的父节点。每次找到一个满足条件的节点，我们就从该节点出发不断向父节点迭代，即可还原出从根节点到当前节点的路径。</p>\n<ul>\n<li>代码实现</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; ret = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class=\"line\">    Map&lt;TreeNode, TreeNode&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;TreeNode, TreeNode&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">pathSum</span><span class=\"params\">(TreeNode root, <span class=\"type\">int</span> targetSum)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Queue&lt;TreeNode&gt; queueNode = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class=\"line\">        Queue&lt;Integer&gt; queueSum = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;Integer&gt;();</span><br><span class=\"line\">        queueNode.offer(root);</span><br><span class=\"line\">        queueSum.offer(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!queueNode.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"type\">TreeNode</span> <span class=\"variable\">node</span> <span class=\"operator\">=</span> queueNode.poll();</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">rec</span> <span class=\"operator\">=</span> queueSum.poll() + node.val;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node.left == <span class=\"literal\">null</span> &amp;&amp; node.right == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (rec == targetSum) &#123;</span><br><span class=\"line\">                    getPath(node);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (node.left != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                    map.put(node.left, node);</span><br><span class=\"line\">                    queueNode.offer(node.left);</span><br><span class=\"line\">                    queueSum.offer(rec);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (node.right != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                    map.put(node.right, node);</span><br><span class=\"line\">                    queueNode.offer(node.right);</span><br><span class=\"line\">                    queueSum.offer(rec);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getPath</span><span class=\"params\">(TreeNode node)</span> &#123;</span><br><span class=\"line\">        List&lt;Integer&gt; temp = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;Integer&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (node != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            temp.add(node.val);</span><br><span class=\"line\">            node = map.get(node);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Collections.reverse(temp);</span><br><span class=\"line\">        ret.add(<span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;Integer&gt;(temp));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>复杂度分析</li>\n</ul>\n<p>时间复杂度： <code>O(N^2)</code> ，其中 NN 是树的节点数。分析思路与方法一相同。</p>\n<p>空间复杂度： <code>O(N)</code> ，其中 NN 是树的节点数。空间复杂度主要取决于哈希表和队列空间的开销，哈希表需要存储除根节点外的每个节点的父节点，队列中的元素个数不会超过树的节点数</p>\n","raw":null,"categories":[{"name":"java","path":"api/categories/java.json"}],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"树","path":"api/tags/树.json"},{"name":"dfs","path":"api/tags/dfs.json"},{"name":"bfs","path":"api/tags/bfs.json"}]}]}