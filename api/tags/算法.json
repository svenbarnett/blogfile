{"name":"算法","postlist":[{"title":"买卖股票的最佳时机 II——LeetCode122","slug":"best-time-to-buy-and-sell-stock-ii","date":"2022-01-06T15:28:13.000Z","updated":"2023-03-29T12:39:52.106Z","comments":null,"realpath":null,"path":"api/articles/best-time-to-buy-and-sell-stock-ii.json","excerpt":"# 题目描述给定一个数组 prices ，其中 prices [i] 是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。","keywords":"leetcode,算法,贪心算法,动态规划","cover":"/p/f883163f/2022-01-06%2023.30.34.png","content":"<h1 id=\"题目描述\"><a class=\"markdownIt-Anchor\" href=\"#题目描述\">#</a> 题目描述</h1>\n<p>给定一个数组 prices ，其中 prices [i] 是一支给定股票第 i 天的价格。</p>\n<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>\n<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>\n<span id=\"more\"></span>\n<p>示例 1:</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\"data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: prices = [7,1,5,3,6,4]</span><br><span class=\"line\">输出: 7</span><br></pre></td></tr></table></figure></div>\n<p>解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出，这笔交易所能获得利润 = 5-1 = 4 。<br>\n随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，这笔交易所能获得利润 = 6-3 = 3 。<br>\n <br>\n示例 2:</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\"data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: prices = [1,2,3,4,5]</span><br><span class=\"line\">输出: 4</span><br></pre></td></tr></table></figure></div>\n<p>解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出，这笔交易所能获得利润 = 5-1 = 4 。<br>\n注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</p>\n<p>示例 3:</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\"data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入: prices = [7,6,4,3,1]</span><br><span class=\"line\">输出: 0</span><br></pre></td></tr></table></figure></div>\n<p>解释：在这种情况下，没有交易完成，所以最大利润为 0。</p>\n<p>提示：<br>\n]<br>\n1 &lt;= prices.length &lt;= 3 * 10^4<br>\n0 &lt;= prices[i] &lt;= 10^4</p>\n<h1 id=\"解题\"><a class=\"markdownIt-Anchor\" href=\"#解题\">#</a> 解题</h1>\n<h2 id=\"解法一动态规划\"><a class=\"markdownIt-Anchor\" href=\"#解法一动态规划\">#</a> 解法一：动态规划</h2>\n<h3 id=\"思路\"><a class=\"markdownIt-Anchor\" href=\"#思路\">#</a> 思路</h3>\n<p>虑到「不能同时参与多笔交易」，因此每天交易结束后只可能存在手里有一支股票或者没有股票的状态。</p>\n<p>定义状态 <code>dp[i][0]</code>  表示第 i 天交易完后手里没有股票的最大利润， <code>dp[i][1]</code>  表示第 i 天交易完后手里持有一支股票的最大利润（i 从 0 开始）。(<strong>定义状态</strong>)</p>\n<p>考虑 <code>dp[i][0]</code>  的转移方程，如果这一天交易完后手里没有股票，那么可能的转移状态为前一天已经没有股票，即  <code>dp[i−1][0]</code> ，或者前一天结束的时候手里持有一支股票，即  <code>dp[i−1][1]</code> ，这时候我们要将其卖出，并获得  <code>prices[i]</code>  的收益。因此为了收益最大化，我们列出如下的转移方程：</p>\n<p><code>dp[i][0] = max&#123; dp[i−1][0] , dp[i−1][1] + prices[i]&#125;</code></p>\n<p>再来考虑 <code>dp[i][1]</code> ，按照同样的方式考虑转移状态，那么可能的转移状态为前一天已经持有一支股票，即 <code>dp[i−1][1]</code> ，或者前一天结束时还没有股票，即  <code>dp[i−1][0]</code> ，这时候我们要将其买入，并减少 <code>prices[i]</code>  的收益。可以列出如下的转移方程：</p>\n<p><code>dp[i][1] = max&#123; dp[i−1][1], dp[i−1][0]−prices[i] &#125;</code></p>\n<p>对于初始状态，根据状态定义我们可以知道第 00 天交易结束的时候  <code>dp[0][0]=0</code> ， <code>dp[0][1]=−prices[0]</code> 。</p>\n<p>因此，我们只要从前往后依次计算状态即可。由于全部交易结束后，持有股票的收益一定低于不持有股票的收益，因此这时候  <code>dp[n−1][0]</code>  的收益必然是大于 <code>dp[n−1][1]</code>  的，最后的答案即为  <code>dp[n−1][0]</code> 。</p>\n<h3 id=\"解题-2\"><a class=\"markdownIt-Anchor\" href=\"#解题-2\">#</a> 解题</h3>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\"data-rel=\"JAVA\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxProfit</span><span class=\"params\">(<span class=\"type\">int</span>[] prices)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> prices.length;</span><br><span class=\"line\">        <span class=\"comment\">// 状态定义 x为天数  y为0为当天不持有 1为当天持有</span></span><br><span class=\"line\">        <span class=\"type\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n][<span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"comment\">// 定义起始状态</span></span><br><span class=\"line\">        <span class=\"comment\">// 第一天 不持有，不花钱 收益为0</span></span><br><span class=\"line\">        dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 第一天 持有，花钱 收益为当天买股票的钱</span></span><br><span class=\"line\">        dp[<span class=\"number\">0</span>][<span class=\"number\">1</span>] = - prices[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"comment\">// 从第二天开始递推哈</span></span><br><span class=\"line\">        <span class=\"comment\">//</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">d</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; d &lt; n; d++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 第二天不持有股票：</span></span><br><span class=\"line\">            <span class=\"comment\">// 第一天不持有股票的收益 + （没买）0  |  第一天持有股票 + （卖出）第二天价格 ；</span></span><br><span class=\"line\">            dp[d][<span class=\"number\">0</span>] = Math.max(dp[d-<span class=\"number\">1</span>][<span class=\"number\">0</span>], dp[d-<span class=\"number\">1</span>][<span class=\"number\">1</span>] + prices[d]);</span><br><span class=\"line\">            <span class=\"comment\">// 第二天持有股票：</span></span><br><span class=\"line\">            <span class=\"comment\">// 第一天不持有股票的收益 + 买入第二天价格  |  第一天持有股票 + 没买也没卖 ；</span></span><br><span class=\"line\">            dp[d][<span class=\"number\">1</span>] = Math.max(dp[d-<span class=\"number\">1</span>][<span class=\"number\">0</span>] - prices[d], dp[d-<span class=\"number\">1</span>][<span class=\"number\">1</span>]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 持有股票的收益必定小于不持有股票</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n-<span class=\"number\">1</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<p>注意到上面的状态转移方程中，每一天的状态只与前一天的状态有关，而与更早的状态都无关，因此我们不必存储这些无关的状态，只需要将 <code>dp[i−1][0] </code> 和 <code>dp[i−1][1]</code>  存放在两个变量中，通过它们计算出 <code>dp[i][0]</code>  和 <code>dp[i][1]</code>  并存回对应的变量，以便于第 <code>i+1</code>  天的状态转移即可。</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\"data-rel=\"JAVA\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxProfit</span><span class=\"params\">(<span class=\"type\">int</span>[] prices)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> prices.length;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">dp0</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, dp1 = -prices[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">newDp0</span> <span class=\"operator\">=</span> Math.max(dp0, dp1 + prices[i]);</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">newDp1</span> <span class=\"operator\">=</span> Math.max(dp1, dp0 - prices[i]);</span><br><span class=\"line\">            dp0 = newDp0;</span><br><span class=\"line\">            dp1 = newDp1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<h3 id=\"复杂度分析\"><a class=\"markdownIt-Anchor\" href=\"#复杂度分析\">#</a> 复杂度分析</h3>\n<ul>\n<li>\n<p>时间复杂度： <code>O(n)</code> ，其中 n 为数组的长度。一共有 2n 个状态，每次状态转移的时间复杂度为  <code>O(1)</code> ，因此时间复杂度为 <code>O(2n)=O(n)</code> 。</p>\n</li>\n<li>\n<p>空间复杂度： <code>O(n)</code> 。我们需要开辟 <code>O(n)</code>  空间存储动态规划中的所有状态。如果使用空间优化，空间复杂度可以优化至  <code>O(1)</code> 。</p>\n</li>\n</ul>\n<h2 id=\"解法二贪心\"><a class=\"markdownIt-Anchor\" href=\"#解法二贪心\">#</a> 解法二：贪心</h2>\n<h3 id=\"思路-2\"><a class=\"markdownIt-Anchor\" href=\"#思路-2\">#</a> 思路</h3>\n<h3 id=\"解题-3\"><a class=\"markdownIt-Anchor\" href=\"#解题-3\">#</a> 解题</h3>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\"data-rel=\"JAVA\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxProfit</span><span class=\"params\">(<span class=\"type\">int</span>[] prices)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">ans</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> prices.length;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            ans += Math.max(<span class=\"number\">0</span>, prices[i] - prices[i - <span class=\"number\">1</span>]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<h3 id=\"复杂度分析-2\"><a class=\"markdownIt-Anchor\" href=\"#复杂度分析-2\">#</a> 复杂度分析</h3>\n","raw":null,"categories":[{"name":"java","path":"api/categories/java.json"}],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"},{"name":"贪心","path":"api/tags/贪心.json"},{"name":"动态规划","path":"api/tags/动态规划.json"}]},{"title":"寻找重复数——LeetCode287","slug":"find-the-duplicate-number","date":"2021-11-11T13:02:11.000Z","updated":"2023-03-29T12:39:52.110Z","comments":null,"realpath":null,"path":"api/articles/find-the-duplicate-number.json","excerpt":"给定一个包含 n + 1 个整数的数组 nums ，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。<br>假设 nums 只有 一个重复的整数 ，找出 这个重复的数 。<br>你设计的解决方案必须不修改数组 nums 且只用常量级 O (1) 的额外空间。<br>Leetcode-287 链接：https://leetcode-cn.com/problems/find-the-duplicate-number","keywords":"寻找重复数,二分法,算法,leetcode","cover":"","content":"<p>给定一个包含 n + 1 个整数的数组 nums ，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。<br>\n假设 nums 只有 一个重复的整数 ，找出 这个重复的数 。<br>\n你设计的解决方案必须不修改数组 nums 且只用常量级 O (1) 的额外空间。<br>\nLeetcode-287 链接：<a href=\"https://leetcode-cn.com/problems/find-the-duplicate-number\">https://leetcode-cn.com/problems/find-the-duplicate-number</a></p>\n<span id=\"more\"></span>\n<p>示例 1：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\"data-rel=\"SH\"><figure class=\"iseeu highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,3,4,2,2]</span><br><span class=\"line\">输出：2</span><br></pre></td></tr></table></figure></div>\n<p>示例 2：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\"data-rel=\"SH\"><figure class=\"iseeu highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [3,1,3,4,2]</span><br><span class=\"line\">输出：3</span><br></pre></td></tr></table></figure></div>\n<p>示例 3：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\"data-rel=\"SH\"><figure class=\"iseeu highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,1]</span><br><span class=\"line\">输出：1</span><br></pre></td></tr></table></figure></div>\n<p>示例 4：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\"data-rel=\"FIX\"><figure class=\"iseeu highlight fix\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">输入：nums </span>=<span class=\"string\"> [1,1,2]</span></span><br><span class=\"line\"><span class=\"string\">输出：1</span></span><br></pre></td></tr></table></figure></div>\n<p>提示：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\"data-rel=\"SH\"><figure class=\"iseeu highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 &lt;= n &lt;= 105</span><br><span class=\"line\">nums.length == n + 1</span><br><span class=\"line\">1 &lt;= nums[i] &lt;= n</span><br></pre></td></tr></table></figure></div>\n<p>nums 中 只有一个整数 出现 两次或多次 ，其余整数均只出现 一次</p>\n<h3 id=\"解题\"><a class=\"markdownIt-Anchor\" href=\"#解题\">#</a> 解题</h3>\n<ol>\n<li>二分法</li>\n</ol>\n<p>针对用例 <code>[1,3,4,2,2]</code></p>\n<p>定义一个 <code>cnt</code>  数组用来存储小于等于 索引  <code>i</code>  的总数</p>\n<p>如果知道 cnt 数组随数字 index 逐渐增大具有单调性，那么当 num [index] 那么我们就可以直接利用二分查找来找到重复的数</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">nums</th>\n<th style=\"text-align:center\">1</th>\n<th style=\"text-align:center\">2</th>\n<th style=\"text-align:center\">3</th>\n<th style=\"text-align:center\">4</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">cnt</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">5</td>\n</tr>\n</tbody>\n</table>\n<p>小于等于 1 的一个</p>\n<p>小于等于 2 的三个</p>\n<p>小于等于 3 的四个</p>\n<p>小于等于 4 的五个</p>\n<p>由此可见：我们的目标是 2，target 满足: target 前面的  <code>cnt[i] &lt;=  i</code> , 目标值 target 之后的  <code>cnt[i] &gt; i</code></p>\n<p>实际上可以归纳为：</p>\n<ul>\n<li>\n<p>如果测试用例的数组中  <code>target</code>  出现了两次，其余的数各出现了一次，这个时候肯定满足上文提及的性质，因为小于  <code>target</code>  的数 i 满足  <code>cnt[i]=i</code> ，大于等于  <code>target</code>  的数  <code>j</code>  满足  <code>cnt[j]=j+1</code> 。</p>\n</li>\n<li>\n<p>如果测试用例的数组中 <code>target </code> 出现了三次及以上，那么必然有一些数不在  <code>nums</code>  数组中了，这个时候相当于我们用 <code>target</code>  去替换了这些数，我们考虑替换的时候对 <code>cnt[] </code> 数组的影响。如果替换的数 <code>i</code>  小于  <code>target</code>  ，那么在数 <code>i</code>  到 <code>target</code>  区间的值，均减一，其他不变，满足条件。如果替换的数  <code>j</code>  大于等于  <code>target</code> ，那么 <code>target</code>  到 数 <code>j</code>  区间内值均加一，其他不变，亦满足条件。</p>\n</li>\n</ul>\n<p>因此不管多个重复还是两个重复，数组都满足那个性质。</p>\n<p>代码实现：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\"data-rel=\"JAVA\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">findDuplicate</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> nums.length;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">l</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>, r = n - <span class=\"number\">1</span>, ans = -<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (l &lt;= r) &#123;</span><br><span class=\"line\">           # 右移动一位，相关于除以<span class=\"number\">2</span>，取中间值</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">mid</span> <span class=\"operator\">=</span> (l + r) &gt;&gt; <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">cnt</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">              # 将小于等于中间值都加起来  </span><br><span class=\"line\">              <span class=\"keyword\">if</span> (nums[i] &lt;= mid) &#123;</span><br><span class=\"line\">                    cnt++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">           # 如果此时的cnt总数小于等于mid，那说明不在mid左边</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cnt &lt;= mid) &#123;</span><br><span class=\"line\">               # 把左边拉到中间</span><br><span class=\"line\">                l = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                # 否则把右边拉到中间</span><br><span class=\"line\">                r = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">                # 记录答案</span><br><span class=\"line\">                ans = mid;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<p>复杂度分析</p>\n<p>时间复杂度： <code>O(n * logn)</code> ，其中 n 为 nums 数组的长度。二分查找最多需要二分 <code>O(logn) </code> 次，每次判断的时候需要 <code>O(n)</code>  遍历 nums 数组求解小于等于 mid 的数的个数，因此总时间复杂度为 <code>O(n * logn)</code> 。</p>\n<p>空间复杂度： <code>O(1)</code> 。我们只需要常数空间存放若干变量。</p>\n<ol start=\"2\">\n<li>快慢指针</li>\n</ol>\n<p>我们对 nums 数组建图，每个位置  <code>i</code>  连一条  <code>i→nums[i]</code>  的边。由于存在的重复的数字<br>\n <code>target</code>  因此  <code>target </code> 这个位置一定有起码两条指向它的边，因此整张图一定存在环，且我们要找到的<br>\n <code>target</code>  就是这个环的入口.</p>\n<p>我们先设置慢指针 <code>slow 和快指针</code>   <code>fast</code>  ，慢指针每次走一步，快指针每次走两步，根据「Floyd 判圈算法」两个指针在有环的情况下一定会相遇，此时我们再将  <code>slow</code>  放置起点 <code>0</code> ，两个指针每次同时移动一步，相遇的点就是答案。</p>\n<p>代码实现：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\"data-rel=\"JAVA\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">findDuplicate</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">slow</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, fast = <span class=\"number\">0</span>;</span><br><span class=\"line\">      \t# 找环的入口</span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            slow = nums[slow];</span><br><span class=\"line\">            fast = nums[nums[fast]];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> (slow != fast);</span><br><span class=\"line\">        # 重置slow为起点</span><br><span class=\"line\">        slow = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (slow != fast) &#123;</span><br><span class=\"line\">            slow = nums[slow];</span><br><span class=\"line\">            fast = nums[fast];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        # 再次相遇 就是环入口</span><br><span class=\"line\">        <span class=\"keyword\">return</span> slow;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<p>复杂度分析</p>\n<p>时间复杂度： <code>O(n)</code> 。「Floyd 判圈算法」时间复杂度为线性的时间复杂度。<br>\n空间复杂度： <code>O(1)</code> 。我们只需要常数空间存放若干变量。</p>\n","raw":null,"categories":[],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"},{"name":"二分法","path":"api/tags/二分法.json"},{"name":"快慢指针","path":"api/tags/快慢指针.json"}]},{"title":"环形链表——LeetCode141","slug":"linked-list-cycle","date":"2021-11-12T13:17:10.000Z","updated":"2023-03-29T12:39:52.114Z","comments":null,"realpath":null,"path":"api/articles/linked-list-cycle.json","excerpt":"给定一个链表，判断链表中是否有环。如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。<br>如果链表中存在环，则返回 true 。 否则，返回 false 。<br>LeetCode-141 链接：https://leetcode-cn.com/problems/linked-list-cycle","keywords":"环形链表,快慢指针","cover":"/p/1426/circularlinkedlist.png","content":"<p>给定一个链表，判断链表中是否有环。</p>\n<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。<br>\n如果链表中存在环，则返回 true 。 否则，返回 false 。<br>\nLeetCode-141 链接：<a href=\"https://leetcode-cn.com/problems/linked-list-cycle\">https://leetcode-cn.com/problems/linked-list-cycle</a></p>\n<span id=\"more\"></span> \n<p>示例 1：</p>\n<p><img src=\"/p/1426/circularlinkedlist.png\" alt=\"环形链表-示例1\"></p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\"data-rel=\"BASH\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：<span class=\"built_in\">head</span> = [3,2,0,-4], pos = 1</span><br><span class=\"line\">输出：<span class=\"literal\">true</span></span><br><span class=\"line\">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure></div>\n<p>示例 2：</p>\n<p><img src=\"/p/1426/circularlinkedlist_test2.png\" alt=\"环形链表-示例2\"></p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\"data-rel=\"BASH\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：<span class=\"built_in\">head</span> = [1,2], pos = 0</span><br><span class=\"line\">输出：<span class=\"literal\">true</span></span><br><span class=\"line\">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure></div>\n<p>示例 3：</p>\n<p><img src=\"/p/1426/circularlinkedlist_test3.png\" alt=\"环形链表-示例3\"></p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\"data-rel=\"BASH\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：<span class=\"built_in\">head</span> = [1], pos = -1</span><br><span class=\"line\">输出：<span class=\"literal\">false</span></span><br><span class=\"line\">解释：链表中没有环。</span><br></pre></td></tr></table></figure></div>\n<p>提示：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\"data-rel=\"REASONML\"><figure class=\"iseeu highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">链表中节点的数目范围是 <span class=\"literal\">[<span class=\"number\">0</span>, <span class=\"number\">104</span>]</span></span><br><span class=\"line\">-<span class=\"number\">105</span> &lt;= <span class=\"module-access\"><span class=\"module\"><span class=\"identifier\">Node</span>.</span></span><span class=\"keyword\">val</span> &lt;= <span class=\"number\">105</span></span><br><span class=\"line\">pos 为 -<span class=\"number\">1</span> 或者链表中的一个 有效索引 。</span><br></pre></td></tr></table></figure></div>\n<h3 id=\"解题\"><a class=\"markdownIt-Anchor\" href=\"#解题\">#</a> 解题</h3>\n<ol>\n<li>Hash 表</li>\n</ol>\n<p>最容易想到的方法是遍历所有节点，每次遍历到一个节点时，判断该节点此前是否被访问过。</p>\n<p>具体地，我们可以使用哈希表来存储所有已经访问过的节点。每次我们到达一个节点，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。重复这一过程，直到我们遍历完整个链表即可。</p>\n<p>代码实现：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\"data-rel=\"JAVA\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">hasCycle</span><span class=\"params\">(ListNode head)</span> &#123;</span><br><span class=\"line\">        Set&lt;ListNode&gt; seen = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;ListNode&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (head != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!seen.add(head)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            head = head.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<p>复杂度分析</p>\n<p>时间复杂度： <code>O(N)</code> ，其中  <code>N </code> 是链表中的节点数。最坏情况下我们需要遍历每个节点一次。<br>\n空间复杂度： <code>O(N)</code> ，其中 <code>N </code> 是链表中的节点数。主要为哈希表的开销，最坏情况下我们需要将每个节点插入到哈希表中一次。</p>\n<ol start=\"2\">\n<li>快慢指针</li>\n</ol>\n<p>方法需要读者对「Floyd 判圈算法」（又称龟兔赛跑算法）有所了解。</p>\n<p>假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。</p>\n<p>我们可以根据上述思路来解决本题。具体地，我们定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。</p>\n<p><img src=\"/p/1426/2.png\" alt=\"龟兔赛跑\"></p>\n<blockquote>\n<p>为什么我们要规定初始时慢指针在位置 head，快指针在位置 head.next，而不是两个指针都在位置 head（即与「乌龟」和「兔子」中的叙述相同）？</p>\n</blockquote>\n<ul>\n<li>观察下面的代码，我们使用的是 while 循环，循环条件先于循环体。由于循环条件一定是判断快慢指针是否重合，如果我们将两个指针初始都置于 head，那么 while 循环就不会执行。因此，我们可以假想一个在 head 之前的虚拟节点，慢指针从虚拟节点移动一步到达 head，快指针从虚拟节点移动两步到达 head.next，这样我们就可以使用 while 循环了。</li>\n<li>当然，我们也可以使用 do-while 循环。此时，我们就可以把快慢指针的初始值都置为 head。</li>\n</ul>\n<p>代码实现：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\"data-rel=\"JAVA\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">hasCycle</span><span class=\"params\">(ListNode head)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head == <span class=\"literal\">null</span> || head.next == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">slow</span> <span class=\"operator\">=</span> head;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">fast</span> <span class=\"operator\">=</span> head.next;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (slow != fast) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (fast == <span class=\"literal\">null</span> || fast.next == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            slow = slow.next;</span><br><span class=\"line\">            fast = fast.next.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<p>复杂度分析</p>\n<p>时间复杂度： <code>O(N)</code> ，其中  <code>N</code>  是链表中的节点数。<br>\n当链表中不存在环时，快指针将先于慢指针到达链表尾部，链表中每个节点至多被访问两次。<br>\n当链表中存在环时，每一轮移动后，快慢指针的距离将减小一。而初始距离为环的长度，因此至多移动<br>\n <code>N</code>  轮。<br>\n空间复杂度： <code>O(1)</code> 。我们只使用了两个指针的额外空间。</p>\n","raw":null,"categories":[],"tags":[{"name":"算法","path":"api/tags/算法.json"},{"name":"快慢指针","path":"api/tags/快慢指针.json"},{"name":"环形链表","path":"api/tags/环形链表.json"}]},{"title":"最长回文子串——Leetcode5","slug":"longest-palindromic-substring","date":"2022-01-03T06:28:19.000Z","updated":"2023-03-29T12:39:52.114Z","comments":null,"realpath":null,"path":"api/articles/longest-palindromic-substring.json","excerpt":"# 题目描述给你一个字符串 s，找到 s 中最长的回文子串。","keywords":"回文子串,leetcode5","cover":"/p/dfd6ab93/image-20220103143944443.png","content":"<h1 id=\"题目描述\"><a class=\"markdownIt-Anchor\" href=\"#题目描述\">#</a> 题目描述</h1>\n<p>给你一个字符串 s，找到 s 中最长的回文子串。</p>\n<span id=\"more\"></span>\n<p>示例 1：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\"data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;babad&quot;</span><br><span class=\"line\">输出：&quot;bab&quot;</span><br><span class=\"line\">解释：&quot;aba&quot; 同样是符合题意的答案。</span><br></pre></td></tr></table></figure></div>\n<p>示例 2：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\"data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;cbbd&quot;</span><br><span class=\"line\">输出：&quot;bb&quot;</span><br></pre></td></tr></table></figure></div>\n<p>示例 3：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\"data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;a&quot;</span><br><span class=\"line\">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure></div>\n<p>示例 4：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\"data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;ac&quot;</span><br><span class=\"line\">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure></div>\n<p>提示：</p>\n<p><code>1 &lt;= s.length &lt;= 1000</code> <br>\ns 仅由数字和英文字母（大写和 / 或小写）组成</p>\n<h1 id=\"解题\"><a class=\"markdownIt-Anchor\" href=\"#解题\">#</a> 解题</h1>\n<h2 id=\"解题思路\"><a class=\"markdownIt-Anchor\" href=\"#解题思路\">#</a> 解题思路</h2>\n<p>对于一个子串而言，如果它是回文串，并且长度大于 22，那么将它首尾的两个字母去除之后，它仍然是个回文串。例如对于字符串 “ababa”，如果我们已经知道 “bab” 是回文串，那么 “ababa” 一定是回文串，这是因为它的首尾两个字母都是 “a”。</p>\n<p>根据这样的思路，我们就可以用动态规划的方法解决本题。我们用  <code>P(i,j) </code> 表示字符串 s 的第 i 到 j 个字母组成的串（下文表示成  <code>s[i:j]</code> ）是否为回文串：如果字符串 s 从 i 到 j 是回文串，那么 <code>P(i,j)= true</code> ，否则为 <code>P(i,j)= true</code> ；</p>\n<p>这里的「否」包含两种可能性：</p>\n<ul>\n<li>\n<p><code>s[i,j]</code>  本身不是一个回文串；</p>\n</li>\n<li>\n<p><code>i&gt;j</code> ，此时  <code>s[i,j]</code>  本身不合法。</p>\n</li>\n</ul>\n<p>那么我们就可以写出动态规划的状态转移方程：</p>\n<p><img src=\"/p/dfd6ab93/image-20220104210656306.png\" alt=\"状态转移方程\"></p>\n<p>也就是说，只有  <code>s[i+1:j−1] </code> 是回文串，并且  <code>s</code>  的第 <code>i</code>  和  <code>j</code>  个字母相同时， <code>s[i:j]</code>  才会是回文串。</p>\n<p>上文的所有讨论是建立在子串长度大于 2 的前提之上的，我们还需要考虑动态规划中的<strong>边界条件</strong>，即子串的长度为 1 或 2。</p>\n<ul>\n<li>\n<p>对于长度为 1 的子串，它显然是个回文串；</p>\n</li>\n<li>\n<p>对于长度为 2 的子串，只要它的两个字母相同，它就是一个回文串。</p>\n</li>\n</ul>\n<p>因此我们就可以写出动态规划的边界条件：</p>\n<p><img src=\"/p/dfd6ab93/image-20220104210730308.png\" alt=\"边界条件\"></p>\n<p>根据这个思路，我们就可以完成动态规划了，最终的答案即为所有 <code> P(i, j) = true</code>  中  <code>j−i+1</code> （即子串长度）的最大值。注意：在状态转移方程中，我们是从长度较短的字符串向长度较长的字符串进行转移的，因此一定要注意动态规划的循环顺序。</p>\n<h2 id=\"代码实现\"><a class=\"markdownIt-Anchor\" href=\"#代码实现\">#</a> 代码实现</h2>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\"data-rel=\"JAVA\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">longestPalindrome</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> s.length();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (len &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">maxLen</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">begin</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">// dp[i][j] 表示 s[i..j] 是否是回文串</span></span><br><span class=\"line\">        <span class=\"type\">boolean</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">boolean</span>[len][len];</span><br><span class=\"line\">        <span class=\"comment\">// 初始化：所有长度为 1 的子串都是回文串</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">            dp[i][i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">char</span>[] charArray = s.toCharArray();</span><br><span class=\"line\">        <span class=\"comment\">// 递推开始</span></span><br><span class=\"line\">        <span class=\"comment\">// 先枚举子串长度</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">L</span> <span class=\"operator\">=</span> <span class=\"number\">2</span>; L &lt;= len; L++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 枚举左边界，左边界的上限设置可以宽松一些</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得</span></span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> L + i - <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"comment\">// 如果右边界越界，就可以退出当前循环</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (j &gt;= len) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (charArray[i] != charArray[j]) &#123;</span><br><span class=\"line\">                    dp[i][j] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (j - i &lt; <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">                        dp[i][j] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        dp[i][j] = dp[i + <span class=\"number\">1</span>][j - <span class=\"number\">1</span>];</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (dp[i][j] &amp;&amp; j - i + <span class=\"number\">1</span> &gt; maxLen) &#123;</span><br><span class=\"line\">                    maxLen = j - i + <span class=\"number\">1</span>;</span><br><span class=\"line\">                    begin = i;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s.substring(begin, begin + maxLen);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"复杂度分析\"><a class=\"markdownIt-Anchor\" href=\"#复杂度分析\">#</a> 复杂度分析</h2>\n<p>时间复杂度： <code>O(n^2) </code> 其中 n 是字符串的长度。动态规划的状态总数为  <code>O(n^2)</code>  对于每个状态，我们需要转移的时间为  <code>O(1)</code> 。</p>\n<p>空间复杂度： <code>O(n^2)</code> ，即存储动态规划状态需要的空间。</p>\n","raw":null,"categories":[{"name":"java","path":"api/categories/java.json"}],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"},{"name":"动态规划","path":"api/tags/动态规划.json"}]},{"title":"复原IP地址——LeetCode93","slug":"restore-ip-addresses","date":"2022-01-04T13:58:27.000Z","updated":"2023-03-29T12:39:52.182Z","comments":null,"realpath":null,"path":"api/articles/restore-ip-addresses.json","excerpt":"# 题目描述有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。例如：“0.1.2.201” 和 “192.168.1.1” 是 有效 IP 地址，但是 “0.011.255.245”、“192.168.1.312” 和 “192.168@1.1” 是 无效 IP 地址。<br>给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 ‘.’ 来形成。你不能重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。","keywords":"算法,leetcode,ip,地址,回溯","cover":"/p/ab179abd/leetcode.jpeg","content":"<h1 id=\"题目描述\"><a class=\"markdownIt-Anchor\" href=\"#题目描述\">#</a> 题目描述</h1>\n<p>有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。</p>\n<p>例如：“0.1.2.201” 和 “192.168.1.1” 是 有效 IP 地址，但是 “0.011.255.245”、“192.168.1.312” 和 “192.168@1.1” 是 无效 IP 地址。<br>\n给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 ‘.’ 来形成。你不能重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。</p>\n<span id=\"more\"></span>\n<h2 id=\"用例\"><a class=\"markdownIt-Anchor\" href=\"#用例\">#</a> 用例</h2>\n<p>示例 1：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\"data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;25525511135&quot;</span><br><span class=\"line\">输出：[&quot;255.255.11.135&quot;,&quot;255.255.111.35&quot;]</span><br></pre></td></tr></table></figure></div>\n<p>示例 2：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\"data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;0000&quot;</span><br><span class=\"line\">输出：[&quot;0.0.0.0&quot;]</span><br></pre></td></tr></table></figure></div>\n<p>示例 3：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\"data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;1111&quot;</span><br><span class=\"line\">输出：[&quot;1.1.1.1&quot;]</span><br></pre></td></tr></table></figure></div>\n<p>示例 4：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\"data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;010010&quot;</span><br><span class=\"line\">输出：[&quot;0.10.0.10&quot;,&quot;0.100.1.0&quot;]</span><br></pre></td></tr></table></figure></div>\n<p>示例 5：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\"data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;101023&quot;</span><br><span class=\"line\">输出：[&quot;1.0.10.23&quot;,&quot;1.0.102.3&quot;,&quot;10.1.0.23&quot;,&quot;10.10.2.3&quot;,&quot;101.0.2.3&quot;]</span><br></pre></td></tr></table></figure></div>\n<p>提示：</p>\n<p>0 &lt;= s.length &lt;= 20<br>\ns 仅由数字组成</p>\n<h1 id=\"解题\"><a class=\"markdownIt-Anchor\" href=\"#解题\">#</a> 解题</h1>\n<h2 id=\"解题思路\"><a class=\"markdownIt-Anchor\" href=\"#解题思路\">#</a> 解题思路</h2>\n<p>由于我们需要找出所有可能复原出的 IP 地址，因此可以考虑使用<strong>回溯</strong>的方法，对<strong>所有可能的字符串分隔方式</strong>进行搜索，并筛选出满足要求的作为答案。</p>\n<p>设题目中给出的字符串为 s。我们用递归函数  <code>dfs(segId,segStart)</code>  表示我们正在从 <code>s[segStart] </code> 的位置开始，搜索 IP 地址中的第 segId 段，其中 <code>segId∈&#123;0,1,2,3&#125;</code> 。由于 IP 地址的每一段必须是  <code>[0, 255] </code> 中的整数，因此我们从 segStart 开始，从小到大依次枚举当前这一段 IP 地址的结束位置 segEnd。如果满足要求，就递归地进行下一段搜索，调用递归函数 <code>dfs(segId+1,segEnd+1)</code> 。</p>\n<p>特别地，由于 IP 地址的每一段不能有前导零，因此如果  <code>s[segStart]</code>  等于字符 0，那么 IP 地址的第 segId 段只能为 0，需要作为特殊情况进行考虑。</p>\n<p>在搜索的过程中，如果我们已经得到了全部的 4 段 IP 地址（即 segId=4），并且遍历完了整个字符串（即  <code>segStart=∣s∣</code> ，其中  <code>|s|</code>  表示字符串 s 的长度），那么就复原出了一种满足题目要求的 IP 地址，我们将其加入答案。在其它的时刻，如果提前遍历完了整个字符串，那么我们需要结束搜索，回溯到上一步。</p>\n<h2 id=\"代码实现\"><a class=\"markdownIt-Anchor\" href=\"#代码实现\">#</a> 代码实现</h2>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\"data-rel=\"JAVA\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">int</span> <span class=\"variable\">SEG_COUNT</span> <span class=\"operator\">=</span> <span class=\"number\">4</span>;</span><br><span class=\"line\">    List&lt;String&gt; ans = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;String&gt;();</span><br><span class=\"line\">    <span class=\"type\">int</span>[] segments = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[SEG_COUNT];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;String&gt; <span class=\"title function_\">restoreIpAddresses</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">        segments = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[SEG_COUNT];</span><br><span class=\"line\">        dfs(s, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">dfs</span><span class=\"params\">(String s, <span class=\"type\">int</span> segId, <span class=\"type\">int</span> segStart)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果找到了 4 段 IP 地址并且遍历完了字符串，那么就是一种答案</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (segId == SEG_COUNT) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (segStart == s.length()) &#123;</span><br><span class=\"line\">                <span class=\"type\">StringBuffer</span> <span class=\"variable\">ipAddr</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuffer</span>();</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; SEG_COUNT; ++i) &#123;</span><br><span class=\"line\">                    ipAddr.append(segments[i]);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (i != SEG_COUNT - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                        ipAddr.append(<span class=\"string\">&#x27;.&#x27;</span>);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                ans.add(ipAddr.toString());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 如果还没有找到 4 段 IP 地址就已经遍历完了字符串，那么提前回溯</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (segStart == s.length()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 由于不能有前导零，如果当前数字为 0，那么这一段 IP 地址只能为 0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.charAt(segStart) == <span class=\"string\">&#x27;0&#x27;</span>) &#123;</span><br><span class=\"line\">            segments[segId] = <span class=\"number\">0</span>;</span><br><span class=\"line\">            dfs(s, segId + <span class=\"number\">1</span>, segStart + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 一般情况，枚举每一种可能性并递归</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">addr</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">segEnd</span> <span class=\"operator\">=</span> segStart; segEnd &lt; s.length(); ++segEnd) &#123;</span><br><span class=\"line\">            addr = addr * <span class=\"number\">10</span> + (s.charAt(segEnd) - <span class=\"string\">&#x27;0&#x27;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (addr &gt; <span class=\"number\">0</span> &amp;&amp; addr &lt;= <span class=\"number\">0xFF</span>) &#123;</span><br><span class=\"line\">                segments[segId] = addr;</span><br><span class=\"line\">                dfs(s, segId + <span class=\"number\">1</span>, segEnd + <span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"复杂度分析\"><a class=\"markdownIt-Anchor\" href=\"#复杂度分析\">#</a> 复杂度分析</h2>\n<p>复杂度分析</p>\n<p>我们用 SEG_COUNT=4 表示 IP 地址的段数。</p>\n<p>时间复杂度： <code>O(3^SEG_COUNT × ∣s∣)</code> 。由于 IP 地址的每一段的位数不会超过 3，因此在递归的每一层，我们最多只会深入到下一层的 33 种情况。由于 SEG_COUNT=4，对应着递归的最大层数。如果我们复原出了一种满足题目要求的 IP 地址，那么需要  <code>O(∣s∣) </code> 的时间将其加入答案数组中，因此总时间复杂度为 <code>O(3 ^SEG_COUNT ×∣s∣)</code> 。</p>\n<p>空间复杂度： <code>O(SEG_COUNT)</code> ，这里只计入除了用来存储答案数组以外的额外空间复杂度。递归使用的空间与递归的最大深度 \\text {SEG_COUNT} SEG_COUNT 成正比。并且在上面的代码中，我们只额外使用了长度为  <code>SEG_COUNT</code>  的数组  <code>segments</code>  存储已经搜索过的 IP 地址，因此空间复杂度为 <code>O(SEG_COUNT)</code> 。</p>\n","raw":null,"categories":[{"name":"java","path":"api/categories/java.json"}],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"},{"name":"回溯","path":"api/tags/回溯.json"}]},{"title":"单词接龙——leetcode127","slug":"word-ladder","date":"2022-01-09T10:38:08.000Z","updated":"2023-03-29T12:39:52.206Z","comments":null,"realpath":null,"path":"api/articles/word-ladder.json","excerpt":"# 题目描述字典 wordList 中从单词 beginWord 和 endWord 的 转换序列 是一个按下述规格形成的序列：<br>序列中第一个单词是  beginWord  。<br>序列中最后一个单词是  endWord 。<br>每次转换只能改变一个字母。<br>转换过程中的中间单词必须是字典  wordList  中的单词。<br>给你两个单词  beginWord  和  endWord  和一个字典  wordList  ，找到从  beginWord  到  endWord  的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回  0 。","keywords":"算法,leetcode,单词接龙","cover":"/p/fbb9fe6d/leetcode127.png","content":"<h1 id=\"题目描述\"><a class=\"markdownIt-Anchor\" href=\"#题目描述\">#</a> 题目描述</h1>\n<p>字典 wordList 中从单词 beginWord 和 endWord 的 转换序列 是一个按下述规格形成的序列：<br>\n序列中第一个单词是  <code>beginWord</code>  。<br>\n序列中最后一个单词是  <code>endWord</code> 。<br>\n每次转换只能改变一个字母。<br>\n转换过程中的中间单词必须是字典  <code>wordList</code>  中的单词。<br>\n给你两个单词  <code>beginWord</code>  和  <code>endWord</code>  和一个字典  <code>wordList</code>  ，找到从  <code>beginWord </code> 到  <code>endWord</code>  的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回  <code>0</code> 。</p>\n<span id=\"more\"></span>\n<p>示例 1：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\"data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class=\"line\">输出：5</span><br><span class=\"line\">解释：一个最短转换序列是 &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;, 返回它的长度 5。</span><br></pre></td></tr></table></figure></div>\n<p>示例 2：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\"data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class=\"line\">输出：0</span><br><span class=\"line\">解释：endWord &quot;cog&quot; 不在字典中，所以无法进行转换。</span><br></pre></td></tr></table></figure></div>\n<p>提示：</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\"data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 &lt;= beginWord.length &lt;= 10</span><br><span class=\"line\">endWord.length == beginWord.length</span><br><span class=\"line\">1 &lt;= wordList.length &lt;= 5000</span><br><span class=\"line\">wordList[i].length == beginWord.length</span><br><span class=\"line\">beginWord、endWord 和 wordList[i] 由小写英文字母组成</span><br><span class=\"line\">beginWord != endWord</span><br><span class=\"line\">wordList 中的所有字符串 互不相同</span><br></pre></td></tr></table></figure></div>\n<h1 id=\"解题\"><a class=\"markdownIt-Anchor\" href=\"#解题\">#</a> 解题</h1>\n<h3 id=\"方法一广度优先搜索-优化建图\"><a class=\"markdownIt-Anchor\" href=\"#方法一广度优先搜索-优化建图\">#</a> 方法一：广度优先搜索 + 优化建图</h3>\n<h4 id=\"思路\"><a class=\"markdownIt-Anchor\" href=\"#思路\">#</a> 思路</h4>\n<p>本题要求的是最短转换序列的长度，看到最短首先想到的就是广度优先搜索。想到广度优先搜索自然而然的就能想到图，但是本题并没有直截了当的给出图的模型，因此我们需要把它抽象成图的模型。</p>\n<p>我们可以把每个单词都抽象为一个点，如果两个单词可以只改变一个字母进行转换，那么说明他们之间有一条双向边。因此我们只需要把满足转换条件的点相连，就形成了一张图。</p>\n<p>基于该图，我们以 beginWord 为图的起点，以 endWord 为终点进行广度优先搜索，寻找 beginWord 到 endWord 的最短路径。</p>\n<h4 id=\"算法\"><a class=\"markdownIt-Anchor\" href=\"#算法\">#</a> 算法</h4>\n<p>基于上面的思路我们考虑如何编程实现。</p>\n<p>首先为了方便表示，我们先给每一个单词标号，即给每个单词分配一个 id。创建一个由单词 word 到 id 对应的映射 wordId，并将 beginWord 与 wordList 中所有的单词都加入这个映射中。之后我们检查 endWord 是否在该映射内，若不存在，则输入无解。我们可以使用哈希表实现上面的映射关系。</p>\n<p>然后我们需要建图，依据朴素的思路，我们可以枚举每一对单词的组合，判断它们是否恰好相差一个字符，以判断这两个单词对应的节点是否能够相连。但是这样效率太低，我们可以优化建图。</p>\n<p>具体地，我们可以创建虚拟节点。对于单词 hit，我们创建三个虚拟节点 <em>it、h</em>t、hi*，并让 hit 向这三个虚拟节点分别连一条边即可。如果一个单词能够转化为 hit，那么该单词必然会连接到这三个虚拟节点之一。对于每一个单词，我们枚举它连接到的虚拟节点，把该单词对应的 id 与这些虚拟节点对应的 id 相连即可。</p>\n<p>最后我们将起点加入队列开始广度优先搜索，当搜索到终点时，我们就找到了最短路径的长度。注意因为添加了虚拟节点，所以我们得到的距离为实际最短路径长度的两倍。同时我们并未计算起点对答案的贡献，所以我们应当返回距离的一半再加一的结果。</p>\n<h4 id=\"代码\"><a class=\"markdownIt-Anchor\" href=\"#代码\">#</a> 代码</h4>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"false\"data-rel=\"JAVA\"><figure class=\"iseeu highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    Map&lt;String, Integer&gt; wordId = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;String, Integer&gt;();</span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; edge = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">nodeNum</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">ladderLength</span><span class=\"params\">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String word : wordList) &#123;</span><br><span class=\"line\">            addEdge(word);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        addEdge(beginWord);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!wordId.containsKey(endWord)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] dis = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[nodeNum];</span><br><span class=\"line\">        Arrays.fill(dis, Integer.MAX_VALUE);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">beginId</span> <span class=\"operator\">=</span> wordId.get(beginWord), endId = wordId.get(endWord);</span><br><span class=\"line\">        dis[beginId] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        Queue&lt;Integer&gt; que = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;Integer&gt;();</span><br><span class=\"line\">        que.offer(beginId);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!que.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">x</span> <span class=\"operator\">=</span> que.poll();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (x == endId) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> dis[endId] / <span class=\"number\">2</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> it : edge.get(x)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (dis[it] == Integer.MAX_VALUE) &#123;</span><br><span class=\"line\">                    dis[it] = dis[x] + <span class=\"number\">1</span>;</span><br><span class=\"line\">                    que.offer(it);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">addEdge</span><span class=\"params\">(String word)</span> &#123;</span><br><span class=\"line\">        addWord(word);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">id1</span> <span class=\"operator\">=</span> wordId.get(word);</span><br><span class=\"line\">        <span class=\"type\">char</span>[] array = word.toCharArray();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">length</span> <span class=\"operator\">=</span> array.length;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; length; ++i) &#123;</span><br><span class=\"line\">            <span class=\"type\">char</span> <span class=\"variable\">tmp</span> <span class=\"operator\">=</span> array[i];</span><br><span class=\"line\">            array[i] = <span class=\"string\">&#x27;*&#x27;</span>;</span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">newWord</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(array);</span><br><span class=\"line\">            addWord(newWord);</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">id2</span> <span class=\"operator\">=</span> wordId.get(newWord);</span><br><span class=\"line\">            edge.get(id1).add(id2);</span><br><span class=\"line\">            edge.get(id2).add(id1);</span><br><span class=\"line\">            array[i] = tmp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">addWord</span><span class=\"params\">(String word)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!wordId.containsKey(word)) &#123;</span><br><span class=\"line\">            wordId.put(word, nodeNum++);</span><br><span class=\"line\">            edge.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;Integer&gt;());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<h4 id=\"复杂度分析\"><a class=\"markdownIt-Anchor\" href=\"#复杂度分析\">#</a> 复杂度分析</h4>\n<ul>\n<li>时间复杂度： <code>O(N×C2)</code> 。其中  N 为 wordList 的长度， C 为列表中单词的长度。</li>\n</ul>\n<p>建图过程中，对于每一个单词，我们需要枚举它连接到的所有虚拟节点，时间复杂度为   <code>O(C)</code> ，将这些单词加入到哈希表中，时间复杂度为  <code>O(N×C)</code> ，因此总时间复杂度为  <code>O(N×C)</code> 。</p>\n<p>广度优先搜索的时间复杂度最坏情况下是 O (N \\times C) O (N×C)。每一个单词需要拓展出 O©O© 个虚拟节点，因此节点数 O (N \\times C) O (N×C)。</p>\n<ul>\n<li>空间复杂度： <code>O(N×C2)</code> 。其中 N 为 wordList 的长度，C 为列表中单词的长度。哈希表中包含  <code>O(N×C)</code>  个节点，每个节点占用空间  <code>O(C)</code> ，因此总的空间复杂度为  <code>O(N×C^2)</code> 。</li>\n</ul>\n","raw":null,"categories":[{"name":"算法","path":"api/categories/算法.json"}],"tags":[{"name":"leetcode","path":"api/tags/leetcode.json"},{"name":"算法","path":"api/tags/算法.json"},{"name":"单词接龙","path":"api/tags/单词接龙.json"}]}]}