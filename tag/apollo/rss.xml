<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>人间日常 • Posts by &#34;apollo&#34; tag</title>
        <link>https://www.pswen.cn</link>
        <description>所行皆过往，所愿皆成真</description>
        <language>zh-CN</language>
        <pubDate>Sun, 26 Feb 2023 12:39:24 +0000</pubDate>
        <lastBuildDate>Sun, 26 Feb 2023 12:39:24 +0000</lastBuildDate>
        <category>合照</category>
        <category>疫情</category>
        <category>春节</category>
        <category>烟花</category>
        <category>元宵节</category>
        <category>QQ</category>
        <category>那些年</category>
        <category>Apollo</category>
        <category>Spring</category>
        <category>动态配置</category>
        <category>聚会</category>
        <category>悼念</category>
        <category>linux</category>
        <category>acmesh</category>
        <category>域名证书</category>
        <category>leetcode</category>
        <category>算法</category>
        <category>贪心</category>
        <category>动态规划</category>
        <category>二分法</category>
        <category>快慢指针</category>
        <category>gulp</category>
        <category>压缩图片</category>
        <category>gulp-imagemin</category>
        <category>Java</category>
        <category>位运算</category>
        <category>正则</category>
        <category>js</category>
        <category>去除零</category>
        <category>jvm</category>
        <category>类加载</category>
        <category>jvm调优</category>
        <category>混合模式</category>
        <category>解释模式</category>
        <category>纯编译模式</category>
        <category>环形链表</category>
        <category>往昔时光</category>
        <category>大学</category>
        <category>高中</category>
        <category>往昔</category>
        <category>实习</category>
        <category>我们</category>
        <category>年轻</category>
        <category>年幼</category>
        <category>树</category>
        <category>dfs</category>
        <category>bfs</category>
        <category>武康大楼</category>
        <category>上海</category>
        <category>陆家嘴</category>
        <category>三叉戟</category>
        <category>上海外滩</category>
        <category>夜景</category>
        <category>晚霞</category>
        <category>云谷</category>
        <category>回溯</category>
        <category>矩阵</category>
        <category>深度遍历</category>
        <category>广度遍历</category>
        <category>图记</category>
        <category>天安云谷</category>
        <category>生活</category>
        <category>午餐</category>
        <category>单词接龙</category>
        <item>
            <guid isPermalink="true">https://www.pswen.cn/p/4c633c0c/</guid>
            <title>从Apollo动态配置原理学Spring(二)</title>
            <link>https://www.pswen.cn/p/4c633c0c/</link>
            <category>Apollo</category>
            <category>Spring</category>
            <pubDate>Sun, 26 Feb 2023 12:39:24 +0000</pubDate>
            <description><![CDATA[ &lt;blockquote&gt;
&lt;p&gt;Apollo 动态配置其实本质就是利用 Spring Bean 的生命周期的扩展点，这个扩展点超级多，不可能全部列出来，只说核心的扩展点。这也就是为什么 Spring 的扩展性很好的原因，开了很多的口子，尽可能让某个功能高内聚松耦合，用户需要哪个功能就用哪个，而不是直接来一个大而全的东西。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们先通过学习核心的，然后后续对照 Apollo 用到了哪些再对照，就会发现很多地方就能理解的很好了&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;p&gt;&lt;strong&gt;什么是 Spring Bean 的生命周期&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于普通的 Java 对象，当 new 的时候创建对象，然后该对象就能够使用了。一旦该对象不再被使用，则由 Java 自动进行垃圾回收。&lt;/p&gt;
&lt;p&gt;而 Spring 中的对象是 bean，bean 和普通的 Java 对象没啥大的区别，只不过 Spring 不再自己去 new 对象了，而是由 IoC 容器去帮助我们实例化对象并且管理它，我们需要哪个对象，去问 IoC 容器要即可。IoC 其实就是解决对象之间的耦合问题，Spring Bean 的生命周期完全由容器控制。&lt;/p&gt;
&lt;h2 id=&#34;spring-bean-的生命周期&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#spring-bean-的生命周期&#34;&gt;#&lt;/a&gt; Spring Bean 的生命周期&lt;/h2&gt;
&lt;p&gt;这里要提一下，这里我们说的 Spring Bean 的生命周期主要指的是 singleton bean，对于 prototype 的 bean ，Spring 在创建好交给使用者之后则不会再管理后续的生命周期。&lt;/p&gt;
&lt;p&gt;我们也来复习下 Spring 中的 bean 的作用域有哪些？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;singleton&lt;/code&gt;  : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;prototype&lt;/code&gt;  : 每次请求都会创建一个新的 bean 实例。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;request&lt;/code&gt;  : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;session&lt;/code&gt;  : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;global-session&lt;/code&gt; ： 全局 session 作用域，仅仅在基于 Portlet 的 web 应用中才有意义，Spring5 已经没有了。Portlet 是能够生成语义代码（例如：HTML）片段的小型 Java Web 插件。它们基于 portlet 容器，可以像 servlet 一样处理 HTTP 请求。但是，与 servlet 不同，每个 portlet 都有不同的会话。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们知道对于普通的 Java 对象来说，它们的生命周期就是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实例化&lt;/li&gt;
&lt;li&gt;该对象不再被使用时通过垃圾回收机制进行回收&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而对于 Spring Bean 的生命周期来说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实例化 Instantiation&lt;/li&gt;
&lt;li&gt;属性赋值 Populate&lt;/li&gt;
&lt;li&gt;初始化 Initialization&lt;/li&gt;
&lt;li&gt;销毁 Destruction&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实例化 -&amp;gt; 属性赋值 -&amp;gt; 初始化 -&amp;gt; 销毁&lt;/p&gt;
&lt;p&gt;只有四个步骤，这样拆解的话是不是感觉也不难？不像其他人写的那样直接一上来就各种 BeanPostProcessor、BeanFactoryPostProcessor 全部怼进流程里去，别说读者看着头大，自己写的可能短时间内还记得流程，隔个一段时间，你可能都不知道自己写了个啥。&lt;/p&gt;
&lt;p&gt;通过 Bean 创建流程入口 &lt;code&gt;AbstractApplicationContext#refresh()&lt;/code&gt;  方法的  &lt;code&gt;finishBeanFactoryInitialization(beanFactory)&lt;/code&gt;  处带大家跟一下源码，想了想还是不带入过多的代码进来，直接给到最终的主要逻辑。&lt;/p&gt;
&lt;div class=&#34;highlight-wrap&#34;autocomplete=&#34;off&#34; autocorrect=&#34;off&#34; autocapitalize=&#34;off&#34; spellcheck=&#34;false&#34; contenteditable=&#34;false&#34;data-rel=&#34;JAVA&#34;&gt;&lt;figure class=&#34;iseeu highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;protected&lt;/span&gt; Object &lt;span class=&#34;title function_&#34;&gt;doCreateBean&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(String beanName, RootBeanDefinition mbd, &lt;span class=&#34;meta&#34;&gt;@Nullable&lt;/span&gt; Object[] args)&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;throws&lt;/span&gt; BeanCreationException &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;BeanWrapper&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;instanceWrapper&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;literal&#34;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (mbd.isSingleton()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        instanceWrapper = (BeanWrapper)&lt;span class=&#34;built_in&#34;&gt;this&lt;/span&gt;.factoryBeanInstanceCache.remove(beanName);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (instanceWrapper == &lt;span class=&#34;literal&#34;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    	&lt;span class=&#34;comment&#34;&gt;// 实例化阶段&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        instanceWrapper = &lt;span class=&#34;built_in&#34;&gt;this&lt;/span&gt;.createBeanInstance(beanName, mbd, args);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;type&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;exposedObject&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; bean;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    	&lt;span class=&#34;comment&#34;&gt;// 属性赋值阶段&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;built_in&#34;&gt;this&lt;/span&gt;.populateBean(beanName, mbd, instanceWrapper);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;comment&#34;&gt;// 初始化阶段&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        exposedObject = &lt;span class=&#34;built_in&#34;&gt;this&lt;/span&gt;.initializeBean(beanName, exposedObject, mbd);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125; &lt;span class=&#34;keyword&#34;&gt;catch&lt;/span&gt; (Throwable var18) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        ...&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/div&gt;
&lt;p&gt;至于销毁，是在容器关闭时调用的，详见  &lt;code&gt;ConfigurableApplicationContext#close()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;是不是很清爽了？至于 BeanPostProcessor、BeanFactoryPostProcessor 以及其他的类，只不过是对主流程四个步骤的一系列扩展点而已。&lt;/p&gt;
&lt;h2 id=&#34;spring-bean-的生命周期的扩展点&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#spring-bean-的生命周期的扩展点&#34;&gt;#&lt;/a&gt; Spring Bean 的生命周期的扩展点&lt;/h2&gt;
&lt;p&gt;Spring Bean 的生命周期的扩展点超级多，老周这里不可能全部列出来，只说核心的扩展点。这也就是为什么 Spring 的扩展性很好的原因，开了很多的口子，尽可能让某个功能高内聚松耦合，用户需要哪个功能就用哪个，而不是直接来一个大而全的东西。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Bean 自身的方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如构造函数、getter/setter 以及 init-method 和 destory-method 所指定的方法等，也就对应着上文说的实例化 -&amp;gt; 属性赋值 -&amp;gt; 初始化 -&amp;gt; 销毁四个阶段。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/p/4c633c0c/20210707002134280.png&#34; alt=&#34;阶段示意图&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;容器级的方法（BeanPostProcessor 一系列接口）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;主要是后处理器方法，比如下图的  &lt;code&gt;InstantiationAwareBeanPostProcessor&lt;/code&gt; 、 &lt;code&gt;BeanPostProcessor&lt;/code&gt;  接口方法。这些接口的实现类是独立于 Bean 的，并且会注册到 Spring 容器中。在 Spring 容器创建任何 Bean 的时候，这些后处理器都会发生作用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/p/4c633c0c/20210707225212729.png&#34; alt=&#34;扩展点&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;InstantiationAwareBeanPostProcessor 源码分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们翻一下源码发现 InstantiationAwareBeanPostProcessor 是继承了 BeanPostProcessor&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/p/4c633c0c/20210707230505579.png&#34; alt=&#34;InstantiationAwareBeanPostProcessor &#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/p/4c633c0c/20210707230919307.png&#34; alt=&#34;BeanPostProcessor&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation&lt;/code&gt;  调用点&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Object postProcessBeforeInstantiation(Class&amp;lt;?&amp;gt; beanClass, String beanName)&lt;br&gt;
 返回值：如果返回的不为 null，那么后续的 Bean 的创建流程【实例化、初始化 afterProperties】都不会执行，而是直接使用返回的快捷 Bean，此时的正常执行顺序如下：&lt;br&gt;
InstantiationAwareBeanPostProcessor 接口中的 postProcessBeforeInstantiation，在实例化之前调用。&lt;br&gt;
BeanPostProcessor 接口中的 postProcessAfterInitialization，在实例化之后调用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20210707233026943.png&#34; alt=&#34;createbean&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/p/4c633c0c/20210707235533784.png&#34; alt=&#34;resolveBeforeInstantiation&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/p/4c633c0c/20210708000228655.png&#34; alt=&#34;applyBean&#34;&gt;&lt;/p&gt;
&lt;p&gt;总之，postProcessBeforeInstantiation 在 doCreateBean 之前调用，也就是在 bean 实例化之前调用的，英文源码注释解释道该方法的返回值会替换原本的 Bean 作为代理，这也是 &lt;a href=&#34;https://so.csdn.net/so/search?q=AOP&amp;amp;spm=1001.2101.3001.7020&#34;&gt;AOP&lt;/a&gt; 等功能实现的关键点。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation&lt;/code&gt;  调用点&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException&lt;br&gt;
 正常情况下在实例化之后在执行 populateBean 之前调用&lt;br&gt;
返回值：如果有指定的 bean 的时候返回 false，那么后续的属性填充和属性依赖注入【populateBean】将不会执行，同时后续的 postProcessPropertyValues 将不会执行，但是初始化和 BeanPostProcessor 的仍然会执行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;/p/4c633c0c/20210708005050274.png&#34; alt=&#34;populateBean&#34;&gt;&lt;/p&gt;
&lt;p&gt;public PropertyValues postProcessPropertyValues(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)&lt;br&gt;
 实例化之后调用，在方法 applyPropertyValues【属性填充】之前&lt;br&gt;
返回值：如果返回 null，那么将不会进行后续的属性填充，比如依赖注入等，如果返回的 pvs 额外的添加了属性，那么后续会填充到该类对应的属性中。&lt;br&gt;
pvs：PropertyValues 对象，用于封装指定类的对象，简单来说就是 PropertyValue 的集合，里面相当于以 key-value 形式存放类的属性和值。&lt;br&gt;
pds：PropertyDescriptor 对象数组，PropertyDescriptor 相当于存储类的属性，不过可以调用 set，get 方法设置和获取对应属性的值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/p/4c633c0c/20210708010057366.png&#34; alt=&#34;postProcessPropertyValues&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;BeanPostProcessor 源码分析&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#doCreateBean&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;/p/4c633c0c/20210708232740951.png&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;br&gt;
进入初始化接口：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/p/4c633c0c/20210708233139731.png&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;br&gt;
我们先来看&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#applyBeanPostProcessorsBeforeInitialization&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;/p/4c633c0c/20210708233742525.png&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先获取到所有的后置处理器 getBeanPostProcessors ()&lt;/li&gt;
&lt;li&gt;在 for 循环中依次调用后置处理器的方法  &lt;code&gt;processor.postProcessBeforeInitialization(result, beanName);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;进入 postProcessBeforeInitialization 方法&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;org.springframework.context.support.ApplicationContextAwareProcessor#postProcessBeforeInitialization&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;/p/4c633c0c/20210708234443215.png&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt;
&lt;p&gt;进入  &lt;code&gt;invokeAwareInterfaces(bean);&lt;/code&gt;  方法，当前 bean 实现了 ApplicationContextAware 接口。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/p/4c633c0c/20210708234639952.png&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ApplicationContextAwareProcessor#postProcessBeforeInitialization&lt;/code&gt;  首先判断此 bean 是不是各种的 Aware，如果是它列举的那几个 Aware 就获取 Bean 工厂的权限，可以向容器中导入相关的上下文环境，目的是为了 Bean 实例能够获取到相关的上下文，如果不是它列举的几个 Aware，那就调用  &lt;code&gt;invokeAwareInterfaces(bean)&lt;/code&gt; ，向容器中添加相关接口的上下文环境。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;3.3 工厂后处理器方法（BeanFactoryProcessor 一系列接口）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;包括  &lt;code&gt;AspectJWeavingEnabler&lt;/code&gt; 、 &lt;code&gt;CustomAutowireConfigurer&lt;/code&gt; 、 &lt;code&gt;ConfigurationClassPostProcessor&lt;/code&gt;  等。这些都是 Spring 框架中已经实现好的 BeanFactoryPostProcessor，用来实现某些特定的功能。&lt;/p&gt;
&lt;p&gt;我们知道 Spring IoC 容器初始化的关键环节就在  &lt;code&gt;org.springframework.context.support.AbstractApplicationContext#refresh&lt;/code&gt;  方法中 ，容器创建的主体流程都在这个方法里面，这个方法是真的重要！！！&lt;/p&gt;
&lt;p&gt;对于工厂后处理器方法老周这里直接带你看  &lt;code&gt;invokeBeanFactoryPostProcessors(beanFactory);&lt;/code&gt;  方法，这个方法处理的是  &lt;code&gt;BeanFactoryPostProcessor&lt;/code&gt;  接口的 Bean。调用方法如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/p/4c633c0c/20210709231013239.png&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;br&gt;
跟到最重要的方法里去，代码虽长，但逻辑中规中矩。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;BeanFactoryPostProcessor&lt;/code&gt; ：一切处理 BeanFactory 的父接口&lt;br&gt;
 &lt;code&gt;BeanDefinitionRegistryPostProcessor&lt;/code&gt; ：实现了 BeanFactoryPostProcessor 接口的接口&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/p/4c633c0c/20210709233225102.png&#34; alt=&#34;在这里插入图片描述&#34;&gt;&lt;br&gt;
流程说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调用 BeanDefinitionRegistryPostProcessor#postProcessBeanDefinitionRegistry (registry) 方法。参数 beanFactoryPostProcessors 传入的优先处理掉。然后获取容器注册的，对于这些 Bean 按照 PriorityOrdered 接口、Ordered、没有排序接口的实例分别进行处理。&lt;/li&gt;
&lt;li&gt;调用 BeanFactoryPostProcessor#postProcessBeanFactory (beanFactory) 方法。备注：BeanDefinitionRegistryPostProcessor 属于 BeanFactoryPostProcessor 子接口。先处理属于 BeanDefinitionRegistryPostProcessor 接口实例的 postProcessBeanFactory (beanFactory) 方法，然后获取容器注册的。对于这些 Bean 按照 PriorityOrdered 接口、Ordered、没有排序接口的实例分别进行处理。&lt;/li&gt;
&lt;/ul&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://www.pswen.cn/p/e352a76e/</guid>
            <title>从Apollo动态配置原理学Spring(一)</title>
            <link>https://www.pswen.cn/p/e352a76e/</link>
            <category>Apollo</category>
            <category>Spring</category>
            <category>动态配置</category>
            <pubDate>Thu, 23 Feb 2023 14:29:54 +0000</pubDate>
            <description><![CDATA[ &lt;blockquote&gt;
&lt;p&gt;最近工作碰到需要写一个类似携程 Apollo 的动态配置功能，以此系统学习该原理，熟练掌握下 Spring 的各种机制&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Apollo 动态配置原理简述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Apollo 配置中心动态生效机制，是基于 Http 长轮询请求和 Spring 扩展机制实现的，在 Spring 容器启动过程中，Apollo 通过自定义的 &lt;code&gt;BeanPostProcessor&lt;/code&gt;  和 &lt;code&gt;BeanFactoryPostProcessor&lt;/code&gt;  將参数中包含 &lt;code&gt;$&amp;#123;…&amp;#125;&lt;/code&gt;  占位符和 &lt;code&gt;@Value&lt;/code&gt;  注解的 Bean 注册到 Apollo 框架中定义的注册表中。然后通过 Http 长轮询不断的去获取服务端的配置信息，一旦配置发生变化，Apollo 会根据变化的配置的 Key 找到对应的 Bean，然后修改 Bean 的属性，从而实现了配置动态生效的特性。&lt;/p&gt;
&lt;p&gt;需要注意的是，Apollo 在配置变化后，只能修改 Bean 的属性，例如我们数据源的属性发生变化，新创建的 Connection 对象是没问题的，但是连接池中已经创建的 Connection 对象相关信息是不能动态修改的，所以依然需要重启应用。&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;p&gt;其中涉及到的 Spring 的扩展机制有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BeanFactoryPostProcessor&lt;/li&gt;
&lt;li&gt;BeanPostProcessor&lt;/li&gt;
&lt;li&gt;BeanDefinitionRegistry&lt;/li&gt;
&lt;li&gt;PropertySource&lt;/li&gt;
&lt;li&gt;ImportBeanDefinitionRegistrar&lt;/li&gt;
&lt;li&gt;PropertySourcesPlaceholderConfigurer&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;…&lt;/p&gt;
&lt;p&gt;其中每一个都是非常关键的点，我们后续会一一进行学习。&lt;/p&gt;
&lt;h2 id=&#34;apollo启动过程&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#apollo启动过程&#34;&gt;#&lt;/a&gt; Apollo 启动过程&lt;/h2&gt;
&lt;p&gt;首先，我们先看一张图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/p/e352a76e/image-20230223224050610.png&#34; alt=&#34;Apollo启动图&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Spring 启动，扫描 bean，将相关变量参数注册到 Apollo 属性注册表&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过 RemoteConfigRepository 获取配置，持久化本地，后续读取从本地读取，通过 &lt;code&gt;PropertySourcesProcessor&lt;/code&gt;  执行如下步骤&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;（1）根据命名空间从配置中心获取配置信息，创建 RemoteConfigRepository 和 LocalFileConfigRepository 对象。RemoteConfigRepository 表示远程配置中心资源，LocalFileConfigRepository 表示本地缓存配置资源。&lt;/p&gt;
&lt;p&gt;（2）LocalFileConfigRepository 对象缓存配置信息到 C:\opt\data 或者 /opt/data 目录&lt;/p&gt;
&lt;p&gt;（3）RemoteConfigRepository 开启 HTTP 长轮询请求定时任务，默认 2s 请求一次。&lt;/p&gt;
&lt;p&gt;（4）將本地缓存配置信息转换为 PropertySource 对象（Apollo 自定义了 Spring 的 PropertySource），加载到 Spring 的 Environment 对象中。至此静态配置就已经加入到环境变量中&lt;/p&gt;
&lt;p&gt;（5）將自定义的 ConfigPropertySource 注册为观察者。一旦 RemoteConfigRepository 发现远程配置中心信息发生变化，ConfigPropertySource 对象会得到通知。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;通过一个自定义监听器，监听对应事件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;后续通过长轮询请求监听到配置变化，根据配置读取注册表里面的 key 和对应的 bean，通过反射修改 bean 对应属性值&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;apollo扩展点&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#apollo扩展点&#34;&gt;#&lt;/a&gt; Apollo 扩展点&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;PropertySourcesProcessor&lt;/code&gt;  初始化 Apollo 配置、接入 Spring environment，初始化 Apollo 监听器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ApolloAnnotationProcessor&lt;/code&gt;  提供 Apollo 一些注解支持 &lt;code&gt;@ApolloConfig&lt;/code&gt; ， &lt;code&gt;@ApolloConfigChangeListener&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SpringValueProcessor&lt;/code&gt;  提供对 &lt;code&gt;@Value&lt;/code&gt;  动态生效能力 针对实例 bean&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SpringValueDefinitionProcessor&lt;/code&gt;  提供对 &lt;code&gt;@Value&lt;/code&gt;  动态生效能力 针对 bean 定义&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ApolloJsonValueProcessor&lt;/code&gt;  提供对 &lt;code&gt;@ApolloJsonValue&lt;/code&gt;  支持&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上述分别对应使用 Spring 的扩展能力 &lt;code&gt;BeanFactoryPostProcessor&lt;/code&gt; 、 &lt;code&gt;BeanPostProcessor&lt;/code&gt; 、 &lt;code&gt;BeanPostProcessor&lt;/code&gt;  和 &lt;code&gt;BeanFactoryPostProcessor&lt;/code&gt; 、 &lt;code&gt;BeanDefinitionRegistryPostProcessor&lt;/code&gt; 、 &lt;code&gt;BeanPostProcessor&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;我们这个系列也会对 apollo 基于 spring 提供的扩展点来嵌入自己的能力。主要为 BeanFactoryPostProcessor、BeanPostProcessor 这两个扩展点；先简单说一下：&lt;em&gt;&lt;strong&gt;只需要知道，BeanFactoryPostProcessor、BeanDefinitionRegistryPostProcessor 在生成所有 beandefinition 之后调用，而 BeanPostProcessor 在通过 beandefinition 实例化 bean 的过程中调用即可。&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;那这些实现我们就下篇见了！！！&lt;/p&gt;
 ]]></description>
        </item>
    </channel>
</rss>
