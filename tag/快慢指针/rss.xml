<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>人间日常 • Posts by &#34;快慢指针&#34; tag</title>
        <link>https://www.pswen.cn</link>
        <description>所行皆过往，所愿皆成真</description>
        <language>zh-CN</language>
        <pubDate>Fri, 12 Nov 2021 13:17:10 +0000</pubDate>
        <lastBuildDate>Fri, 12 Nov 2021 13:17:10 +0000</lastBuildDate>
        <category>疫情</category>
        <category>linux</category>
        <category>acmesh</category>
        <category>域名证书</category>
        <category>leetcode</category>
        <category>算法</category>
        <category>贪心</category>
        <category>动态规划</category>
        <category>二分法</category>
        <category>快慢指针</category>
        <category>gulp</category>
        <category>压缩图片</category>
        <category>gulp-imagemin</category>
        <category>Java</category>
        <category>位运算</category>
        <category>正则</category>
        <category>js</category>
        <category>去除零</category>
        <category>jvm</category>
        <category>类加载</category>
        <category>环形链表</category>
        <category>jvm调优</category>
        <category>混合模式</category>
        <category>解释模式</category>
        <category>纯编译模式</category>
        <category>往昔时光</category>
        <category>大学</category>
        <category>高中</category>
        <category>往昔</category>
        <category>实习</category>
        <category>我们</category>
        <category>年轻</category>
        <category>年幼</category>
        <category>树</category>
        <category>dfs</category>
        <category>bfs</category>
        <category>武康大楼</category>
        <category>上海</category>
        <category>陆家嘴</category>
        <category>三叉戟</category>
        <category>上海外滩</category>
        <category>夜景</category>
        <category>晚霞</category>
        <category>云谷</category>
        <category>回溯</category>
        <category>矩阵</category>
        <category>深度遍历</category>
        <category>广度遍历</category>
        <category>图记</category>
        <category>天安云谷</category>
        <category>生活</category>
        <category>午餐</category>
        <category>单词接龙</category>
        <item>
            <guid isPermalink="true">https://www.pswen.cn/p/1426/</guid>
            <title>环形链表——LeetCode141</title>
            <link>https://www.pswen.cn/p/1426/</link>
            <category>算法</category>
            <category>快慢指针</category>
            <category>环形链表</category>
            <pubDate>Fri, 12 Nov 2021 13:17:10 +0000</pubDate>
            <description><![CDATA[ &lt;p&gt;给定一个链表，判断链表中是否有环。&lt;/p&gt;
&lt;p&gt;如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。&lt;br&gt;
如果链表中存在环，则返回 true 。 否则，返回 false 。&lt;br&gt;
LeetCode-141 链接：&lt;a href=&#34;https://leetcode-cn.com/problems/linked-list-cycle&#34;&gt;https://leetcode-cn.com/problems/linked-list-cycle&lt;/a&gt;&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt; 
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/p/1426/circularlinkedlist.png&#34; alt=&#34;环形链表-示例1&#34;&gt;&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;输入：head = [3,2,0,-4], pos = 1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;输出：true&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;解释：链表中有一个环，其尾部连接到第二个节点。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;示例 2：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/p/1426/circularlinkedlist_test2.png&#34; alt=&#34;环形链表-示例2&#34;&gt;&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;输入：head = [1,2], pos = 0&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;输出：true&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;解释：链表中有一个环，其尾部连接到第一个节点。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;示例 3：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/p/1426/circularlinkedlist_test3.png&#34; alt=&#34;环形链表-示例3&#34;&gt;&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;输入：head = [1], pos = -1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;输出：false&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;解释：链表中没有环。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;链表中节点的数目范围是 [0, 104]&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;-105 &amp;lt;= Node.val &amp;lt;= 105&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;pos 为 -1 或者链表中的一个 有效索引 。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&#34;解题&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#解题&#34;&gt;#&lt;/a&gt; 解题&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Hash 表&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最容易想到的方法是遍历所有节点，每次遍历到一个节点时，判断该节点此前是否被访问过。&lt;/p&gt;
&lt;p&gt;具体地，我们可以使用哈希表来存储所有已经访问过的节点。每次我们到达一个节点，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。重复这一过程，直到我们遍历完整个链表即可。&lt;/p&gt;
&lt;p&gt;代码实现：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Solution&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;type&#34;&gt;boolean&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;hasCycle&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(ListNode head)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        Set&amp;lt;ListNode&amp;gt; seen = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;HashSet&lt;/span&gt;&amp;lt;ListNode&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;while&lt;/span&gt; (head != &lt;span class=&#34;literal&#34;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (!seen.add(head)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;literal&#34;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            head = head.next;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;literal&#34;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;复杂度分析&lt;/p&gt;
&lt;p&gt;时间复杂度： &lt;code&gt;O(N)&lt;/code&gt; ，其中  &lt;code&gt;N &lt;/code&gt; 是链表中的节点数。最坏情况下我们需要遍历每个节点一次。&lt;br&gt;
空间复杂度： &lt;code&gt;O(N)&lt;/code&gt; ，其中 &lt;code&gt;N &lt;/code&gt; 是链表中的节点数。主要为哈希表的开销，最坏情况下我们需要将每个节点插入到哈希表中一次。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;快慢指针&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;方法需要读者对「Floyd 判圈算法」（又称龟兔赛跑算法）有所了解。&lt;/p&gt;
&lt;p&gt;假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。&lt;/p&gt;
&lt;p&gt;我们可以根据上述思路来解决本题。具体地，我们定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/p/1426/2.png&#34; alt=&#34;龟兔赛跑&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么我们要规定初始时慢指针在位置 head，快指针在位置 head.next，而不是两个指针都在位置 head（即与「乌龟」和「兔子」中的叙述相同）？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;观察下面的代码，我们使用的是 while 循环，循环条件先于循环体。由于循环条件一定是判断快慢指针是否重合，如果我们将两个指针初始都置于 head，那么 while 循环就不会执行。因此，我们可以假想一个在 head 之前的虚拟节点，慢指针从虚拟节点移动一步到达 head，快指针从虚拟节点移动两步到达 head.next，这样我们就可以使用 while 循环了。&lt;/li&gt;
&lt;li&gt;当然，我们也可以使用 do-while 循环。此时，我们就可以把快慢指针的初始值都置为 head。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;代码实现：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Solution&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;type&#34;&gt;boolean&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;hasCycle&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(ListNode head)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (head == &lt;span class=&#34;literal&#34;&gt;null&lt;/span&gt; || head.next == &lt;span class=&#34;literal&#34;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;literal&#34;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;type&#34;&gt;ListNode&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;slow&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; head;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;type&#34;&gt;ListNode&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;fast&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; head.next;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;while&lt;/span&gt; (slow != fast) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (fast == &lt;span class=&#34;literal&#34;&gt;null&lt;/span&gt; || fast.next == &lt;span class=&#34;literal&#34;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;literal&#34;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            slow = slow.next;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            fast = fast.next.next;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;literal&#34;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;复杂度分析&lt;/p&gt;
&lt;p&gt;时间复杂度： &lt;code&gt;O(N)&lt;/code&gt; ，其中  &lt;code&gt;N&lt;/code&gt;  是链表中的节点数。&lt;br&gt;
当链表中不存在环时，快指针将先于慢指针到达链表尾部，链表中每个节点至多被访问两次。&lt;br&gt;
当链表中存在环时，每一轮移动后，快慢指针的距离将减小一。而初始距离为环的长度，因此至多移动&lt;br&gt;
 &lt;code&gt;N&lt;/code&gt;  轮。&lt;br&gt;
空间复杂度： &lt;code&gt;O(1)&lt;/code&gt; 。我们只使用了两个指针的额外空间。&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://www.pswen.cn/p/44752/</guid>
            <title>寻找重复数——LeetCode287</title>
            <link>https://www.pswen.cn/p/44752/</link>
            <category>leetcode</category>
            <category>算法</category>
            <category>二分法</category>
            <category>快慢指针</category>
            <pubDate>Thu, 11 Nov 2021 13:02:11 +0000</pubDate>
            <description><![CDATA[ &lt;p&gt;给定一个包含 n + 1 个整数的数组 nums ，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。&lt;br&gt;
假设 nums 只有 一个重复的整数 ，找出 这个重复的数 。&lt;br&gt;
你设计的解决方案必须不修改数组 nums 且只用常量级 O (1) 的额外空间。&lt;br&gt;
Leetcode-287 链接：&lt;a href=&#34;https://leetcode-cn.com/problems/find-the-duplicate-number&#34;&gt;https://leetcode-cn.com/problems/find-the-duplicate-number&lt;/a&gt;&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;figure class=&#34;highlight sh&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;输入：nums = [1,3,4,2,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;输出：2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;示例 2：&lt;/p&gt;
&lt;figure class=&#34;highlight sh&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;输入：nums = [3,1,3,4,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;输出：3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;示例 3：&lt;/p&gt;
&lt;figure class=&#34;highlight sh&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;输入：nums = [1,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;输出：1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;示例 4：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;输入：nums = [1,1,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;输出：1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;figure class=&#34;highlight sh&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1 &amp;lt;= n &amp;lt;= 105&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;nums.length == n + 1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;1 &amp;lt;= nums[i] &amp;lt;= n&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;nums 中 只有一个整数 出现 两次或多次 ，其余整数均只出现 一次&lt;/p&gt;
&lt;h3 id=&#34;解题&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#解题&#34;&gt;#&lt;/a&gt; 解题&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;二分法&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;针对用例 &lt;code&gt;[1,3,4,2,2]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;定义一个 &lt;code&gt;cnt&lt;/code&gt;  数组用来存储小于等于 索引  &lt;code&gt;i&lt;/code&gt;  的总数&lt;/p&gt;
&lt;p&gt;如果知道 cnt 数组随数字 index 逐渐增大具有单调性，那么当 num [index] 那么我们就可以直接利用二分查找来找到重复的数&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;nums&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;1&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;2&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;3&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;4&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;cnt&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;小于等于 1 的一个&lt;/p&gt;
&lt;p&gt;小于等于 2 的三个&lt;/p&gt;
&lt;p&gt;小于等于 3 的四个&lt;/p&gt;
&lt;p&gt;小于等于 4 的五个&lt;/p&gt;
&lt;p&gt;由此可见：我们的目标是 2，target 满足: target 前面的  &lt;code&gt;cnt[i] &amp;lt;=  i&lt;/code&gt; , 目标值 target 之后的  &lt;code&gt;cnt[i] &amp;gt; i&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;实际上可以归纳为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果测试用例的数组中  &lt;code&gt;target&lt;/code&gt;  出现了两次，其余的数各出现了一次，这个时候肯定满足上文提及的性质，因为小于  &lt;code&gt;target&lt;/code&gt;  的数 i 满足  &lt;code&gt;cnt[i]=i&lt;/code&gt; ，大于等于  &lt;code&gt;target&lt;/code&gt;  的数  &lt;code&gt;j&lt;/code&gt;  满足  &lt;code&gt;cnt[j]=j+1&lt;/code&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果测试用例的数组中 &lt;code&gt;target &lt;/code&gt; 出现了三次及以上，那么必然有一些数不在  &lt;code&gt;nums&lt;/code&gt;  数组中了，这个时候相当于我们用 &lt;code&gt;target&lt;/code&gt;  去替换了这些数，我们考虑替换的时候对 &lt;code&gt;cnt[] &lt;/code&gt; 数组的影响。如果替换的数 &lt;code&gt;i&lt;/code&gt;  小于  &lt;code&gt;target&lt;/code&gt;  ，那么在数 &lt;code&gt;i&lt;/code&gt;  到 &lt;code&gt;target&lt;/code&gt;  区间的值，均减一，其他不变，满足条件。如果替换的数  &lt;code&gt;j&lt;/code&gt;  大于等于  &lt;code&gt;target&lt;/code&gt; ，那么 &lt;code&gt;target&lt;/code&gt;  到 数 &lt;code&gt;j&lt;/code&gt;  区间内值均加一，其他不变，亦满足条件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此不管多个重复还是两个重复，数组都满足那个性质。&lt;/p&gt;
&lt;p&gt;代码实现：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;28&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Solution&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;findDuplicate&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt;[] nums)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; nums.length;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;l&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, r = n - &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;, ans = -&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;while&lt;/span&gt; (l &amp;lt;= r) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;           # 右移动一位，相关于除以&lt;span class=&#34;number&#34;&gt;2&lt;/span&gt;，取中间值&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;mid&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; (l + r) &amp;gt;&amp;gt; &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;cnt&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;for&lt;/span&gt; (&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;; i &amp;lt; n; ++i) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;              # 将小于等于中间值都加起来  &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;              &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (nums[i] &amp;lt;= mid) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                    cnt++;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;           # 如果此时的cnt总数小于等于mid，那说明不在mid左边&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (cnt &amp;lt;= mid) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;               # 把左边拉到中间&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                l = mid + &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &amp;#125; &lt;span class=&#34;keyword&#34;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                # 否则把右边拉到中间&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                r = mid - &lt;span class=&#34;number&#34;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                # 记录答案&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                ans = mid;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; ans;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;复杂度分析&lt;/p&gt;
&lt;p&gt;时间复杂度： &lt;code&gt;O(n * logn)&lt;/code&gt; ，其中 n 为 nums 数组的长度。二分查找最多需要二分 &lt;code&gt;O(logn) &lt;/code&gt; 次，每次判断的时候需要 &lt;code&gt;O(n)&lt;/code&gt;  遍历 nums 数组求解小于等于 mid 的数的个数，因此总时间复杂度为 &lt;code&gt;O(n * logn)&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;空间复杂度： &lt;code&gt;O(1)&lt;/code&gt; 。我们只需要常数空间存放若干变量。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;快慢指针&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们对 nums 数组建图，每个位置  &lt;code&gt;i&lt;/code&gt;  连一条  &lt;code&gt;i→nums[i]&lt;/code&gt;  的边。由于存在的重复的数字&lt;br&gt;
 &lt;code&gt;target&lt;/code&gt;  因此  &lt;code&gt;target &lt;/code&gt; 这个位置一定有起码两条指向它的边，因此整张图一定存在环，且我们要找到的&lt;br&gt;
 &lt;code&gt;target&lt;/code&gt;  就是这个环的入口.&lt;/p&gt;
&lt;p&gt;我们先设置慢指针 &lt;code&gt;slow 和快指针&lt;/code&gt;   &lt;code&gt;fast&lt;/code&gt;  ，慢指针每次走一步，快指针每次走两步，根据「Floyd 判圈算法」两个指针在有环的情况下一定会相遇，此时我们再将  &lt;code&gt;slow&lt;/code&gt;  放置起点 &lt;code&gt;0&lt;/code&gt; ，两个指针每次同时移动一步，相遇的点就是答案。&lt;/p&gt;
&lt;p&gt;代码实现：&lt;/p&gt;
&lt;figure class=&#34;highlight java&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Solution&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;findDuplicate&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(&lt;span class=&#34;type&#34;&gt;int&lt;/span&gt;[] nums)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;type&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;slow&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;, fast = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;      	# 找环的入口&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;do&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            slow = nums[slow];&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            fast = nums[nums[fast]];&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &amp;#125; &lt;span class=&#34;keyword&#34;&gt;while&lt;/span&gt; (slow != fast);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        # 重置slow为起点&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        slow = &lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;while&lt;/span&gt; (slow != fast) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            slow = nums[slow];&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            fast = nums[fast];&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        # 再次相遇 就是环入口&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; slow;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;复杂度分析&lt;/p&gt;
&lt;p&gt;时间复杂度： &lt;code&gt;O(n)&lt;/code&gt; 。「Floyd 判圈算法」时间复杂度为线性的时间复杂度。&lt;br&gt;
空间复杂度： &lt;code&gt;O(1)&lt;/code&gt; 。我们只需要常数空间存放若干变量。&lt;/p&gt;
 ]]></description>
        </item>
    </channel>
</rss>
