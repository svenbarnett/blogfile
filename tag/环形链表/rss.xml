<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>人间日常 • Posts by &#34;环形链表&#34; tag</title>
        <link>https://www.pswen.cn</link>
        <description>所行皆过往，所愿皆成真</description>
        <language>zh-CN</language>
        <pubDate>Fri, 12 Nov 2021 13:17:10 +0000</pubDate>
        <lastBuildDate>Fri, 12 Nov 2021 13:17:10 +0000</lastBuildDate>
        <category>合照</category>
        <category>疫情</category>
        <category>春节</category>
        <category>烟花</category>
        <category>元宵节</category>
        <category>QQ</category>
        <category>那些年</category>
        <category>Apollo</category>
        <category>Spring</category>
        <category>动态配置</category>
        <category>聚会</category>
        <category>悼念</category>
        <category>linux</category>
        <category>acmesh</category>
        <category>域名证书</category>
        <category>leetcode</category>
        <category>算法</category>
        <category>贪心</category>
        <category>动态规划</category>
        <category>二分法</category>
        <category>快慢指针</category>
        <category>gulp</category>
        <category>压缩图片</category>
        <category>gulp-imagemin</category>
        <category>Java</category>
        <category>位运算</category>
        <category>正则</category>
        <category>js</category>
        <category>去除零</category>
        <category>jvm</category>
        <category>类加载</category>
        <category>jvm调优</category>
        <category>混合模式</category>
        <category>解释模式</category>
        <category>纯编译模式</category>
        <category>环形链表</category>
        <category>往昔时光</category>
        <category>大学</category>
        <category>高中</category>
        <category>往昔</category>
        <category>实习</category>
        <category>我们</category>
        <category>年轻</category>
        <category>年幼</category>
        <category>树</category>
        <category>dfs</category>
        <category>bfs</category>
        <category>武康大楼</category>
        <category>上海</category>
        <category>陆家嘴</category>
        <category>三叉戟</category>
        <category>上海外滩</category>
        <category>夜景</category>
        <category>晚霞</category>
        <category>云谷</category>
        <category>回溯</category>
        <category>矩阵</category>
        <category>深度遍历</category>
        <category>广度遍历</category>
        <category>图记</category>
        <category>天安云谷</category>
        <category>生活</category>
        <category>午餐</category>
        <category>单词接龙</category>
        <item>
            <guid isPermalink="true">https://www.pswen.cn/p/1426/index.html</guid>
            <title>环形链表——LeetCode141</title>
            <link>https://www.pswen.cn/p/1426/index.html</link>
            <category>算法</category>
            <category>快慢指针</category>
            <category>环形链表</category>
            <pubDate>Fri, 12 Nov 2021 13:17:10 +0000</pubDate>
            <description><![CDATA[ &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;给定一个链表，判断链表中是否有环。&lt;/p&gt;
&lt;p&gt;如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。&lt;br&gt;
如果链表中存在环，则返回 true 。 否则，返回 false 。&lt;br&gt;
LeetCode-141 链接：&lt;a href=&#34;https://leetcode-cn.com/problems/linked-list-cycle&#34;&gt;https://leetcode-cn.com/problems/linked-list-cycle&lt;/a&gt;&lt;/p&gt;
&lt;span id=&#34;more&#34;&gt;&lt;/span&gt; 
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/p/1426/index/circularlinkedlist.png&#34; alt=&#34;环形链表-示例1&#34;&gt;&lt;/p&gt;
&lt;div class=&#34;highlight-wrap&#34; autocomplete=&#34;off&#34; autocorrect=&#34;off&#34; autocapitalize=&#34;off&#34; spellcheck=&#34;false&#34; contenteditable=&#34;false&#34; data-rel=&#34;BASH&#34;&gt;&lt;figure class=&#34;iseeu highlight bash&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;输入：&lt;span class=&#34;built_in&#34;&gt;head&lt;/span&gt; = [3,2,0,-4], pos = 1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;输出：&lt;span class=&#34;literal&#34;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;解释：链表中有一个环，其尾部连接到第二个节点。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/div&gt;
&lt;p&gt;示例 2：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/p/1426/index/circularlinkedlist_test2.png&#34; alt=&#34;环形链表-示例2&#34;&gt;&lt;/p&gt;
&lt;div class=&#34;highlight-wrap&#34; autocomplete=&#34;off&#34; autocorrect=&#34;off&#34; autocapitalize=&#34;off&#34; spellcheck=&#34;false&#34; contenteditable=&#34;false&#34; data-rel=&#34;BASH&#34;&gt;&lt;figure class=&#34;iseeu highlight bash&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;输入：&lt;span class=&#34;built_in&#34;&gt;head&lt;/span&gt; = [1,2], pos = 0&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;输出：&lt;span class=&#34;literal&#34;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;解释：链表中有一个环，其尾部连接到第一个节点。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/div&gt;
&lt;p&gt;示例 3：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/p/1426/index/circularlinkedlist_test3.png&#34; alt=&#34;环形链表-示例3&#34;&gt;&lt;/p&gt;
&lt;div class=&#34;highlight-wrap&#34; autocomplete=&#34;off&#34; autocorrect=&#34;off&#34; autocapitalize=&#34;off&#34; spellcheck=&#34;false&#34; contenteditable=&#34;false&#34; data-rel=&#34;BASH&#34;&gt;&lt;figure class=&#34;iseeu highlight bash&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;输入：&lt;span class=&#34;built_in&#34;&gt;head&lt;/span&gt; = [1], pos = -1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;输出：&lt;span class=&#34;literal&#34;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;解释：链表中没有环。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/div&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;div class=&#34;highlight-wrap&#34; autocomplete=&#34;off&#34; autocorrect=&#34;off&#34; autocapitalize=&#34;off&#34; spellcheck=&#34;false&#34; contenteditable=&#34;false&#34; data-rel=&#34;REASONML&#34;&gt;&lt;figure class=&#34;iseeu highlight reasonml&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;链表中节点的数目范围是 &lt;span class=&#34;literal&#34;&gt;[&lt;span class=&#34;number&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;number&#34;&gt;104&lt;/span&gt;]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;-&lt;span class=&#34;number&#34;&gt;105&lt;/span&gt; &amp;lt;= &lt;span class=&#34;module-access&#34;&gt;&lt;span class=&#34;module&#34;&gt;&lt;span class=&#34;identifier&#34;&gt;Node&lt;/span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;keyword&#34;&gt;val&lt;/span&gt; &amp;lt;= &lt;span class=&#34;number&#34;&gt;105&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;pos 为 -&lt;span class=&#34;number&#34;&gt;1&lt;/span&gt; 或者链表中的一个 有效索引 。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/div&gt;
&lt;h3 id=&#34;解题&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#解题&#34;&gt;#&lt;/a&gt; 解题&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Hash 表&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最容易想到的方法是遍历所有节点，每次遍历到一个节点时，判断该节点此前是否被访问过。&lt;/p&gt;
&lt;p&gt;具体地，我们可以使用哈希表来存储所有已经访问过的节点。每次我们到达一个节点，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。重复这一过程，直到我们遍历完整个链表即可。&lt;/p&gt;
&lt;p&gt;代码实现：&lt;/p&gt;
&lt;div class=&#34;highlight-wrap&#34; autocomplete=&#34;off&#34; autocorrect=&#34;off&#34; autocapitalize=&#34;off&#34; spellcheck=&#34;false&#34; contenteditable=&#34;false&#34; data-rel=&#34;JAVA&#34;&gt;&lt;figure class=&#34;iseeu highlight java&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Solution&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;type&#34;&gt;boolean&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;hasCycle&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(ListNode head)&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        Set&amp;lt;ListNode&amp;gt; seen = &lt;span class=&#34;keyword&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;HashSet&lt;/span&gt;&amp;lt;ListNode&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;while&lt;/span&gt; (head != &lt;span class=&#34;literal&#34;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (!seen.add(head)) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;literal&#34;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            }&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            head = head.next;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        }&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;literal&#34;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    }&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/div&gt;
&lt;p&gt;复杂度分析&lt;/p&gt;
&lt;p&gt;时间复杂度： &lt;code&gt;O(N)&lt;/code&gt; ，其中  &lt;code&gt;N &lt;/code&gt; 是链表中的节点数。最坏情况下我们需要遍历每个节点一次。&lt;br&gt;
空间复杂度： &lt;code&gt;O(N)&lt;/code&gt; ，其中 &lt;code&gt;N &lt;/code&gt; 是链表中的节点数。主要为哈希表的开销，最坏情况下我们需要将每个节点插入到哈希表中一次。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;快慢指针&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;方法需要读者对「Floyd 判圈算法」（又称龟兔赛跑算法）有所了解。&lt;/p&gt;
&lt;p&gt;假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。&lt;/p&gt;
&lt;p&gt;我们可以根据上述思路来解决本题。具体地，我们定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/p/1426/index/2.png&#34; alt=&#34;龟兔赛跑&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么我们要规定初始时慢指针在位置 head，快指针在位置 head.next，而不是两个指针都在位置 head（即与「乌龟」和「兔子」中的叙述相同）？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;观察下面的代码，我们使用的是 while 循环，循环条件先于循环体。由于循环条件一定是判断快慢指针是否重合，如果我们将两个指针初始都置于 head，那么 while 循环就不会执行。因此，我们可以假想一个在 head 之前的虚拟节点，慢指针从虚拟节点移动一步到达 head，快指针从虚拟节点移动两步到达 head.next，这样我们就可以使用 while 循环了。&lt;/li&gt;
&lt;li&gt;当然，我们也可以使用 do-while 循环。此时，我们就可以把快慢指针的初始值都置为 head。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;代码实现：&lt;/p&gt;
&lt;div class=&#34;highlight-wrap&#34; autocomplete=&#34;off&#34; autocorrect=&#34;off&#34; autocapitalize=&#34;off&#34; spellcheck=&#34;false&#34; contenteditable=&#34;false&#34; data-rel=&#34;JAVA&#34;&gt;&lt;figure class=&#34;iseeu highlight java&#34;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;keyword&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;title class_&#34;&gt;Solution&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    &lt;span class=&#34;keyword&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;type&#34;&gt;boolean&lt;/span&gt; &lt;span class=&#34;title function_&#34;&gt;hasCycle&lt;/span&gt;&lt;span class=&#34;params&#34;&gt;(ListNode head)&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (head == &lt;span class=&#34;literal&#34;&gt;null&lt;/span&gt; || head.next == &lt;span class=&#34;literal&#34;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;literal&#34;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        }&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;type&#34;&gt;ListNode&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;slow&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; head;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;type&#34;&gt;ListNode&lt;/span&gt; &lt;span class=&#34;variable&#34;&gt;fast&lt;/span&gt; &lt;span class=&#34;operator&#34;&gt;=&lt;/span&gt; head.next;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;while&lt;/span&gt; (slow != fast) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            &lt;span class=&#34;keyword&#34;&gt;if&lt;/span&gt; (fast == &lt;span class=&#34;literal&#34;&gt;null&lt;/span&gt; || fast.next == &lt;span class=&#34;literal&#34;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;                &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;literal&#34;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            }&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            slow = slow.next;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;            fast = fast.next.next;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        }&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;        &lt;span class=&#34;keyword&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;literal&#34;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;    }&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;}&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/div&gt;
&lt;p&gt;复杂度分析&lt;/p&gt;
&lt;p&gt;时间复杂度： &lt;code&gt;O(N)&lt;/code&gt; ，其中  &lt;code&gt;N&lt;/code&gt;  是链表中的节点数。&lt;br&gt;
当链表中不存在环时，快指针将先于慢指针到达链表尾部，链表中每个节点至多被访问两次。&lt;br&gt;
当链表中存在环时，每一轮移动后，快慢指针的距离将减小一。而初始距离为环的长度，因此至多移动&lt;br&gt;
 &lt;code&gt;N&lt;/code&gt;  轮。&lt;br&gt;
空间复杂度： &lt;code&gt;O(1)&lt;/code&gt; 。我们只使用了两个指针的额外空间。&lt;/p&gt;
&lt;/body&gt;&lt;/html&gt; ]]></description>
        </item>
    </channel>
</rss>
