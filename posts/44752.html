<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  
  <title>寻找重复数——LeetCode287 | 人间日常 | 所行皆过往，所愿皆成真</title>

  
  <meta name="author" content="SIWEN.PENG">
  

  
  <meta name="description" content="使用二分法解决寻找重复数，练习二分法使用">
  

  
  <meta name="keywords" content="寻找重复数,二分法,算法,leetcode,psw,彭思文,siwen,思文,sven,java,study,solution,blog">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1,user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="寻找重复数——LeetCode287"/>

  <meta property="og:site_name" content="人间日常"/>

  
  <meta property="og:image" content="/avatar.jpg"/>
  

  <link href="/avatar.jpg" rel="icon">
  <link rel="alternate" href="/atom.xml" title="人间日常" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/custom.css" media="screen" type="text/css">
  
  
  

  <script src="//sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
<meta name="generator" content="Hexo 6.3.0"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>

<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">人间日常</a>
    </h1>
    <p class="site-description">所行皆过往，所愿皆成真</p>
    <span class="site-description" id="jinrishici-sentence">正在加载今日诗词....</span>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives/index.html">归档</a></li>
      
        <li><a href="/pics/index.html">图记</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <div id="container">
<article>

  
    
    <h3 class="article-title"><span>寻找重复数——LeetCode287</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/posts/44752.html" rel="bookmark">
        <time class="entry-date published" datetime="2021-11-11T13:02:11.000Z">
          2021-11-11
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="article-cover">
      
    </div>
    <div class="entry">
      
        <html><head></head><body><p>给定一个包含 n + 1 个整数的数组 nums ，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。<br>假设 nums 只有 一个重复的整数 ，找出 这个重复的数 。<br>你设计的解决方案必须不修改数组 nums 且只用常量级 O(1) 的额外空间。<br>Leetcode-287 链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-the-duplicate-number">https://leetcode-cn.com/problems/find-the-duplicate-number</a><br><span id="more"></span><br>示例 1：<br></p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs sh"><code class="language-hljs sh">输入：nums = [1,3,4,2,2]<br>输出：2<br></code></pre></td></tr></tbody></table></figure><p></p>
<p>示例 2：<br></p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs sh"><code class="language-hljs sh">输入：nums = [3,1,3,4,2]<br>输出：3<br></code></pre></td></tr></tbody></table></figure><p></p>
<p>示例 3：<br></p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs sh"><code class="language-hljs sh">输入：nums = [1,1]<br>输出：1<br></code></pre></td></tr></tbody></table></figure><p></p>
<p>示例 4：<br></p><figure class="highlight fix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre class=" language-hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [1,1,2]</span><br><span class="hljs-string"><code class="language-hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [1,1,2]</span><br><span class="hljs-string">输出：1</span><br></code></pre></td></tr></tbody></table></figure><p></p>
<p>提示：<br></p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre class=" language-hljs sh"><code class="language-hljs sh">1 <= n <= 105<br>nums.length == n + 1<br>1 <= nums[i] <= n<br></code></pre></td></tr></tbody></table></figure><br>nums 中 只有一个整数 出现 两次或多次 ，其余整数均只出现 一次<p></p>
<h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><ol>
<li>二分法</li>
</ol>
<p>针对用例<code>[1,3,4,2,2]</code></p>
<p>定义一个<code>cnt</code>数组用来存储小于等于 索引 <code>i</code> 的总数</p>
<p>如果知道 cnt 数组随数字 index 逐渐增大具有单调性，那么当num[index] 那么我们就可以直接利用二分查找来找到重复的数</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">nums</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">cnt</td>
<td style="text-align:center">1</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
</tr>
</tbody>
</table>
</div>
<p>小于等于1的一个</p>
<p>小于等于2的三个</p>
<p>小于等于3的四个</p>
<p>小于等于4的五个</p>
<p>由此可见：我们的目标是2，target满足: target前面的 <code>cnt[i] &lt;=  i</code>, 目标值target之后的 <code>cnt[i] &gt; i</code></p>
<p>实际上可以归纳为：</p>
<ul>
<li><p>如果测试用例的数组中 <code>target</code> 出现了两次，其余的数各出现了一次，这个时候肯定满足上文提及的性质，因为小于 <code>target</code> 的数 i 满足 <code>cnt[i]=i</code>，大于等于 <code>target</code> 的数 <code>j</code>满足 <code>cnt[j]=j+1</code>。</p>
</li>
<li><p>如果测试用例的数组中<code>target</code>出现了三次及以上，那么必然有一些数不在 <code>nums</code> 数组中了，这个时候相当于我们用<code>target</code>去替换了这些数，我们考虑替换的时候对<code>cnt[]</code>数组的影响。如果替换的数<code>i</code>小于 <code>target</code> ，那么在数<code>i</code>到<code>target</code>区间的值，均减一，其他不变，满足条件。如果替换的数 <code>j</code> 大于等于 <code>target</code>，那么<code>target</code>到 数<code>j</code>区间内值均加一，其他不变，亦满足条件。</p>
</li>
</ul>
<p>因此不管多个重复还是两个重复，数组都满足那个性质。</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findDuplicate</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> {<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, r = n - <span class="hljs-number">1</span>, ans = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt;= r) {<br>           # 右移动一位，相关于除以<span class="hljs-number">2</span>，取中间值<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) {<br>              # 将小于等于中间值都加起来  <br>              <span class="hljs-keyword">if</span> (nums[i] &lt;= mid) {<br>                    cnt++;<br>                }<br>            }<br>           # 如果此时的cnt总数小于等于mid，那说明不在mid左边<br>            <span class="hljs-keyword">if</span> (cnt &lt;= mid) {<br>               # 把左边拉到中间<br>                l = mid + <span class="hljs-number">1</span>;<br>            } <span class="hljs-keyword">else</span> {<br>                # 否则把右边拉到中间<br>                r = mid - <span class="hljs-number">1</span>;<br>                # 记录答案<br>                ans = mid;<br>            }<br>        }<br>        <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findDuplicate</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> {<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, r = n - <span class="hljs-number">1</span>, ans = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt;= r) {<br>           # 右移动一位，相关于除以<span class="hljs-number">2</span>，取中间值<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i) {<br>              # 将小于等于中间值都加起来  <br>              <span class="hljs-keyword">if</span> (nums[i] &lt;= mid) {<br>                    cnt++;<br>                }<br>            }<br>           # 如果此时的cnt总数小于等于mid，那说明不在mid左边<br>            <span class="hljs-keyword">if</span> (cnt &lt;= mid) {<br>               # 把左边拉到中间<br>                l = mid + <span class="hljs-number">1</span>;<br>            } <span class="hljs-keyword">else</span> {<br>                # 否则把右边拉到中间<br>                r = mid - <span class="hljs-number">1</span>;<br>                # 记录答案<br>                ans = mid;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> ans;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>复杂度分析</p>
<p>时间复杂度：<code>O(n * logn)</code>，其中 n为nums 数组的长度。二分查找最多需要二分<code>O(logn)</code>次，每次判断的时候需要<code>O(n)</code> 遍历 nums 数组求解小于等于mid 的数的个数，因此总时间复杂度为<code>O(n * logn)</code>。</p>
<p>空间复杂度：<code>O(1)</code>。我们只需要常数空间存放若干变量。</p>
<ol>
<li>快慢指针</li>
</ol>
<p>我们对 nums数组建图，每个位置 <code>i</code> 连一条 <code>i→nums[i]</code> 的边。由于存在的重复的数字<br><code>target</code>因此 <code>target</code>这个位置一定有起码两条指向它的边，因此整张图一定存在环，且我们要找到的<br><code>target</code>就是这个环的入口.</p>
<p>我们先设置慢指针<code>slow 和快指针</code> <code>fast</code> ，慢指针每次走一步，快指针每次走两步，根据「Floyd 判圈算法」两个指针在有环的情况下一定会相遇，此时我们再将 <code>slow</code> 放置起点<code>0</code>，两个指针每次同时移动一步，相遇的点就是答案。</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre class=" language-hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findDuplicate</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> {<br>        <span class="hljs-type">int</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, fast = <span class="hljs-number">0</span>;<br>      	# 找环的入口<br>        <span class="hljs-keyword">do</span> {<br>            slow = nums[slow];<br>            fast = nums[nums[fast]];<br>        } <span class="hljs-keyword">while</span> (slow != fast);<br>        # 重置slow为起点<br>        slow = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (slow != fast) {<br>            slow = nums[slow];<br>            fast = nums[fast];<br>        }<br>        # 再次相遇 就是环入口<br>        <span class="hljs-keyword"><code class="language-hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findDuplicate</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> {<br>        <span class="hljs-type">int</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, fast = <span class="hljs-number">0</span>;<br>      	# 找环的入口<br>        <span class="hljs-keyword">do</span> {<br>            slow = nums[slow];<br>            fast = nums[nums[fast]];<br>        } <span class="hljs-keyword">while</span> (slow != fast);<br>        # 重置slow为起点<br>        slow = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (slow != fast) {<br>            slow = nums[slow];<br>            fast = nums[fast];<br>        }<br>        # 再次相遇 就是环入口<br>        <span class="hljs-keyword">return</span> slow;<br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>复杂度分析</p>
<p>时间复杂度：<code>O(n)</code>。「Floyd 判圈算法」时间复杂度为线性的时间复杂度。<br>空间复杂度：<code>O(1)</code>。我们只需要常数空间存放若干变量。</p>
</body></html>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/leetcode/">leetcode</a><a href="/tags/算法/">算法</a><a href="/tags/二分法/">二分法</a><a href="/tags/快慢指针/">快慢指针</a>
    </span>
    

    </div>

    
  </div>
</article>

  









</div>


    </main>

    <footer class="site-footer">
  <p class="mp">
    <img alt="关注我" src="/mp.png" style="border-radius: 10px;" no-lazy>
  </p>
  <p class="site-info">
    湘ICP备2020021380号-1 
    </br>
    
    &copy; 2014 - 2023 SIWEN.PENG
    
  </p>
</footer>
    
    
<script>
    var _hmt = _hmt || [];
    ( function () {
        var hm = document.createElement( "script" );
        hm.src = "//hm.baidu.com/hm.js?83fbb968d837cac86cb15c97ddd8cdd4";
        var s = document.getElementsByTagName( "script" )[ 0 ];
        s.parentNode.insertBefore( hm, s );
    } )();
</script>

  </div>
</div>

        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script></body>
</html>