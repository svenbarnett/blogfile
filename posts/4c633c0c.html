<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  
  <title>从Apollo动态配置原理学Spring(二) | 人间日常 | 所行皆过往，所愿皆成真</title>

  
  <meta name="author" content="SIWEN.PENG">
  

  
  <meta name="description" content="通过Apollo动态原理学习下Spring生命周期">
  

  
  <meta name="keywords" content="Spring生命周期,psw,彭思文,siwen,思文,sven,java,study,solution,blog">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1,user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="从Apollo动态配置原理学Spring(二)"/>

  <meta property="og:site_name" content="人间日常"/>

  
  <meta property="og:image" content="/avatar.jpg"/>
  

  <link href="/avatar.jpg" rel="icon">
  <link rel="alternate" href="/atom.xml" title="人间日常" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/custom.css" media="screen" type="text/css">
  
  
  

  <script src="//sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
<meta name="generator" content="Hexo 6.3.0"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>

<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">人间日常</a>
    </h1>
    <p class="site-description">所行皆过往，所愿皆成真</p>
    <span class="site-description" id="jinrishici-sentence">正在加载今日诗词....</span>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives/">归档</a></li>
      
        <li><a href="/pics/">图记</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <div id="container">
<article>

  
    
    <h3 class="article-title"><span>从Apollo动态配置原理学Spring(二)</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/posts/4c633c0c.html" rel="bookmark">
        <time class="entry-date published" datetime="2023-02-26T12:39:24.000Z">
          2023-02-26
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="article-cover">
      
    </div>
    <div class="entry">
      
        <html><head></head><body><blockquote>
<p>Apollo动态配置其实本质就是利用Spring Bean 的生命周期的扩展点，这个扩展点超级多，不可能全部列出来，只说核心的扩展点。这也就是为什么 Spring 的扩展性很好的原因，开了很多的口子，尽可能让某个功能高内聚松耦合，用户需要哪个功能就用哪个，而不是直接来一个大而全的东西。</p>
</blockquote>
<p>我们先通过学习核心的，然后后续对照Apollo用到了哪些再对照，就会发现很多地方就能理解的很好了</p>
<span id="more"></span>
<p><strong>什么是 Spring Bean 的生命周期</strong></p>
<p>对于普通的 Java 对象，当 new 的时候创建对象，然后该对象就能够使用了。一旦该对象不再被使用，则由 Java 自动进行垃圾回收。</p>
<p>而 Spring 中的对象是 bean，bean 和普通的 Java 对象没啥大的区别，只不过 Spring 不再自己去 new 对象了，而是由 IoC 容器去帮助我们实例化对象并且管理它，我们需要哪个对象，去问 IoC 容器要即可。IoC 其实就是解决对象之间的耦合问题，Spring Bean 的生命周期完全由容器控制。</p>
<h2 id="Spring-Bean-的生命周期"><a href="#Spring-Bean-的生命周期" class="headerlink" title="Spring Bean 的生命周期"></a>Spring Bean 的生命周期</h2><p>这里要提一下，这里我们说的 Spring Bean 的生命周期主要指的是 singleton bean，对于 prototype 的 bean ，Spring 在创建好交给使用者之后则不会再管理后续的生命周期。</p>
<p>我们也来复习下 Spring 中的 bean 的作用域有哪些?</p>
<ul>
<li><code>singleton</code> : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。</li>
<li><code>prototype</code> : 每次请求都会创建一个新的 bean 实例。</li>
<li><code>request</code> : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。</li>
<li><code>session</code> : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。</li>
<li><code>global-session</code>： 全局 session 作用域，仅仅在基于 Portlet 的 web 应用中才有意义，Spring5 已经没有了。Portlet 是能够生成语义代码（例如：HTML）片段的小型 Java Web 插件。它们基于 portlet 容器，可以像 servlet 一样处理 HTTP 请求。但是，与 servlet 不同，每个 portlet 都有不同的会话。</li>
</ul>
<p>我们知道对于普通的 Java 对象来说，它们的生命周期就是：</p>
<ul>
<li>实例化</li>
<li>该对象不再被使用时通过垃圾回收机制进行回收</li>
</ul>
<p>而对于 Spring Bean 的生命周期来说：</p>
<ul>
<li>实例化 Instantiation</li>
<li>属性赋值 Populate</li>
<li>初始化 Initialization</li>
<li>销毁 Destruction</li>
</ul>
<p>实例化 -&gt; 属性赋值 -&gt; 初始化 -&gt; 销毁</p>
<p>只有四个步骤，这样拆解的话是不是感觉也不难？不像其他人写的那样直接一上来就各种 BeanPostProcessor、BeanFactoryPostProcessor 全部怼进流程里去，别说读者看着头大，自己写的可能短时间内还记得流程，隔个一段时间，你可能都不知道自己写了个啥。</p>
<p>通过 Bean 创建流程入口<code>AbstractApplicationContext#refresh()</code> 方法的 <code>finishBeanFactoryInitialization(beanFactory)</code> 处带大家跟一下源码，想了想还是不带入过多的代码进来，直接给到最终的主要逻辑。</p>
<pre class=" language-lang-java"><code class="language-lang-java">protected Object doCreateBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException {
    BeanWrapper instanceWrapper = null;
    if (mbd.isSingleton()) {
        instanceWrapper = (BeanWrapper)this.factoryBeanInstanceCache.remove(beanName);
    }
    if (instanceWrapper == null) {
        // 实例化阶段
        instanceWrapper = this.createBeanInstance(beanName, mbd, args);
    }
    ...
    Object exposedObject = bean;

    try {
        // 属性赋值阶段
        this.populateBean(beanName, mbd, instanceWrapper);
        // 初始化阶段
        exposedObject = this.initializeBean(beanName, exposedObject, mbd);
    } catch (Throwable var18) {
        ...
    }
    ...
}
</code></pre>
<p>至于销毁，是在容器关闭时调用的，详见 <code>ConfigurableApplicationContext#close()</code></p>
<p>是不是很清爽了？至于 BeanPostProcessor、BeanFactoryPostProcessor 以及其他的类，只不过是对主流程四个步骤的一系列扩展点而已。</p>
<h2 id="Spring-Bean-的生命周期的扩展点"><a href="#Spring-Bean-的生命周期的扩展点" class="headerlink" title="Spring Bean 的生命周期的扩展点"></a>Spring Bean 的生命周期的扩展点</h2><p>Spring Bean 的生命周期的扩展点超级多，老周这里不可能全部列出来，只说核心的扩展点。这也就是为什么 Spring 的扩展性很好的原因，开了很多的口子，尽可能让某个功能高内聚松耦合，用户需要哪个功能就用哪个，而不是直接来一个大而全的东西。</p>
<p><strong>Bean 自身的方法</strong></p>
<p>比如构造函数、getter/setter 以及 init-method 和 destory-method 所指定的方法等，也就对应着上文说的实例化 -&gt; 属性赋值 -&gt; 初始化 -&gt; 销毁四个阶段。</p>
<p><img src="/images/loading.svg" data-original="/posts/4c633c0c/20210707002134280.png" alt="阶段示意图"></p>
<p><strong>容器级的方法（BeanPostProcessor 一系列接口）</strong></p>
<p>主要是后处理器方法，比如下图的 <code>InstantiationAwareBeanPostProcessor</code>、<code>BeanPostProcessor</code> 接口方法。这些接口的实现类是独立于 Bean 的，并且会注册到 Spring 容器中。在 Spring 容器创建任何 Bean 的时候，这些后处理器都会发生作用。</p>
<p><img src="/images/loading.svg" data-original="/posts/4c633c0c/20210707225212729.png" alt="扩展点"></p>
<p> <strong>InstantiationAwareBeanPostProcessor 源码分析</strong></p>
<p>我们翻一下源码发现 InstantiationAwareBeanPostProcessor 是继承了 BeanPostProcessor</p>
<p><img src="/images/loading.svg" data-original="/posts/4c633c0c/20210707230505579.png" alt="InstantiationAwareBeanPostProcessor "></p>
<p><img src="/images/loading.svg" data-original="/posts/4c633c0c/20210707230919307.png" alt="BeanPostProcessor"></p>
<ul>
<li><code>InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation</code> 调用点</li>
</ul>
<blockquote>
<p>Object postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName)<br>返回值：如果返回的不为null，那么后续的Bean的创建流程【实例化、初始化afterProperties】都不会执行，而是直接使用返回的快捷Bean，此时的正常执行顺序如下：<br>InstantiationAwareBeanPostProcessor接口中的postProcessBeforeInstantiation，在实例化之前调用。<br>BeanPostProcessor接口中的postProcessAfterInitialization，在实例化之后调用。</p>
</blockquote>
<p><img src="/images/loading.svg" data-original="https://img-blog.csdnimg.cn/20210707233026943.png" alt="createbean"></p>
<p><img src="/images/loading.svg" data-original="/posts/4c633c0c/20210707235533784.png" alt="resolveBeforeInstantiation"></p>
<p><img src="/images/loading.svg" data-original="/posts/4c633c0c/20210708000228655.png" alt="applyBean"></p>
<p>总之，postProcessBeforeInstantiation 在 doCreateBean 之前调用，也就是在 bean 实例化之前调用的，英文源码注释解释道该方法的返回值会替换原本的 Bean 作为代理，这也是 <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=AOP&amp;spm=1001.2101.3001.7020">AOP</a> 等功能实现的关键点。</p>
<ul>
<li><code>InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation</code> 调用点</li>
</ul>
<blockquote>
<p>boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException<br>正常情况下在实例化之后在执行populateBean之前调用<br>返回值：如果有指定的bean的时候返回false，那么后续的属性填充和属性依赖注入【populateBean】将不会执行，同时后续的postProcessPropertyValues将不会执行,但是初始化和BeanPostProcessor的仍然会执行。</p>
</blockquote>
<p><img src="/images/loading.svg" data-original="/posts/4c633c0c/20210708005050274.png" alt="populateBean"></p>
<p>public PropertyValues postProcessPropertyValues(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)<br>实例化之后调用，在方法applyPropertyValues【属性填充】之前<br>返回值：如果返回null，那么将不会进行后续的属性填充，比如依赖注入等，如果返回的pvs额外的添加了属性，那么后续会填充到该类对应的属性中。<br>pvs：PropertyValues对象，用于封装指定类的对象，简单来说就是PropertyValue的集合，里面相当于以key-value形式存放类的属性和值。<br>pds：PropertyDescriptor对象数组，PropertyDescriptor相当于存储类的属性，不过可以调用set，get方法设置和获取对应属性的值。</p>
<p><img src="/images/loading.svg" data-original="/posts/4c633c0c/20210708010057366.png" alt="postProcessPropertyValues"></p>
<p><strong>BeanPostProcessor 源码分析</strong></p>
<blockquote>
<p>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#doCreateBean</p>
</blockquote>
<p><img src="/images/loading.svg" data-original="/posts/4c633c0c/20210708232740951.png" alt="在这里插入图片描述"><br>进入初始化接口：</p>
<p><img src="/images/loading.svg" data-original="/posts/4c633c0c/20210708233139731.png" alt="在这里插入图片描述"><br>我们先来看</p>
<blockquote>
<p>org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#applyBeanPostProcessorsBeforeInitialization</p>
</blockquote>
<p><img src="/images/loading.svg" data-original="/posts/4c633c0c/20210708233742525.png" alt="在这里插入图片描述"></p>
<ul>
<li>首先获取到所有的后置处理器 getBeanPostProcessors()</li>
<li>在 for 循环中依次调用后置处理器的方法 <code>processor.postProcessBeforeInitialization(result, beanName);</code></li>
<li>进入 postProcessBeforeInitialization 方法</li>
</ul>
<blockquote>
<p>org.springframework.context.support.ApplicationContextAwareProcessor#postProcessBeforeInitialization</p>
</blockquote>
<p><img src="/images/loading.svg" data-original="/posts/4c633c0c/20210708234443215.png" alt="在这里插入图片描述"></p>
<p>进入 <code>invokeAwareInterfaces(bean);</code> 方法，当前 bean 实现了 ApplicationContextAware 接口。</p>
<p><img src="/images/loading.svg" data-original="/posts/4c633c0c/20210708234639952.png" alt="在这里插入图片描述"></p>
<ul>
<li><code>ApplicationContextAwareProcessor#postProcessBeforeInitialization</code> 首先判断此 bean 是不是各种的Aware，如果是它列举的那几个 Aware 就获取 Bean 工厂的权限，可以向容器中导入相关的上下文环境，目的是为了 Bean 实例能够获取到相关的上下文，如果不是它列举的几个 Aware，那就调用 <code>invokeAwareInterfaces(bean)</code>，向容器中添加相关接口的上下文环境。</li>
</ul>
<p><strong>3.3 工厂后处理器方法（BeanFactoryProcessor 一系列接口）</strong></p>
<p>包括 <code>AspectJWeavingEnabler</code>、<code>CustomAutowireConfigurer</code>、<code>ConfigurationClassPostProcessor</code> 等。这些都是 Spring 框架中已经实现好的 BeanFactoryPostProcessor，用来实现某些特定的功能。</p>
<p>我们知道 Spring IoC 容器初始化的关键环节就在 <code>org.springframework.context.support.AbstractApplicationContext#refresh</code> 方法中 ，容器创建的主体流程都在这个方法里面，这个方法是真的重要！！！</p>
<p>对于工厂后处理器方法老周这里直接带你看 <code>invokeBeanFactoryPostProcessors(beanFactory);</code> 方法，这个方法处理的是 <code>BeanFactoryPostProcessor</code> 接口的 Bean。调用方法如下：</p>
<p><img src="/images/loading.svg" data-original="/posts/4c633c0c/20210709231013239.png" alt="在这里插入图片描述"><br>跟到最重要的方法里去，代码虽长，但逻辑中规中矩。</p>
<p><code>BeanFactoryPostProcessor</code>：一切处理 BeanFactory 的父接口<br><code>BeanDefinitionRegistryPostProcessor</code>：实现了 BeanFactoryPostProcessor 接口的接口</p>
<p><img src="/images/loading.svg" data-original="/posts/4c633c0c/20210709233225102.png" alt="在这里插入图片描述"><br>流程说明：</p>
<ul>
<li>调用 BeanDefinitionRegistryPostProcessor#postProcessBeanDefinitionRegistry(registry) 方法。参数 beanFactoryPostProcessors 传入的优先处理掉。然后获取容器注册的，对于这些 Bean 按照 PriorityOrdered 接口、Ordered、没有排序接口的实例分别进行处理。</li>
<li>调用 BeanFactoryPostProcessor#postProcessBeanFactory(beanFactory) 方法。备注：BeanDefinitionRegistryPostProcessor 属于 BeanFactoryPostProcessor 子接口。先处理属于 BeanDefinitionRegistryPostProcessor 接口实例的 postProcessBeanFactory(beanFactory) 方法，然后获取容器注册的。对于这些 Bean 按照 PriorityOrdered 接口、Ordered、没有排序接口的实例分别进行处理。</li>
</ul>
</body></html>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/Java/">Java</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Apollo/">Apollo</a><a href="/tags/Spring/">Spring</a>
    </span>
    

    </div>

    
  </div>
</article>

  









</div>


    </main>

    <footer class="site-footer">
  <p class="mp">
    <img alt="关注我" src="/mp.png" style="border-radius: 10px;" no-lazy>
  </p>
  <p class="site-info">
    湘ICP备2020021380号-1 
    </br>
    
    &copy; 2014 - 2024 SIWEN.PENG
    
  </p>
</footer>
    
    
<script>
    var _hmt = _hmt || [];
    ( function () {
        var hm = document.createElement( "script" );
        hm.src = "//hm.baidu.com/hm.js?83fbb968d837cac86cb15c97ddd8cdd4";
        var s = document.getElementsByTagName( "script" )[ 0 ];
        s.parentNode.insertBefore( hm, s );
    } )();
</script>

  </div>
</div>

        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script></body>
</html>