<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  
  <title>《c++之路》--左值引用、右值引用 | 人间日常 | 所行皆过往，所愿皆成真</title>

  
  <meta name="author" content="SIWEN.PENG">
  

  
  <meta name="description" content="所行皆过往，所愿皆成真">
  

  
  <meta name="keywords" content="左值引用,右值引用,psw,彭思文,siwen,思文,sven,java,study,solution,blog">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1,user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="《c++之路》--左值引用、右值引用"/>

  <meta property="og:site_name" content="人间日常"/>

  
  <meta property="og:image" content="/avatar.jpg"/>
  

  <link href="/avatar.jpg" rel="icon">
  <link rel="alternate" href="/atom.xml" title="人间日常" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/custom.css" media="screen" type="text/css">
  
  
  

  <script src="//sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
<meta name="generator" content="Hexo 6.3.0"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>

<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">人间日常</a>
    </h1>
    <p class="site-description">所行皆过往，所愿皆成真</p>
    <span class="site-description" id="jinrishici-sentence">正在加载今日诗词....</span>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives/index.html">归档</a></li>
      
        <li><a href="/pics/index.html">图记</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <div id="container">
<article>

  
    
    <h3 class="article-title"><span>《c++之路》--左值引用、右值引用</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/posts/8dbe.html" rel="bookmark">
        <time class="entry-date published" datetime="2023-08-12T14:25:01.000Z">
          2023-08-12
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="article-cover">
      
    </div>
    <div class="entry">
      
        <html><head></head><body><p><strong>主要内容</strong></p>
<ul>
<li>什么是左值引用、右值引用</li>
<li>左右值引用如何切换</li>
<li>什么时候需要进行左右值转换</li>
</ul>
<span id="more"></span>
<h3 id="什么是左值引用、右值引用"><a href="#什么是左值引用、右值引用" class="headerlink" title="什么是左值引用、右值引用"></a>什么是左值引用、右值引用</h3><p>在C++11中可以取地址的、有名字的就是左值，反之，不能取地址的、没有名字的就是右值（将亡值或纯右值）。</p>
<p>举个例子，<code>int a = b+c</code>,<code>a</code> 就是左值，其有变量名为<code>a</code>，通过<code>&amp;a</code>可以获取该变量的地址；表达式<code>b+c</code>、函数<code>int func()</code>的返回值是右值，在其被赋值给某一变量前，我们不能通过变量名找到它，<code>＆(b+c)</code>这样的操作则不会通过编译。</p>
<p>左值一定在内存中，右值有可能在内存中也有可能在寄存器中</p>
<figure class="highlight routeros"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs routeros">int <span class="hljs-attribute">a</span>=10；<br>int <span class="hljs-attribute">b</span>=a;//此时a在内存中<br>int <span class="hljs-attribute">a</span>=5；<br>int <span class="hljs-attribute">b</span>=a+1;//此时a+1在寄存器中<br>int *<span class="hljs-attribute"><code class="language-hljs routeros">int <span class="hljs-attribute">a</span>=10；<br>int <span class="hljs-attribute">b</span>=a;//此时a在内存中<br>int <span class="hljs-attribute">a</span>=5；<br>int <span class="hljs-attribute">b</span>=a+1;//此时a+1在寄存器中<br>int *<span class="hljs-attribute">p</span>=&a;//此时&a在寄存器中<br></code></pre></td></tr></tbody></table></figure>
<p>引用：就是取别名 ，引用不可以重定义</p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre class=" language-hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span>()</span><br>{<br>    <span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">num1</span>(<span class="hljs-params"><span class="hljs-number">5</span></span>)</span>;<br>    <span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">num2</span>(<span class="hljs-params"><span class="hljs-number">10</span></span>)</span>;<br>    <span class="hljs-built_in">int</span> *pnum(&amp;num1);<span class="hljs-comment">//将num1的地址传递给pnum</span><br>    <span class="hljs-built_in">int</span> * &amp;rnum = pnum;<span class="hljs-comment">//rnum是pnum的别名</span><br>    rnum = &amp;num2;<span class="hljs-comment">//rnumhe pnum指向同一片内存  改变了rnum就相当于改变了pnum</span><br>    cout &lt;&lt; *pnum &lt;&lt; endl;<br>    system(<span class="hljs-string">"pause"</span>);<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span>()</span><br>{<br>    <span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">num1</span>(<span class="hljs-params"><span class="hljs-number">5</span></span>)</span>;<br>    <span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">num2</span>(<span class="hljs-params"><span class="hljs-number">10</span></span>)</span>;<br>    <span class="hljs-built_in">int</span> * &amp;rnum = &amp;num1;<span class="hljs-comment">//这是不允许的  无法从“int *”转换为“int *&amp;”</span><br>    system(<span class="hljs-string"><code class="language-hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span>()</span><br>{<br>    <span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">num1</span>(<span class="hljs-params"><span class="hljs-number">5</span></span>)</span>;<br>    <span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">num2</span>(<span class="hljs-params"><span class="hljs-number">10</span></span>)</span>;<br>    <span class="hljs-built_in">int</span> *pnum(&amp;num1);<span class="hljs-comment">//将num1的地址传递给pnum</span><br>    <span class="hljs-built_in">int</span> * &amp;rnum = pnum;<span class="hljs-comment">//rnum是pnum的别名</span><br>    rnum = &amp;num2;<span class="hljs-comment">//rnumhe pnum指向同一片内存  改变了rnum就相当于改变了pnum</span><br>    cout &lt;&lt; *pnum &lt;&lt; endl;<br>    system(<span class="hljs-string">"pause"</span>);<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span>()</span><br>{<br>    <span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">num1</span>(<span class="hljs-params"><span class="hljs-number">5</span></span>)</span>;<br>    <span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">num2</span>(<span class="hljs-params"><span class="hljs-number">10</span></span>)</span>;<br>    <span class="hljs-built_in">int</span> * &amp;rnum = &amp;num1;<span class="hljs-comment">//这是不允许的  无法从“int *”转换为“int *&amp;”</span><br>    system(<span class="hljs-string">"pause"</span>);<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>简而言之：左值 [可以取地址的对象就是左值]， 右值[不可以取地址的对象就是右值]</p>
<h3 id="左右值引用"><a href="#左右值引用" class="headerlink" title="左右值引用"></a>左右值引用</h3><p>传统的 C++ 语法中就存在引用语法，而 C++11标准中新增了右值引用的语法特性，因此为了区分两者，将C++11标准出现之前的引用称为左值引用。</p>
<p>无论左值引用还是右值引用，都是给对象取别名。</p>
<p><strong>左值引用【避免对象拷贝】</strong><br>左值引用就是对左值的引用，给左值取别名。主要作用是避免对象拷贝。</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs angelscript"><span class="hljs-comment">// 以下几个是对上面左值的左值引用</span><br><span class="hljs-built_in">int</span>&amp; ra = a;<br><span class="hljs-built_in">int</span>*&amp; rp = p;<br><span class="hljs-built_in">int</span>&amp; r = *p;<br><span class="hljs-keyword">const</span> <span class="hljs-built_in"><code class="language-hljs angelscript"><span class="hljs-comment">// 以下几个是对上面左值的左值引用</span><br><span class="hljs-built_in">int</span>&amp; ra = a;<br><span class="hljs-built_in">int</span>*&amp; rp = p;<br><span class="hljs-built_in">int</span>&amp; r = *p;<br><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span>& rb = b;<br></code></pre></td></tr></tbody></table></figure>
<p><strong>右值引用【延长对象生命周期】</strong><br>右值引用就是对右值的引用，给右值取别名。主要作用是把延长对象的生命周期，一般是延长到作用域的scope之外。</p>
<p>右值引用的表示是在具体的变量类型名称后加两个<code>&amp;</code>，比如：<code>int&amp;&amp; rr = 4</code>;</p>
<figure class="highlight 1c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs 1c"><span class="hljs-comment">// 以下几个是对上面右值的右值引用</span><br>int<span class="hljs-meta">&amp;&amp; rr1 = 10;</span><br>double<span class="hljs-meta">&amp;&amp; rr2 = x + y;</span><br>double<span class="hljs-meta"><code class="language-hljs 1c"><span class="hljs-comment">// 以下几个是对上面右值的右值引用</span><br>int<span class="hljs-meta">&amp;&amp; rr1 = 10;</span><br>double<span class="hljs-meta">&amp;&amp; rr2 = x + y;</span><br>double<span class="hljs-meta">&& rr3 = fmin(x, y);</span><br></code></pre></td></tr></tbody></table></figure>
<h3 id="左右值引用如何切换"><a href="#左右值引用如何切换" class="headerlink" title="左右值引用如何切换"></a>左右值引用如何切换</h3><p>现在我们知道左值引用可以引用左值，右值引用可以引用右值。</p>
<p>那么左值引用是否可以引用右值？右值引用是否可以引用左值呢？</p>
<p>左值引用可以指向右值，但需要<code>const</code>来修饰，不能修改这个值</p>
<p>右值引用可以指向左值，需要<code>std::move(v)</code>即可</p>
<p>声明出来的左值引用或右值引用都是左值</p>
<p><strong>左值引用总结</strong></p>
<p>左值引用只能引用左值，不能直接引用右值。但是const左值引用既可以引用左值，也可以引用右值。</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre class=" language-hljs angelscript"><span class="hljs-comment">// 1.左值引用只能引用左值</span><br><span class="hljs-built_in">int</span> t = <span class="hljs-number">8</span>;<br><span class="hljs-built_in">int</span>&amp; rt1 = t;<br><span class="hljs-comment">//int&amp; rt2 = 8; // 编译报错，因为8是右值，不能直接引用右值</span><br><br><span class="hljs-comment">// 2.但是const左值引用既可以引用左值</span><br><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span>&amp; rt3 = t;<br><br><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span>&amp; rt4 = <span class="hljs-number">8</span>; <span class="hljs-comment">// 也可以引用右值 const int&amp; rt4本质上也是一个常量，指向一个不能被修改的右值，也是安全的</span><br><span class="hljs-keyword">const</span> <span class="hljs-built_in">double</span>&amp; r1 = x + y;<br><span class="hljs-keyword">const</span> <span class="hljs-built_in"><code class="language-hljs angelscript"><span class="hljs-comment">// 1.左值引用只能引用左值</span><br><span class="hljs-built_in">int</span> t = <span class="hljs-number">8</span>;<br><span class="hljs-built_in">int</span>&amp; rt1 = t;<br><span class="hljs-comment">//int&amp; rt2 = 8; // 编译报错，因为8是右值，不能直接引用右值</span><br><br><span class="hljs-comment">// 2.但是const左值引用既可以引用左值</span><br><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span>&amp; rt3 = t;<br><br><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span>&amp; rt4 = <span class="hljs-number">8</span>; <span class="hljs-comment">// 也可以引用右值 const int&amp; rt4本质上也是一个常量，指向一个不能被修改的右值，也是安全的</span><br><span class="hljs-keyword">const</span> <span class="hljs-built_in">double</span>&amp; r1 = x + y;<br><span class="hljs-keyword">const</span> <span class="hljs-built_in">double</span>& r2 = fmin(x, y);<br></code></pre></td></tr></tbody></table></figure>
<blockquote>
<p>问：为什么const左值引用也可以引用右值？<br>答：在 C++11标准产生之前，是没有右值引用这个概念的，当时如果想要一个类型既能接收左值也能接收右值的话，需要用const左值引用，比如标准容器的 push_back 接口：void push_back (const T&amp; val)。<br>也就是说，如果const左值引用不能引用右值的话，有些接口就不好支持了。<br>另外，const左值引用，本意上是指向一个不被（该引用本身）它修改的内存区域，本质上这个引用变量本身也就是一个常量，至于这个内存区域对应一个全局变量、局部变量、xvalue，无所谓啊</p>
</blockquote>
<p><strong>右值引用总结</strong></p>
<p>右值引用只能引用右值，不能直接引用左值。但是右值引用可以引用被move的左值。</p>
<p>move，本文指std::move（C++11），作用是将一个左值强制转化为右值，以实现移动语义。左值被 move 后变为右值，于是右值引用可以引用。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre class=" language-hljs cpp"><span class="hljs-comment">// 1.右值引用只能引用右值</span><br><span class="hljs-type">int</span>&amp;&amp; rr1 = <span class="hljs-number">10</span>;<br><span class="hljs-type">double</span>&amp;&amp; rr2 = x + y;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span>&amp;&amp; rr3 = x + y;<br><br><span class="hljs-type">int</span> t = <span class="hljs-number">10</span>;<br><span class="hljs-comment">//int&amp;&amp; rrt = t; // 编译报错，不能直接引用左值</span><br><br><br><span class="hljs-comment">// 2.但是右值引用可以引用被move的左值</span><br><span class="hljs-type">int</span>&amp;&amp; rrt = std::<span class="hljs-built_in">move</span>(t);<br><span class="hljs-type">int</span>*&amp;&amp; rr4 = std::<span class="hljs-built_in">move</span>(p);<br><span class="hljs-type">int</span>&amp;&amp; rr5 = std::<span class="hljs-built_in">move</span>(*p);<br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp;&amp; rr6 = std::<span class="hljs-built_in"><code class="language-hljs cpp"><span class="hljs-comment">// 1.右值引用只能引用右值</span><br><span class="hljs-type">int</span>&amp;&amp; rr1 = <span class="hljs-number">10</span>;<br><span class="hljs-type">double</span>&amp;&amp; rr2 = x + y;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span>&amp;&amp; rr3 = x + y;<br><br><span class="hljs-type">int</span> t = <span class="hljs-number">10</span>;<br><span class="hljs-comment">//int&amp;&amp; rrt = t; // 编译报错，不能直接引用左值</span><br><br><br><span class="hljs-comment">// 2.但是右值引用可以引用被move的左值</span><br><span class="hljs-type">int</span>&amp;&amp; rrt = std::<span class="hljs-built_in">move</span>(t);<br><span class="hljs-type">int</span>*&amp;&amp; rr4 = std::<span class="hljs-built_in">move</span>(p);<br><span class="hljs-type">int</span>&amp;&amp; rr5 = std::<span class="hljs-built_in">move</span>(*p);<br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp;&amp; rr6 = std::<span class="hljs-built_in">move</span>(b);<br></code></pre></td></tr></tbody></table></figure>
<h3 id="什么时候需要进行左右值转换"><a href="#什么时候需要进行左右值转换" class="headerlink" title="什么时候需要进行左右值转换"></a>什么时候需要进行左右值转换</h3><h4 id="左值引用场景【主要是避免对象拷贝】"><a href="#左值引用场景【主要是避免对象拷贝】" class="headerlink" title="左值引用场景【主要是避免对象拷贝】"></a>左值引用场景【主要是避免对象拷贝】</h4><ul>
<li>左值引用做参数</li>
</ul>
<p>当引用作为参数的时候，其效果跟利用指针作为参数的效果相当。当调用函数时，函数中的形参就会被当成实参变量或者对象的一个别名使用，也就是说函数中对形参的各种操作实际上就是对实参本身的操作，而非简单的实参变量或者对象的值拷贝给形参</p>
<figure class="highlight nim"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre class=" language-hljs nim"><span class="hljs-type">void</span> func1(<span class="hljs-type">string</span> s)<br><span class="hljs-meta">{...}</span><br><br><span class="hljs-type">void</span> func2(<span class="hljs-keyword">const</span> <span class="hljs-type">string</span>&amp; s)<br><span class="hljs-meta">{...}</span><br><br><span class="hljs-type">int</span> main()<br>{<br>    <span class="hljs-type">string</span> s1(<span class="hljs-string">"Hello World!"</span>);<br>    func1(s1);  // 由于是传值传参且做的是深拷贝，代价较大<br>    func2(s1);  // 左值引用做参数减少了拷贝，提高了效率    <br>    //通常函数调用时采用值传递的方式，系统会在内存中开辟空间用来存储形参变量，并将实参变量的值拷贝给形参变量，所以形参变量只是实参变量的副本而已，并且如果函数传递的是类的对象，系统还会调用类中的拷贝构造函数来构造形参对象    <br>    //使用引用作为参数传递时，由于此时形参只是传递函数的实参变量或者对象的别名而非副本，故系统不会耗费时间在内存中开辟空间来存储形参，因此如果参数传递的数据较大，建议使用引用作为函数的形参，提高函数的时间效率，节省内存空间    <br>    //指针作为函数的形参，虽然达到的效果跟使用引用一样，但当调用函数时仍然需要为形参指针分配空间，引用则不需要【引用在底层也会分配指针大小的空间，在汇编底层角度，引用和指针是一样的，不过引用类似于常量指针】。<br>    推荐使用引用而非指针作为函数的传递函数<br>    <span class="hljs-keyword">return</span> <span class="hljs-number"><code class="language-hljs nim"><span class="hljs-type">void</span> func1(<span class="hljs-type">string</span> s)<br><span class="hljs-meta">{...}</span><br><br><span class="hljs-type">void</span> func2(<span class="hljs-keyword">const</span> <span class="hljs-type">string</span>&amp; s)<br><span class="hljs-meta">{...}</span><br><br><span class="hljs-type">int</span> main()<br>{<br>    <span class="hljs-type">string</span> s1(<span class="hljs-string">"Hello World!"</span>);<br>    func1(s1);  // 由于是传值传参且做的是深拷贝，代价较大<br>    func2(s1);  // 左值引用做参数减少了拷贝，提高了效率    <br>    //通常函数调用时采用值传递的方式，系统会在内存中开辟空间用来存储形参变量，并将实参变量的值拷贝给形参变量，所以形参变量只是实参变量的副本而已，并且如果函数传递的是类的对象，系统还会调用类中的拷贝构造函数来构造形参对象    <br>    //使用引用作为参数传递时，由于此时形参只是传递函数的实参变量或者对象的别名而非副本，故系统不会耗费时间在内存中开辟空间来存储形参，因此如果参数传递的数据较大，建议使用引用作为函数的形参，提高函数的时间效率，节省内存空间    <br>    //指针作为函数的形参，虽然达到的效果跟使用引用一样，但当调用函数时仍然需要为形参指针分配空间，引用则不需要【引用在底层也会分配指针大小的空间，在汇编底层角度，引用和指针是一样的，不过引用类似于常量指针】。<br>    推荐使用引用而非指针作为函数的传递函数<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>
<ul>
<li>左值引用做返回值（仅限于对象出了函数作用域以后还存在的情况）</li>
</ul>
<figure class="highlight lua"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs lua"><span class="hljs-built_in">string</span> s2(<span class="hljs-string">"hello"</span>);<br>// <span class="hljs-built_in">string</span> operator+=(<span class="hljs-built_in">char</span> ch) 传值返回存在拷贝且是深拷贝<br>// <span class="hljs-built_in">string</span>&amp; operator+=(<span class="hljs-built_in">char</span> ch) 左值引用做返回值没有拷贝，提高了效率<br>s2 += <span class="hljs-string"><code class="language-hljs lua"><span class="hljs-built_in">string</span> s2(<span class="hljs-string">"hello"</span>);<br>// <span class="hljs-built_in">string</span> operator+=(<span class="hljs-built_in">char</span> ch) 传值返回存在拷贝且是深拷贝<br>// <span class="hljs-built_in">string</span>&amp; operator+=(<span class="hljs-built_in">char</span> ch) 左值引用做返回值没有拷贝，提高了效率<br>s2 += <span class="hljs-string">'!'</span>;<br></code></pre></td></tr></tbody></table></figure>
<blockquote>
<p>实际意义（减少拷贝，节省内存，提高效率）<br>传值传参和传值返回都会产生拷贝，有的甚至是深拷贝，代价很大。而左值引用的实际意义在于做参数和做返回值都可以减少拷贝，从而提高效率。</p>
</blockquote>
<h4 id="左值引用不能处理的场景【不能引用局部变量问题】"><a href="#左值引用不能处理的场景【不能引用局部变量问题】" class="headerlink" title="左值引用不能处理的场景【不能引用局部变量问题】"></a>左值引用不能处理的场景【不能引用局部变量问题】</h4><p>左值引用虽然较完美地解决了大部分问题，但对于有些问题仍然不能很好地解决。</p>
<ul>
<li>全局变量<br>当对象（全局变量）出了函数作用域以后仍然存在时，可以使用左值引用返回，这是没问题的。</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre class=" language-hljs csharp"><span class="hljs-built_in">string</span>&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-built_in">char</span> ch)<br>{<br>　　push_back(ch);<br>　　<span class="hljs-keyword">return</span> *<span class="hljs-keyword"><code class="language-hljs csharp"><span class="hljs-built_in">string</span>&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-built_in">char</span> ch)<br>{<br>　　push_back(ch);<br>　　<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>
<ul>
<li>局部变量<br>但当对象（对象是函数内的局部对象）出了函数作用域以后不存在时，就不可以使用左值引用返回了。</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre class=" language-hljs csharp"><span class="hljs-built_in">string</span> <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; s, <span class="hljs-built_in">char</span> ch)<br>{<br><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">ret</span>(<span class="hljs-params">s</span>)</span>;<br>ret.push_back(ch);<br><span class="hljs-keyword">return</span> ret;<br>}<br><br><span class="hljs-comment">// 拿现在这个函数来举例：ret是函数内的局部对象，出了函数作用域后会被析构，即被销毁了</span><br><span class="hljs-comment">// 若此时再返回它的别名（左值引用），也就是再拿这个对象来用，就会出问题</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">①：不能返回局部变量的引用。局部变量会在函数返回后被销毁，此时对 局部变量的引用就会成为“无所指”的引用，程序会进入未知状态。</span><br><span class="hljs-comment">②：不能返回函数内部通过 new 分配的内存的引用。虽然不存在局部变量的被动销毁问题，但如果被返回的函数的引用只是作为一个临时变量出现，而没有将其赋值给一个实际的变量，    那么就可能造成这个引用所指向的空间（有 new 分配）无法释放的情况（由于没有具体的变量名，故无法用 delete 手动释放该内存），从而造成内存泄漏。</span><br><span class="hljs-comment"><code class="language-hljs csharp"><span class="hljs-built_in">string</span> <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp; s, <span class="hljs-built_in">char</span> ch)<br>{<br><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">ret</span>(<span class="hljs-params">s</span>)</span>;<br>ret.push_back(ch);<br><span class="hljs-keyword">return</span> ret;<br>}<br><br><span class="hljs-comment">// 拿现在这个函数来举例：ret是函数内的局部对象，出了函数作用域后会被析构，即被销毁了</span><br><span class="hljs-comment">// 若此时再返回它的别名（左值引用），也就是再拿这个对象来用，就会出问题</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">①：不能返回局部变量的引用。局部变量会在函数返回后被销毁，此时对 局部变量的引用就会成为“无所指”的引用，程序会进入未知状态。</span><br><span class="hljs-comment">②：不能返回函数内部通过 new 分配的内存的引用。虽然不存在局部变量的被动销毁问题，但如果被返回的函数的引用只是作为一个临时变量出现，而没有将其赋值给一个实际的变量，    那么就可能造成这个引用所指向的空间（有 new 分配）无法释放的情况（由于没有具体的变量名，故无法用 delete 手动释放该内存），从而造成内存泄漏。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></tbody></table></figure>
<p>对于第二种情形，左值引用也无能为力，只能传值返回。</p>
<h4 id="右值引用解决的场景"><a href="#右值引用解决的场景" class="headerlink" title="右值引用解决的场景"></a>右值引用解决的场景</h4><p>于是，为了解决上述传值返回的拷贝问题，C++11标准就增加了右值引用 和 移动语义。</p>
<p>移动语义（Move semantics）：将一个对象中的资源移动到另一个对象（资源控制权的转移）。</p>
<ul>
<li><p>移动构造：转移参数右值的资源来构造自己。</p>
<figure class="highlight scss"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre class=" language-hljs scss"><span class="hljs-comment">// 这是一个模拟string类的实现的移动构造</span><br><span class="hljs-built_in">string</span>(string&amp;&amp; s)<br>:<span class="hljs-built_in">_str</span>(nullptr)<br>, <span class="hljs-built_in">_size</span>(<span class="hljs-number">0</span>)<br>, <span class="hljs-built_in">_capacity</span>(<span class="hljs-number">0</span>)<br>{<br><span class="hljs-built_in"><code class="language-hljs scss"><span class="hljs-comment">// 这是一个模拟string类的实现的移动构造</span><br><span class="hljs-built_in">string</span>(string&amp;&amp; s)<br>:<span class="hljs-built_in">_str</span>(nullptr)<br>, <span class="hljs-built_in">_size</span>(<span class="hljs-number">0</span>)<br>, <span class="hljs-built_in">_capacity</span>(<span class="hljs-number">0</span>)<br>{<br><span class="hljs-built_in">swap</span>(s);<br>}<br></code></pre></td></tr></tbody></table></figure>
</li>
</ul>
<p>拷贝构造函数和移动构造函数都是构造函数的重载函数，所不同的是：</p>
<p>拷贝构造函数的参数是 const左值引用，接收左值或右值；</p>
<p>移动构造函数的参数是右值引用，接收右值或被 move 的左值。</p>
<p>注：当传来的参数是右值时，虽然拷贝构造函数可以接收，但是编译器会认为移动构造函数更加匹配，就会调用移动构造函数。</p>
<p>总的来说，如果这两个函数都有在类内定义的话，在构造对象时：</p>
<p>若是左值做参数，那么就会调用拷贝构造函数，做一次拷贝（如果是像 string 这样的在堆空间上存在资源的类，那么每调用一次拷贝构造就会做一次深拷贝）。</p>
<p>若是右值做参数，那么就会调用移动构造，而调用移动构造就会减少拷贝（如果是像 string 这样的在堆空间上存在资源的类，那么每调用一次移动构造就会少做一次深拷贝）。</p>
<figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre class=" language-hljs awk">string s(<span class="hljs-string">"Hello World11111111111111111"</span>);   <span class="hljs-regexp">//</span> ①<br>string s1 = s; <span class="hljs-regexp">//</span> s是左值，所以调用拷贝构造函数 <span class="hljs-regexp">//</span> ②<br>string s2 = move(s); <span class="hljs-regexp">//</span> ③ s被move后变为右值，所以调用移动构造函数，s的资源会被转移用来构造s2<br><span class="hljs-regexp"><code class="language-hljs awk">string s(<span class="hljs-string">"Hello World11111111111111111"</span>);   <span class="hljs-regexp">//</span> ①<br>string s1 = s; <span class="hljs-regexp">//</span> s是左值，所以调用拷贝构造函数 <span class="hljs-regexp">//</span> ②<br>string s2 = move(s); <span class="hljs-regexp">//</span> ③ s被move后变为右值，所以调用移动构造函数，s的资源会被转移用来构造s2<br><span class="hljs-regexp">//</span> 要注意的是，move一般是不这样用的，因为s的资源被转走了<br></code></pre></td></tr></tbody></table></figure>
<p>过程分析：<br>1、执行完语句① 还没有执行语句②  此时 s有值 s1无值 s2无值<br>2、执行完语句②，还没有执行语句③  此时 s有值 s1有值 s2无值<br>3、执行完语句③ 此时 s空字符串值 s1有值 s2有值</p>
<p>语句2执行的复制构造  语句3执行的移动构造</p>
<ul>
<li>移动赋值：转移参数右值的资源来赋给自己。</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre class=" language-hljs csharp"><span class="hljs-comment">// 这是一个模拟string类的实现的移动赋值</span><br><span class="hljs-built_in">string</span>&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-built_in">string</span>&amp;&amp; s)<br>{<br>　　swap(s);<br>　　<span class="hljs-keyword">return</span> *<span class="hljs-keyword"><code class="language-hljs csharp"><span class="hljs-comment">// 这是一个模拟string类的实现的移动赋值</span><br><span class="hljs-built_in">string</span>&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-built_in">string</span>&amp;&amp; s)<br>{<br>　　swap(s);<br>　　<span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>}<br></code></pre></td></tr></tbody></table></figure>
<p>拷贝赋值函数和移动赋值函数都是赋值运算符重载函数的重载函数，所不同的是：</p>
<p>拷贝赋值函数的参数是 const左值引用，接收左值或右值；<br>移动赋值函数的参数是右值引用，接收右值或被 move 的左值。<br>注：当传来的参数是右值时，虽然拷贝赋值函数可以接收，但是编译器会认为移动赋值函数更加匹配，就会调用移动赋值函数。</p>
<p>总的来说，如果这两个函数都有在类内定义的话，在进行对象的赋值时：</p>
<p>若是左值做参数，那么就会调用拷贝赋值，做一次拷贝（如果是像 string 这样的在堆空间上存在资源的类，那么每调用一次拷贝赋值就会做一次深拷贝）。<br>若是右值做参数，那么就会调用移动赋值，而调用移动赋值就会减少拷贝（如果是像 string 这样的在堆空间上存在资源的类，那么每调用一次移动赋值就会少做一次深拷贝）。</p>
<figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre class=" language-hljs cpp"><span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">"11111111111111111"</span>)</span></span>;<br><span class="hljs-function">string <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-string">"22222222222222222"</span>)</span></span>;<br>s1 = s; <span class="hljs-comment">// s是左值，所以调用拷贝赋值函数</span><br><br><span class="hljs-function">string <span class="hljs-title">s2</span><span class="hljs-params">(<span class="hljs-string">"333333333333333333"</span>)</span></span>;<br>s2 = std::<span class="hljs-built_in">move</span>(s); <span class="hljs-comment">// s被move后变为右值，所以调用移动赋值函数，s的资源会被转移用来赋给s2</span><br><span class="hljs-comment"><code class="language-hljs cpp"><span class="hljs-function">string <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-string">"11111111111111111"</span>)</span></span>;<br><span class="hljs-function">string <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-string">"22222222222222222"</span>)</span></span>;<br>s1 = s; <span class="hljs-comment">// s是左值，所以调用拷贝赋值函数</span><br><br><span class="hljs-function">string <span class="hljs-title">s2</span><span class="hljs-params">(<span class="hljs-string">"333333333333333333"</span>)</span></span>;<br>s2 = std::<span class="hljs-built_in">move</span>(s); <span class="hljs-comment">// s被move后变为右值，所以调用移动赋值函数，s的资源会被转移用来赋给s2</span><br><span class="hljs-comment">// 要注意的是，move一般是不这样用的，因为s的资源被转走了</span><br></code></pre></td></tr></tbody></table></figure>
<h5 id="右值引用的使用场景"><a href="#右值引用的使用场景" class="headerlink" title="右值引用的使用场景"></a>右值引用的使用场景</h5><ul>
<li><p>返回函数的局部变量<br>即上面的使用场景to_string()返回str局部变量的使用场景，主要是解决函数参数的传递中（针对返回的将亡值，即局部大块数据），解决大块数据或对象的传递效率和空间不如意的问题：</p>
</li>
<li><p>C++11标准的STL 容器接口<br>除了上面的使用场景之外，C++11标准的STL 容器的相关接口函数也增加了右值引用版本。</p>
</li>
</ul>
</body></html>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/左值引用/">左值引用</a><a href="/tags/右值引用/">右值引用</a>
    </span>
    

    </div>

    
  </div>
</article>

  









</div>


    </main>

    <footer class="site-footer">
  <p class="mp">
    <img alt="关注我" src="/mp.png" style="border-radius: 10px;" no-lazy>
  </p>
  <p class="site-info">
    湘ICP备2020021380号-1 
    </br>
    
    &copy; 2014 - 2023 SIWEN.PENG
    
  </p>
</footer>
    
    
<script>
    var _hmt = _hmt || [];
    ( function () {
        var hm = document.createElement( "script" );
        hm.src = "//hm.baidu.com/hm.js?83fbb968d837cac86cb15c97ddd8cdd4";
        var s = document.getElementsByTagName( "script" )[ 0 ];
        s.parentNode.insertBefore( hm, s );
    } )();
</script>

  </div>
</div>

        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script></body>
</html>