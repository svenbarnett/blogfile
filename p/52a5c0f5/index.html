<!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="utf-8"><title>被围绕的区域——LeetCode130 | 人间日常 | 所行皆过往，所愿皆成真</title><meta name="author" content="SIWEN.PENG"><meta name="description" content="给你一个 m x n 的矩阵 board ，由若干字符 &#39;X&#39; 和 &#39;O&#39; ，找到所有被 &#39;X&#39; 围绕的区域，并将这些区域里所有的 &#39;O&#39; 用 &#39;X&#39; 填充。"><meta name="keywords" content="矩阵,栈,深度遍历,广度遍历,psw,彭思文,siwen,思文,sven,java,study,solution,blog"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,minimal-ui"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta property="og:title" content="被围绕的区域——LeetCode130"><meta property="og:site_name" content="人间日常"><meta property="og:image" content="xogrid.jpg"><link href="/avatar.jpg" rel="icon"><link rel="alternate" href="/atom.xml" title="人间日常" type="application/atom+xml"><link rel="stylesheet" href="/css/style.css" media="screen" type="text/css"><link rel="stylesheet" href="/css/custom.css" media="screen" type="text/css"><script src="//sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script><meta name="generator" content="Hexo 6.3.0"></head><body><div class="blog"><div class="content"><header><div class="site-branding"><h1 class="site-title"><a href="/">人间日常</a></h1><p class="site-description">所行皆过往，所愿皆成真</p><span class="site-description" id="jinrishici-sentence">正在加载今日诗词....</span></div><nav class="site-navigation"><ul><li><a href="/">主页</a></li><li><a href="/archives/index.html">归档</a></li><li><a href="/pics/index.html">图记</a></li></ul></nav></header><main class="site-main posts-loop"><div id="container"><article><h3 class="article-title"><span>被围绕的区域——LeetCode130</span></h3><div class="article-top-meta"><span class="posted-on"><a href="/p/52a5c0f5/index.html" rel="bookmark"><time class="entry-date published" datetime="2022-02-08T11:56:55.000Z">2022-02-08</time></a></span></div><div class="article-content"><div class="entry"><html><head></head><body><p>给你一个 <code>m x n</code> 的矩阵 <code>board</code> ，由若干字符 <code>'X'</code> 和 <code>'O'</code> ，找到所有被 <code>'X'</code> 围绕的区域，并将这些区域里所有的 <code>'O'</code> 用 <code>'X'</code> 填充。</p><p><img src="/images/loading.svg" data-original="/p/52a5c0f5/index.htmlxogrid.jpg" alt="img"></p><span id="more"></span><p>示例 1</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="PLAINTEXT"><figure class="iseeu highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [["X","X","X","X"],["X","O","O","X"],["X","X","O","X"],["X","O","X","X"]]</span><br><span class="line">输出：[["X","X","X","X"],["X","X","X","X"],["X","X","X","X"],["X","O","X","X"]]</span><br><span class="line">解释：被围绕的区间不会存在于边界上，换句话说，任何边界上的&nbsp;'O'&nbsp;都不会被填充为&nbsp;'X'。 任何不在边界上，或不与边界上的&nbsp;'O'&nbsp;相连的&nbsp;'O'&nbsp;最终都会被填充为&nbsp;'X'。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。</span><br></pre></td></tr></tbody></table></figure></div><p>示例 2</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="PLAINTEXT"><figure class="iseeu highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [["X"]]</span><br><span class="line">输出：[["X"]]</span><br></pre></td></tr></tbody></table></figure></div><p>提示：</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="PLAINTEXT"><figure class="iseeu highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m == board.length</span><br><span class="line">n == board[i].length</span><br><span class="line">1 &lt;= m, n &lt;= 200</span><br><span class="line">board[i][j] 为 'X' 或 'O'</span><br></pre></td></tr></tbody></table></figure></div><h3 id="解题"><a class="markdownIt-Anchor" href="#解题">#</a> 解题</h3><p>写在前面<br>本题给定的矩阵中有三种元素：</p><ul><li><p>字母 X；</p></li><li><p>被字母 X 包围的字母 O；</p></li><li><p>没有被字母 X 包围的字母 O。</p></li></ul><p>本题要求将所有被字母 X 包围的字母 O 都变为字母 X ，但很难判断哪些 O 是被包围的，哪些 O 不是被包围的。</p><p>注意到题目解释中提到： <code>任何边界上的 O 都不会被填充为 X</code> 。 我们可以想到，所有的不被包围的 O 都直接或间接与边界上的 O 相连。我们可以利用这个性质判断 O 是否在边界上，具体地说：</p><ul><li>对于每一个边界上的 O，我们以它为起点，标记所有与它直接或间接相连的字母 O；<br>最后我们遍历这个矩阵，对于每一个字母：</li><li>如果该字母被标记过，则该字母为没有被字母 X 包围的字母 O，我们将其还原为字母 O；<br>如果该字母没有被标记过，则该字母为被字母 X 包围的字母 O，我们将其修改为字母 X。</li></ul><h3 id="方法一深度优先搜索"><a class="markdownIt-Anchor" href="#方法一深度优先搜索">#</a> 方法一：深度优先搜索</h3><h4 id="思路及解法"><a class="markdownIt-Anchor" href="#思路及解法">#</a> 思路及解法</h4><p>我们可以使用深度优先搜索实现标记操作。在下面的代码中，我们把标记过的字母 O 修改为字母 A。</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">(<span class="type">char</span>[][] board)</span> {</span><br><span class="line">        n = board.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        m = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            dfs(board, i, <span class="number">0</span>);</span><br><span class="line">            dfs(board, i, m - <span class="number">1</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m - <span class="number">1</span>; i++) {</span><br><span class="line">            dfs(board, <span class="number">0</span>, i);</span><br><span class="line">            dfs(board, n - <span class="number">1</span>, i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) {</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">'A'</span>) {</span><br><span class="line">                    board[i][j] = <span class="string">'O'</span>;</span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> (board[i][j] == <span class="string">'O'</span>) {</span><br><span class="line">                    board[i][j] = <span class="string">'X'</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">int</span> x, <span class="type">int</span> y)</span> {</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= n || y &lt; <span class="number">0</span> || y &gt;= m || board[x][y] != <span class="string">'O'</span>) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        board[x][y] = <span class="string">'A'</span>;</span><br><span class="line">        dfs(board, x + <span class="number">1</span>, y);</span><br><span class="line">        dfs(board, x - <span class="number">1</span>, y);</span><br><span class="line">        dfs(board, x, y + <span class="number">1</span>);</span><br><span class="line">        dfs(board, x, y - <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h4 id="复杂度分析"><a class="markdownIt-Anchor" href="#复杂度分析">#</a> 复杂度分析</h4><ul><li><p>时间复杂度： <code>O(n×m)</code> ，其中 <code>n</code> 和 <code>m</code> 分别为矩阵的行数和列数。深度优先搜索过程中，每一个点至多只会被标记一次。</p></li><li><p>空间复杂度： <code>O(n×m)</code> ，其中 <code>n</code> 和 <code>m</code> 分别为矩阵的行数和列数。主要为深度优先搜索的栈的开销。</p></li></ul><h3 id="方法二广度优先搜索"><a class="markdownIt-Anchor" href="#方法二广度优先搜索">#</a> 方法二：广度优先搜索</h3><h4 id="思路及解法-2"><a class="markdownIt-Anchor" href="#思路及解法-2">#</a> 思路及解法</h4><p>我们可以使用广度优先搜索实现标记操作。在下面的代码中，我们把标记过的字母 <code>O</code> 修改为字母 <code>A</code> 。</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">int</span>[] dx = {<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>};</span><br><span class="line">    <span class="type">int</span>[] dy = {<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>};</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">(<span class="type">char</span>[][] board)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> board.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> board[<span class="number">0</span>].length;</span><br><span class="line">        Queue&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;<span class="type">int</span>[]&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="keyword">if</span> (board[i][<span class="number">0</span>] == <span class="string">'O'</span>) {</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]{i, <span class="number">0</span>});</span><br><span class="line">                board[i][<span class="number">0</span>] = <span class="string">'A'</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (board[i][m - <span class="number">1</span>] == <span class="string">'O'</span>) {</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]{i, m - <span class="number">1</span>});</span><br><span class="line">                board[i][m - <span class="number">1</span>] = <span class="string">'A'</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m - <span class="number">1</span>; i++) {</span><br><span class="line">            <span class="keyword">if</span> (board[<span class="number">0</span>][i] == <span class="string">'O'</span>) {</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]{<span class="number">0</span>, i});</span><br><span class="line">                board[<span class="number">0</span>][i] = <span class="string">'A'</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (board[n - <span class="number">1</span>][i] == <span class="string">'O'</span>) {</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]{n - <span class="number">1</span>, i});</span><br><span class="line">                board[n - <span class="number">1</span>][i] = <span class="string">'A'</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) {</span><br><span class="line">            <span class="type">int</span>[] cell = queue.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> cell[<span class="number">0</span>], y = cell[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">mx</span> <span class="operator">=</span> x + dx[i], my = y + dy[i];</span><br><span class="line">                <span class="keyword">if</span> (mx &lt; <span class="number">0</span> || my &lt; <span class="number">0</span> || mx &gt;= n || my &gt;= m || board[mx][my] != <span class="string">'O'</span>) {</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                }</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]{mx, my});</span><br><span class="line">                board[mx][my] = <span class="string">'A'</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) {</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">'A'</span>) {</span><br><span class="line">                    board[i][j] = <span class="string">'O'</span>;</span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> (board[i][j] == <span class="string">'O'</span>) {</span><br><span class="line">                    board[i][j] = <span class="string">'X'</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h4 id="复杂度分析-2"><a class="markdownIt-Anchor" href="#复杂度分析-2">#</a> 复杂度分析</h4><ul><li><p>时间复杂度： <code>O(n×m)</code> ，其中 <code>n</code> 和 <code>m</code> 分别为矩阵的行数和列数。广度优先搜索过程中，每一个点至多只会被标记一次。</p></li><li><p>空间复杂度： <code>O(n×m)</code> ，其中 <code>n</code> 和 <code>m</code> 分别为矩阵的行数和列数。主要为广度优先搜索的队列的开销。</p></li></ul></body></html></div></div><div class="article-footer"><div class="article-meta pull-left"><span class="post-categories"><i class="icon-categories"></i> <a href="/categories/LeetCode/">LeetCode</a>, <a href="/categories/LeetCode/算法/">算法</a>, <a href="/categories/LeetCode/算法/java/">java</a> </span><span class="post-tags"><i class="icon-tags"></i> <a href="/tags/矩阵/">矩阵</a><a href="/tags/深度遍历/">深度遍历</a><a href="/tags/广度遍历/">广度遍历</a></span></div></div></article></div></main><footer class="site-footer"><p class="mp"><img alt="关注我" src="/mp.png" style="border-radius:10px" no-lazy></p><p class="site-info">湘ICP备2020021380号-1<br>&copy; 2014 - 2023 SIWEN.PENG</p></footer><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script"),c=(e.src="//hm.baidu.com/hm.js?83fbb968d837cac86cb15c97ddd8cdd4",document.getElementsByTagName("script")[0]);c.parentNode.insertBefore(e,c)}()</script></div></div><style>[bg-lazy]{background-image:none!important;background-color:#eee!important}</style><script>window.imageLazyLoadSetting={isSPA:!1,preloadRatio:1,processImages:null}</script><script>window.addEventListener("load",function(){var a=/\.(gif|jpg|jpeg|tiff|png)$/i,e=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(t){var r=t.parentNode;"A"===r.tagName&&(r.href.match(a)||r.href.match(e))&&(r.href=t.dataset.original)})})</script><script>!function(t){function e(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function n(){i&&(r=e());for(var n,a=0;a<r.length;a++)0<=(n=(n=r[a]).getBoundingClientRect()).bottom&&0<=n.left&&n.top<=(t.innerHeight*o||document.documentElement.clientHeight*o)&&function(){var e,n,i,o=r[a],c=function(){r=r.filter(function(t){return o!==t}),t.imageLazyLoadSetting.onImageLoaded&&t.imageLazyLoadSetting.onImageLoaded(o)};(e=o).hasAttribute("bg-lazy")?(e.removeAttribute("bg-lazy"),c()):(n=new Image,i=e.getAttribute("data-original"),n.onload=function(){e.src=i,e.removeAttribute("data-original"),c()},e.src!==i&&(n.src=i))}()}function a(){clearTimeout(n.tId),n.tId=setTimeout(n,500)}t.imageLazyLoadSetting.processImages=n;var i=t.imageLazyLoadSetting.isSPA,o=t.imageLazyLoadSetting.preloadRatio||1,r=e();n(),document.addEventListener("scroll",a),t.addEventListener("resize",a),t.addEventListener("orientationchange",a)}(this)</script></body></html>