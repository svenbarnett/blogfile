<!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="utf-8"><title>JVM调优——X参数,方法内联 | 人间日常 | 所行皆过往，所愿皆成真</title><meta name="author" content="SIWEN.PENG"><meta name="description" content="jvm相关启动参数可以用来控制模式"><meta name="keywords" content="jvm调优,mixed,混合,xint,解释,comp,纯编译,方法内联,psw,彭思文,siwen,思文,sven,java,study,solution,blog"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,minimal-ui"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta property="og:title" content="JVM调优——X参数,方法内联"><meta property="og:site_name" content="人间日常"><meta property="og:image" content="logo"><link href="/avatar.jpg" rel="icon"><link rel="alternate" href="/atom.xml" title="人间日常" type="application/atom+xml"><link rel="stylesheet" href="/css/style.css" media="screen" type="text/css"><link rel="stylesheet" href="/css/custom.css" media="screen" type="text/css"><script src="//sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script><meta name="generator" content="Hexo 6.3.0"></head><body><div class="blog"><div class="content"><header><div class="site-branding"><h1 class="site-title"><a href="/">人间日常</a></h1><p class="site-description">所行皆过往，所愿皆成真</p><span class="site-description" id="jinrishici-sentence">正在加载今日诗词....</span></div><nav class="site-navigation"><ul><li><a href="/">主页</a></li><li><a href="/archives/index.html">归档</a></li><li><a href="/pics/index.html">图记</a></li></ul></nav></header><main class="site-main posts-loop"><div id="container"><article><h3 class="article-title"><span>JVM调优——X参数,方法内联</span></h3><div class="article-top-meta"><span class="posted-on"><a href="/p/638c83fa/index.html" rel="bookmark"><time class="entry-date published" datetime="2022-01-12T15:06:08.000Z">2022-01-12</time></a></span></div><div class="article-content"><div class="entry"><html><head></head><body><p>JVM 的 <code>-X</code> 参数是非标准参数，在不同版本的 JVM 中，参数可能会有所不同，可以通过 <code>java -X</code> 查看非标准参数</p><span id="more"></span><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="PLAINTEXT"><figure class="iseeu highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">&gt; java -X</span><br><span class="line"></span><br><span class="line">    -Xbatch           禁用后台编译</span><br><span class="line">    -Xbootclasspath/a:&lt;以 : 分隔的目录和 zip/jar 文件&gt;</span><br><span class="line">                      附加在引导类路径末尾</span><br><span class="line">    -Xcheck:jni       对 JNI 函数执行其他检查</span><br><span class="line">    -Xcomp            强制在首次调用时编译方法</span><br><span class="line">    -Xdebug           不执行任何操作。为实现向后兼容而提供。</span><br><span class="line">    -Xdiag            显示附加诊断消息</span><br><span class="line">    -Xfuture          启用最严格的检查，预期将来的默认值。</span><br><span class="line">                      此选项已过时，可能会在</span><br><span class="line">                      未来发行版中删除。</span><br><span class="line">    -Xint             仅解释模式执行</span><br><span class="line">    -Xinternalversion</span><br><span class="line">                      显示比 -version 选项更详细的</span><br><span class="line">                      JVM 版本信息</span><br><span class="line">    -Xlog:&lt;opts&gt;      配置或启用采用 Java 虚拟</span><br><span class="line">                      机 (Java Virtual Machine, JVM) 统一记录框架进行事件记录。使用 -Xlog:help</span><br><span class="line">                      可了解详细信息。</span><br><span class="line">    -Xloggc:&lt;file&gt;    将 GC 状态记录在文件中（带时间戳）。</span><br><span class="line">                      此选项已过时，可能会在</span><br><span class="line">                      将来的发行版中删除。它将替换为 -Xlog:gc:&lt;file&gt;。</span><br><span class="line">    -Xmixed           混合模式执行（默认值）</span><br><span class="line">    -Xmn&lt;size&gt;        为年轻代（新生代）设置初始和最大堆大小</span><br><span class="line">                      （以字节为单位）</span><br><span class="line">    -Xms&lt;size&gt;        设置初始 Java 堆大小</span><br><span class="line">    -Xmx&lt;size&gt;        设置最大 Java 堆大小</span><br><span class="line">    -Xnoclassgc       禁用类垃圾收集</span><br><span class="line">    -Xrs              减少 Java/VM 对操作系统信号的使用（请参见文档）</span><br><span class="line">    -Xshare:auto      在可能的情况下使用共享类数据（默认值）</span><br><span class="line">    -Xshare:off       不尝试使用共享类数据</span><br><span class="line">    -Xshare:on        要求使用共享类数据，否则将失败。</span><br><span class="line">                      这是一个测试选项，可能导致间歇性</span><br><span class="line">                      故障。不应在生产环境中使用它。</span><br><span class="line">    -XshowSettings    显示所有设置并继续</span><br><span class="line">    -XshowSettings:all</span><br><span class="line">                      显示所有设置并继续</span><br><span class="line">    -XshowSettings:locale</span><br><span class="line">                      显示所有与区域设置相关的设置并继续</span><br><span class="line">    -XshowSettings:properties</span><br><span class="line">                      显示所有属性设置并继续</span><br><span class="line">    -XshowSettings:vm</span><br><span class="line">                      显示所有与 vm 相关的设置并继续</span><br><span class="line">    -XshowSettings:system</span><br><span class="line">                      （仅 Linux）显示主机系统或容器</span><br><span class="line">                      配置并继续</span><br><span class="line">    -Xss&lt;size&gt;        设置 Java 线程堆栈大小</span><br><span class="line">    -Xverify          设置字节码验证器的模式</span><br><span class="line">                      请注意，选项 -Xverify:none 已过时，</span><br><span class="line">                      可能会在未来发行版中删除。</span><br><span class="line">    --add-reads &lt;module&gt;=&lt;target-module&gt;(,&lt;target-module&gt;)*</span><br><span class="line">                      更新 &lt;module&gt; 以读取 &lt;target-module&gt;，而无论</span><br><span class="line">                      模块如何声明。</span><br><span class="line">                      &lt;target-module&gt; 可以是 ALL-UNNAMED，将读取所有未命名</span><br><span class="line">                      模块。</span><br><span class="line">    --add-exports &lt;module&gt;/&lt;package&gt;=&lt;target-module&gt;(,&lt;target-module&gt;)*</span><br><span class="line">                      更新 &lt;module&gt; 以将 &lt;package&gt; 导出到 &lt;target-module&gt;，</span><br><span class="line">                      而无论模块如何声明。</span><br><span class="line">                      &lt;target-module&gt; 可以是 ALL-UNNAMED，将导出到所有</span><br><span class="line">                      未命名模块。</span><br><span class="line">    --add-opens &lt;module&gt;/&lt;package&gt;=&lt;target-module&gt;(,&lt;target-module&gt;)*</span><br><span class="line">                      更新 &lt;module&gt; 以在 &lt;target-module&gt; 中打开</span><br><span class="line">                      &lt;package&gt;，而无论模块如何声明。</span><br><span class="line">    --illegal-access=&lt;value&gt;</span><br><span class="line">                      允许或拒绝通过未命名模块中的代码对命名模块中的</span><br><span class="line">                      类型成员进行访问。</span><br><span class="line">                      &lt;value&gt; 为 "deny"、"permit"、"warn" 或 "debug" 之一</span><br><span class="line">                      此选项将在未来发行版中删除。</span><br><span class="line">    --limit-modules &lt;module name&gt;[,&lt;module name&gt;...]</span><br><span class="line">                      限制可观察模块的领域</span><br><span class="line">    --patch-module &lt;module&gt;=&lt;file&gt;(:&lt;file&gt;)*</span><br><span class="line">                      使用 JAR 文件或目录中的类和资源</span><br><span class="line">                      覆盖或增强模块。</span><br><span class="line">    --source &lt;version&gt;</span><br><span class="line">                      设置源文件模式中源的版本。</span><br><span class="line"></span><br><span class="line">这些额外选项如有更改, 恕不另行通知。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">以下选项是特定于 macOS 的选项：</span><br><span class="line">    -XstartOnFirstThread</span><br><span class="line">                      在第一个 (AppKit) 线程上运行 main() 方法</span><br><span class="line">    -Xdock:name=&lt;application name&gt;</span><br><span class="line">                      覆盖停靠栏中显示的默认应用程序名称</span><br><span class="line">    -Xdock:icon=&lt;path to icon file&gt;</span><br><span class="line">                     覆盖停靠栏中显示的默认图标</span><br></pre></td></tr></tbody></table></figure></div><h2 id="-xint-xcomp与-xmixed参数"><a class="markdownIt-Anchor" href="#-xint-xcomp与-xmixed参数">#</a> -Xint、-Xcomp 与 - Xmixed 参数</h2><h3 id="-xint参数"><a class="markdownIt-Anchor" href="#-xint参数">#</a> -Xint 参数</h3><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="PLAINTEXT"><figure class="iseeu highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在解释模式（interpreted mode）下，-Xint标记会强制JVM执行所有的字节码，这当然会降低运行速度，通常低10倍或更多。</span><br></pre></td></tr></tbody></table></figure></div><p><img src="/images/loading.svg" data-original="/p/638c83fa/index.html20190729122640228.png" alt="interpreted-mode"></p><h3 id="-xcomp参数"><a class="markdownIt-Anchor" href="#-xcomp参数">#</a> -Xcomp 参数</h3><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="PLAINTEXT"><figure class="iseeu highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xcomp参数与-Xint正好相反，JVM在第一次使用时会把所有的字节码编译成本地代码，从而带来最大程度的优化。</span><br></pre></td></tr></tbody></table></figure></div><p><img src="/images/loading.svg" data-original="/p/638c83fa/index.html20190729122919297.png" alt="compiled-mode"></p><p>然而，很多应用在使用 - Xcomp 也会有一些性能损失，当然这笔 - Xint 损失的少，原因是 - Xcomp 没有让 JVM 启用 JIT 编译器的全部功能。JIT 编译器可以对是否需要编译做出判断。如果所有代码都需要进行编译的话，对于一些只执行一次的代码就没有意义了。</p><h3 id="-xmixed参数"><a class="markdownIt-Anchor" href="#-xmixed参数">#</a> -Xmixed 参数</h3><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="PLAINTEXT"><figure class="iseeu highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xmixed是混合模式，将解释模式和变异模式进行混合使用，有JVM自己决定，这是JVM的默认模式，也是推荐模式</span><br></pre></td></tr></tbody></table></figure></div><p><img src="/images/loading.svg" data-original="/p/638c83fa/index.html2019072913573773.png" alt="mixed-model"></p><h2 id="jvm方法内联优化"><a class="markdownIt-Anchor" href="#jvm方法内联优化">#</a> JVM 方法内联优化</h2><h3 id="前言"><a class="markdownIt-Anchor" href="#前言">#</a> 前言</h3><p>在日常中工作中，我们时不时会代码进行一些优化，比如用新的算法，简化计算逻辑，减少计算量等。对于 java 程序来说，除了开发者本身对代码优化之外，还有一个 "人" 也在背后默默的优化我们的代码，这个 "人" 就是 jvm。jvm 会帮我们分析出热点代码，优化代码逻辑。其中 jvm 最常做的优化之一就是：方法内联优化。</p><h3 id="方法内联"><a class="markdownIt-Anchor" href="#方法内联">#</a> 方法内联</h3><p>什么是方法内联？又可以叫做函数内联，java 中方法可等同于其它语言中的函数。关于方法内联维基百科上面解释是：</p><blockquote><p>在计算机科学中，内联函数（有时称作在线函数或编译时期展开函数）是一种编程语言结构，用来建议编译器对一些特殊函数进行内联扩展（有时称作在线扩展）；也就是说<strong>建议编译器将指定的函数体插入并取代每一处调用该函数的地方（上下文），从而节省了每次调用函数带来的额外时间开支。</strong></p></blockquote><p>简单通俗的讲就是把方法内部调用的其它方法的逻辑，嵌入到自身的方法中去，变成自身的一部分，之后不再调用该方法，从而节省调用函数带来的额外开支。</p><h3 id="函数调用开销"><a class="markdownIt-Anchor" href="#函数调用开销">#</a> 函数调用开销</h3><p>之所以出现方法内联是因为函数调用除了执行自身逻辑的开销外，还有一些不为人知的额外开销。这部分额外的开销主要来自方法栈帧的生成、参数字段的压入、栈帧的弹出、还有指令执行地址的跳转。比如有下面这样代码：</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">function_A</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>{</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">    function_B(a,b);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">function_B</span><span class="params">(<span class="type">int</span> c, <span class="type">int</span> d)</span>{</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>{</span><br><span class="line">     function_A(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>则代码的执行过程如下：</p><p><img src="/images/loading.svg" data-original="/p/638c83fa/index.html247487dfbaf1ec956441e9e5e2f85817_1440w.jpg" alt="img"></p><p>所以如果 java 中方法调用嵌套过多或者方法过多，这种额外的开销就越多。</p><p>试想一下想 get/set 这种方法调用：</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getI</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setI</span><span class="params">(<span class="type">int</span> i)</span> {</span><br><span class="line">    <span class="built_in">this</span>.i = i;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure></div><p>很可能自身执行逻辑的开销还比不上为了调用这个方法的额外开锁。如果类似的方法被频繁的调用，则真正相对执行效率就会很低，虽然这类方法的执行时间很短。这也是为什么 jvm 会在热点代码中执行方法内联的原因，这样的话就可以省去调用调用函数带来的额外开支。</p><p>这里举个内联的可能形式：</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>  <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b , <span class="type">int</span> c, <span class="type">int</span> d)</span>{</span><br><span class="line">      <span class="keyword">return</span> add(a, b) + add(c, d);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>{</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>内联之后：</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-rel="JAVA"><figure class="iseeu highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>  <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b , <span class="type">int</span> c, <span class="type">int</span> d)</span>{</span><br><span class="line">      <span class="keyword">return</span> a + b + c + d;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>这样除了本身的相加逻辑的开销，比内联前减少了二次调用函数带来的额外开销。</p><h3 id="内联条件"><a class="markdownIt-Anchor" href="#内联条件">#</a> 内联条件</h3><p>一个方法如果满足以下条件就很可能被 jvm 内联。</p><p>1、热点代码： 如果一个方法的执行频率很高就表示优化的潜在价值就越大。那代码执行多少次才能确定为热点代码？这是根据编译器的编译模式来决定的。如果是客户端编译模式则次数是 1500，服务端编译模式是 10000。次数的大小可以通过 - XX:CompileThreshold 来调整。</p><p>2、方法体不能太大：jvm 中被内联的方法会编译成机器码放在 code cache 中。如果方法体太大，则能缓存热点方法就少，反而会影响性能。</p><p>3、如果希望方法被内联，尽量用 private、static、final 修饰，这样 jvm 可以直接内联。如果是 public、protected 修饰方法 jvm 则需要进行类型判断，因为这些方法可以被子类继承和覆盖，jvm 需要判断内联究竟内联是父类还是其中某个子类的方法。</p><blockquote><p>所以了解 jvm 方法内联机制之后，会有助于我们工作中写出能让 jvm 更容易优化的代码，有助于提升程序的性能。</p></blockquote></body></html></div></div><div class="article-footer"><div class="article-meta pull-left"><span class="post-categories"><i class="icon-categories"></i> <a href="/categories/java/">java</a> </span><span class="post-tags"><i class="icon-tags"></i> <a href="/tags/jvm调优/">jvm调优</a><a href="/tags/混合模式/">混合模式</a><a href="/tags/解释模式/">解释模式</a><a href="/tags/纯编译模式/">纯编译模式</a></span></div></div></article></div></main><footer class="site-footer"><p class="mp"><img alt="关注我" src="/mp.png" style="border-radius:10px" no-lazy></p><p class="site-info">湘ICP备2020021380号-1<br>&copy; 2014 - 2023 SIWEN.PENG</p></footer><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script"),c=(e.src="//hm.baidu.com/hm.js?83fbb968d837cac86cb15c97ddd8cdd4",document.getElementsByTagName("script")[0]);c.parentNode.insertBefore(e,c)}()</script></div></div><style>[bg-lazy]{background-image:none!important;background-color:#eee!important}</style><script>window.imageLazyLoadSetting={isSPA:!1,preloadRatio:1,processImages:null}</script><script>window.addEventListener("load",function(){var a=/\.(gif|jpg|jpeg|tiff|png)$/i,e=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(t){var r=t.parentNode;"A"===r.tagName&&(r.href.match(a)||r.href.match(e))&&(r.href=t.dataset.original)})})</script><script>!function(t){function e(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function n(){i&&(r=e());for(var n,a=0;a<r.length;a++)0<=(n=(n=r[a]).getBoundingClientRect()).bottom&&0<=n.left&&n.top<=(t.innerHeight*o||document.documentElement.clientHeight*o)&&function(){var e,n,i,o=r[a],c=function(){r=r.filter(function(t){return o!==t}),t.imageLazyLoadSetting.onImageLoaded&&t.imageLazyLoadSetting.onImageLoaded(o)};(e=o).hasAttribute("bg-lazy")?(e.removeAttribute("bg-lazy"),c()):(n=new Image,i=e.getAttribute("data-original"),n.onload=function(){e.src=i,e.removeAttribute("data-original"),c()},e.src!==i&&(n.src=i))}()}function a(){clearTimeout(n.tId),n.tId=setTimeout(n,500)}t.imageLazyLoadSetting.processImages=n;var i=t.imageLazyLoadSetting.isSPA,o=t.imageLazyLoadSetting.preloadRatio||1,r=e();n(),document.addEventListener("scroll",a),t.addEventListener("resize",a),t.addEventListener("orientationchange",a)}(this)</script></body></html>