<!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="utf-8"><title>单词接龙——leetcode127 | 人间日常 | 所行皆过往，所愿皆成真</title><meta name="author" content="SIWEN.PENG"><meta name="description" content="# 题目描述
字典 wordList 中从单词 beginWord 和 endWord 的 转换序列 是一个按下述规格形成的序列：
序列中第一个单词是 beginWord 。
序列中最后一个单词是 endWord 。
每次转换只能改变一个字母。
转换过程中的中间单词必须是字典 wordList 中的单词。
给你两个单词 beginWord 和 endWord 和一个字典 wordList ，找到从 beginWord 到 endWord 的 最短转换序列 中的
单词数目 。如果不存在这样的转换序列，返回 0 。"><meta name="keywords" content="算法,leetcode,单词接龙,psw,彭思文,siwen,思文,sven,java,study,solution,blog"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,minimal-ui"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta property="og:title" content="单词接龙——leetcode127"><meta property="og:site_name" content="人间日常"><meta property="og:image" content="leetcode127.png"><link href="/avatar.jpg" rel="icon"><link rel="alternate" href="/atom.xml" title="人间日常" type="application/atom+xml"><link rel="stylesheet" href="/css/style.css" media="screen" type="text/css"><link rel="stylesheet" href="/css/custom.css" media="screen" type="text/css"><script async custom-element="amp-auto-ads" src="//cdn.ampproject.org/v0/amp-auto-ads-0.1.js"></script><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3643487522951220" crossorigin="anonymous"></script><script type="text/javascript" src="//cpro.baidustatic.com/cpro/ui/cm.js"></script><meta name="generator" content="Hexo 6.3.0"></head><body><amp-auto-ads type="adsense" data-ad-client="ca-pub-3643487522951220"></amp-auto-ads><div class="blog"><div class="content"><header><div class="site-branding"><h1 class="site-title"><a href="/">人间日常</a></h1><p class="site-description">所行皆过往，所愿皆成真</p></div><nav class="site-navigation"><ul><li><a href="/">主页</a></li><li><a href="/archives/">归档</a></li><li><a href="/pics/">图记</a></li></ul></nav></header><main class="site-main posts-loop"><div id="container"><article><h3 class="article-title"><span>单词接龙——leetcode127</span></h3><div class="article-top-meta"><span class="posted-on"><a href="/p/fbb9fe6d/" rel="bookmark"><time class="entry-date published" datetime="2022-01-09T10:38:08.000Z">2022-01-09</time></a></span></div><div class="article-content"><div class="entry"><h1 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述">#</a> 题目描述</h1><p>字典 wordList 中从单词 beginWord 和 endWord 的 转换序列 是一个按下述规格形成的序列：<br>序列中第一个单词是 <code>beginWord</code> 。<br>序列中最后一个单词是 <code>endWord</code> 。<br>每次转换只能改变一个字母。<br>转换过程中的中间单词必须是字典  <code>wordList</code> 中的单词。<br>给你两个单词 <code>beginWord</code>  和 <code>endWord</code> 和一个字典 <code>wordList</code> ，找到从  <code>beginWord</code> 到  <code>endWord</code> 的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回 <code>0</code> 。</p><span id="more"></span><p>示例 1：</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAINTEXT"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line">输出：5</span><br><span class="line">解释：一个最短转换序列是 &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;, 返回它的长度 5。</span><br></pre></td></tr></table></figure></div><p>示例 2：</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAINTEXT"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class="line">输出：0</span><br><span class="line">解释：endWord &quot;cog&quot; 不在字典中，所以无法进行转换。</span><br></pre></td></tr></table></figure></div><p>提示：</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="PLAINTEXT"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= beginWord.length &lt;= 10</span><br><span class="line">endWord.length == beginWord.length</span><br><span class="line">1 &lt;= wordList.length &lt;= 5000</span><br><span class="line">wordList[i].length == beginWord.length</span><br><span class="line">beginWord、endWord 和 wordList[i] 由小写英文字母组成</span><br><span class="line">beginWord != endWord</span><br><span class="line">wordList 中的所有字符串 互不相同</span><br></pre></td></tr></table></figure></div><h1 id="解题"><a class="markdownIt-Anchor" href="#解题">#</a> 解题</h1><h3 id="方法一广度优先搜索-优化建图"><a class="markdownIt-Anchor" href="#方法一广度优先搜索-优化建图">#</a> 方法一：广度优先搜索 + 优化建图</h3><h4 id="思路"><a class="markdownIt-Anchor" href="#思路">#</a> 思路</h4><p>本题要求的是最短转换序列的长度，看到最短首先想到的就是广度优先搜索。想到广度优先搜索自然而然的就能想到图，但是本题并没有直截了当的给出图的模型，因此我们需要把它抽象成图的模型。</p><p>我们可以把每个单词都抽象为一个点，如果两个单词可以只改变一个字母进行转换，那么说明他们之间有一条双向边。因此我们只需要把满足转换条件的点相连，就形成了一张图。</p><p>基于该图，我们以 beginWord 为图的起点，以 endWord 为终点进行广度优先搜索，寻找 beginWord 到 endWord 的最短路径。</p><h4 id="算法"><a class="markdownIt-Anchor" href="#算法">#</a> 算法</h4><p>基于上面的思路我们考虑如何编程实现。</p><p>首先为了方便表示，我们先给每一个单词标号，即给每个单词分配一个 id。创建一个由单词 word 到 id 对应的映射 wordId，并将 beginWord 与 wordList 中所有的单词都加入这个映射中。之后我们检查 endWord 是否在该映射内，若不存在，则输入无解。我们可以使用哈希表实现上面的映射关系。</p><p>然后我们需要建图，依据朴素的思路，我们可以枚举每一对单词的组合，判断它们是否恰好相差一个字符，以判断这两个单词对应的节点是否能够相连。但是这样效率太低，我们可以优化建图。</p><p>具体地，我们可以创建虚拟节点。对于单词 hit，我们创建三个虚拟节点 <em>it、h</em>t、hi*，并让 hit 向这三个虚拟节点分别连一条边即可。如果一个单词能够转化为 hit，那么该单词必然会连接到这三个虚拟节点之一。对于每一个单词，我们枚举它连接到的虚拟节点，把该单词对应的 id 与这些虚拟节点对应的 id 相连即可。</p><p>最后我们将起点加入队列开始广度优先搜索，当搜索到终点时，我们就找到了最短路径的长度。注意因为添加了虚拟节点，所以我们得到的距离为实际最短路径长度的两倍。同时我们并未计算起点对答案的贡献，所以我们应当返回距离的一半再加一的结果。</p><h4 id="代码"><a class="markdownIt-Anchor" href="#代码">#</a> 代码</h4><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true" data-rel="JAVA"><figure class="iseeu highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Map&lt;String, Integer&gt; wordId = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Integer&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; edge = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">nodeNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (String word : wordList) &#123;</span><br><span class="line">            addEdge(word);</span><br><span class="line">        &#125;</span><br><span class="line">        addEdge(beginWord);</span><br><span class="line">        <span class="keyword">if</span> (!wordId.containsKey(endWord)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] dis = <span class="keyword">new</span> <span class="title class_">int</span>[nodeNum];</span><br><span class="line">        Arrays.fill(dis, Integer.MAX_VALUE);</span><br><span class="line">        <span class="type">int</span> <span class="variable">beginId</span> <span class="operator">=</span> wordId.get(beginWord), endId = wordId.get(endWord);</span><br><span class="line">        dis[beginId] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        Queue&lt;Integer&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        que.offer(beginId);</span><br><span class="line">        <span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> que.poll();</span><br><span class="line">            <span class="keyword">if</span> (x == endId) &#123;</span><br><span class="line">                <span class="keyword">return</span> dis[endId] / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> it : edge.get(x)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dis[it] == Integer.MAX_VALUE) &#123;</span><br><span class="line">                    dis[it] = dis[x] + <span class="number">1</span>;</span><br><span class="line">                    que.offer(it);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        addWord(word);</span><br><span class="line">        <span class="type">int</span> <span class="variable">id1</span> <span class="operator">=</span> wordId.get(word);</span><br><span class="line">        <span class="type">char</span>[] array = word.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> array.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> array[i];</span><br><span class="line">            array[i] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">newWord</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(array);</span><br><span class="line">            addWord(newWord);</span><br><span class="line">            <span class="type">int</span> <span class="variable">id2</span> <span class="operator">=</span> wordId.get(newWord);</span><br><span class="line">            edge.get(id1).add(id2);</span><br><span class="line">            edge.get(id2).add(id1);</span><br><span class="line">            array[i] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addWord</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!wordId.containsKey(word)) &#123;</span><br><span class="line">            wordId.put(word, nodeNum++);</span><br><span class="line">            edge.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="复杂度分析"><a class="markdownIt-Anchor" href="#复杂度分析">#</a> 复杂度分析</h4><ul><li>时间复杂度： <code>O(N×C2)</code> 。其中 N 为 wordList 的长度， C 为列表中单词的长度。</li></ul><p>建图过程中，对于每一个单词，我们需要枚举它连接到的所有虚拟节点，时间复杂度为 <code>O(C)</code> ，将这些单词加入到哈希表中，时间复杂度为 <code>O(N×C)</code> ，因此总时间复杂度为 <code>O(N×C)</code> 。</p><p>广度优先搜索的时间复杂度最坏情况下是 O (N \times C) O (N×C)。每一个单词需要拓展出 O©O© 个虚拟节点，因此节点数 O (N \times C) O (N×C)。</p><ul><li>空间复杂度： <code>O(N×C2)</code> 。其中 N 为 wordList 的长度，C 为列表中单词的长度。哈希表中包含 <code>O(N×C)</code> 个节点，每个节点占用空间 <code>O(C)</code> ，因此总的空间复杂度为 <code>O(N×C^2)</code> 。</li></ul></div></div><div class="article-footer"><div class="article-meta pull-left"><span class="post-categories"><i class="icon-categories"></i> <a href="/categories/算法/">算法</a> </span><span class="post-tags"><i class="icon-tags"></i> <a href="/tags/leetcode/">leetcode</a><a href="/tags/算法/">算法</a><a href="/tags/单词接龙/">单词接龙</a></span></div></div></article></div><link rel="stylesheet" href="/js/readmore/readmore.css" media="screen" type="text/css"><script src="/js/readmore/readmore.js" type="text/javascript"></script><script>const btw=new BTWPlugin;btw.init({id:"container",blogId:"31136-1676194002310-704",name:"浪漫宇宙与人间日常",qrcode:"/qrcode.jpg",keyword:"人间日常"})</script></main><footer class="site-footer"><p class="mp"><img alt="关注我" src="/mp.png" style="border-radius:10px" no-lazy></p><p class="site-info">湘ICP备2020021380号-1<br>&copy; 2014 - 2023 SIWEN.PENG</p></footer><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script"),c=(e.src="//hm.baidu.com/hm.js?83fbb968d837cac86cb15c97ddd8cdd4",document.getElementsByTagName("script")[0]);c.parentNode.insertBefore(e,c)}()</script></div></div><style>[bg-lazy]{background-image:none!important;background-color:#eee!important}</style><script>window.imageLazyLoadSetting={isSPA:!1,preloadRatio:1,processImages:null}</script><script>window.addEventListener("load",function(){var a=/\.(gif|jpg|jpeg|tiff|png)$/i,e=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(t){var r=t.parentNode;"A"===r.tagName&&(r.href.match(a)||r.href.match(e))&&(r.href=t.dataset.original)})})</script><script>!function(t){function e(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function n(){i&&(r=e());for(var n,a=0;a<r.length;a++)0<=(n=(n=r[a]).getBoundingClientRect()).bottom&&0<=n.left&&n.top<=(t.innerHeight*o||document.documentElement.clientHeight*o)&&function(){var e,n,i,o=r[a],c=function(){r=r.filter(function(t){return o!==t}),t.imageLazyLoadSetting.onImageLoaded&&t.imageLazyLoadSetting.onImageLoaded(o)};(e=o).hasAttribute("bg-lazy")?(e.removeAttribute("bg-lazy"),c()):(n=new Image,i=e.getAttribute("data-original"),n.onload=function(){e.src=i,e.removeAttribute("data-original"),c()},e.src!==i&&(n.src=i))}()}function a(){clearTimeout(n.tId),n.tId=setTimeout(n,500)}t.imageLazyLoadSetting.processImages=n;var i=t.imageLazyLoadSetting.isSPA,o=t.imageLazyLoadSetting.preloadRatio||1,r=e();n(),document.addEventListener("scroll",a),t.addEventListener("resize",a),t.addEventListener("orientationchange",a)}(this)</script></body></html>