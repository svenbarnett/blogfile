<!DOCTYPE HTML><html><head><meta charset="utf-8"><title>复原IP地址——LeetCode93 | 人间日常 | 所行皆过往，所愿皆成真</title><meta name="author" content="SIWEN.PENG"><meta name="description" content="# 题目描述
有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。

例如：“0.1.2.201” 和 “192.168.1.1” 是 有效 IP 地址，但是 “0.011.255.245”、“192.168.1.312” 和
“192.168@1.1” 是 无效 IP 地址。
给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 ‘.’ 来形成。你不能重新排序或删除
s 中的任何数字。你可以按 任何 顺序返回答案。"><meta name="keywords" content="算法,leetcode,ip,地址,回溯,psw,彭思文,siwen,思文,sven,java,study,solution,blog"><meta id="viewport" name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no,minimal-ui"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta property="og:title" content="复原IP地址——LeetCode93"><meta property="og:site_name" content="人间日常"><meta property="og:image" content="leetcode.jpeg"><link href="/favicon.ico" rel="icon"><link rel="alternate" href="/atom.xml" title="人间日常" type="application/atom+xml"><link rel="stylesheet" href="/css/style.css" media="screen" type="text/css"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="blog"><div class="content"><header><div class="site-branding"><h1 class="site-title"><a href="/">人间日常</a></h1><p class="site-description">所行皆过往，所愿皆成真</p></div><nav class="site-navigation"><ul></ul></nav></header><main class="site-main posts-loop"><article><h3 class="article-title"><span>复原IP地址——LeetCode93</span></h3><div class="article-top-meta"><span class="posted-on"><a target="_blank" href="//p/ab179abd/" rel="bookmark noopener"><time class="entry-date published" datetime="2022-01-04T13:58:27.000Z">2022-01-04</time></a></span></div><div class="article-content"><div class="entry"><h1 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述">#</a> 题目描述</h1><p>有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。</p><p>例如：“0.1.2.201” 和 “192.168.1.1” 是 有效 IP 地址，但是 “0.011.255.245”、“192.168.1.312” 和 “192.168@1.1” 是 无效 IP 地址。<br>给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 ‘.’ 来形成。你不能重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。</p><span id="more"></span><h2 id="用例"><a class="markdownIt-Anchor" href="#用例">#</a> 用例</h2><p>示例 1：</p><figure class="highlight plaintext"><figcaption data-lang="plaintext"></figcaption><table><tr><td data-num="1"></td><td><pre>输入：s = "25525511135"</pre></td></tr><tr><td data-num="2"></td><td><pre>输出：["255.255.11.135","255.255.111.35"]</pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><figcaption data-lang="plaintext"></figcaption><table><tr><td data-num="1"></td><td><pre>输入：s = "0000"</pre></td></tr><tr><td data-num="2"></td><td><pre>输出：["0.0.0.0"]</pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plaintext"><figcaption data-lang="plaintext"></figcaption><table><tr><td data-num="1"></td><td><pre>输入：s = "1111"</pre></td></tr><tr><td data-num="2"></td><td><pre>输出：["1.1.1.1"]</pre></td></tr></table></figure><p>示例 4：</p><figure class="highlight plaintext"><figcaption data-lang="plaintext"></figcaption><table><tr><td data-num="1"></td><td><pre>输入：s = "010010"</pre></td></tr><tr><td data-num="2"></td><td><pre>输出：["0.10.0.10","0.100.1.0"]</pre></td></tr></table></figure><p>示例 5：</p><figure class="highlight plaintext"><figcaption data-lang="plaintext"></figcaption><table><tr><td data-num="1"></td><td><pre>输入：s = "101023"</pre></td></tr><tr><td data-num="2"></td><td><pre>输出：["1.0.10.23","1.0.102.3","10.1.0.23","10.10.2.3","101.0.2.3"]</pre></td></tr></table></figure><p>提示：</p><p>0 &lt;= s.length &lt;= 20<br>s 仅由数字组成</p><h1 id="解题"><a class="markdownIt-Anchor" href="#解题">#</a> 解题</h1><h2 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路">#</a> 解题思路</h2><p>由于我们需要找出所有可能复原出的 IP 地址，因此可以考虑使用<strong>回溯</strong>的方法，对<strong>所有可能的字符串分隔方式</strong>进行搜索，并筛选出满足要求的作为答案。</p><p>设题目中给出的字符串为 s。我们用递归函数 <code>dfs(segId,segStart)</code> 表示我们正在从 <code>s[segStart]</code> 的位置开始，搜索 IP 地址中的第 segId 段，其中 <code>segId∈&#123;0,1,2,3&#125;</code> 。由于 IP 地址的每一段必须是 <code>[0, 255]</code> 中的整数，因此我们从 segStart 开始，从小到大依次枚举当前这一段 IP 地址的结束位置 segEnd。如果满足要求，就递归地进行下一段搜索，调用递归函数 <code>dfs(segId+1,segEnd+1)</code> 。</p><p>特别地，由于 IP 地址的每一段不能有前导零，因此如果 <code>s[segStart]</code> 等于字符 0，那么 IP 地址的第 segId 段只能为 0，需要作为特殊情况进行考虑。</p><p>在搜索的过程中，如果我们已经得到了全部的 4 段 IP 地址（即 segId=4），并且遍历完了整个字符串（即 <code>segStart=∣s∣</code> ，其中 <code>|s|</code> 表示字符串 s 的长度），那么就复原出了一种满足题目要求的 IP 地址，我们将其加入答案。在其它的时刻，如果提前遍历完了整个字符串，那么我们需要结束搜索，回溯到上一步。</p><h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现">#</a> 代码实现</h2><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">SEG_COUNT</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> segments <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token constant">SEG_COUNT</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> <span class="token function">restoreIpAddresses</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        segments <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token constant">SEG_COUNT</span><span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token function">dfs</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> segId<span class="token punctuation">,</span> <span class="token keyword">int</span> segStart<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token comment">// 如果找到了 4 段 IP 地址并且遍历完了字符串，那么就是一种答案</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>segId <span class="token operator">==</span> <span class="token constant">SEG_COUNT</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>segStart <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>                <span class="token class-name">StringBuffer</span> ipAddr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token constant">SEG_COUNT</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                    ipAddr<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>segments<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">!=</span> <span class="token constant">SEG_COUNT</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>                        ipAddr<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token char">'.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>                    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>                <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>                ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>ipAddr<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>            <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre></pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token comment">// 如果还没有找到 4 段 IP 地址就已经遍历完了字符串，那么提前回溯</span></pre></td></tr><tr><td data-num="29"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>segStart <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>            <span class="token keyword">return</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="32"></td><td><pre></pre></td></tr><tr><td data-num="33"></td><td><pre>        <span class="token comment">// 由于不能有前导零，如果当前数字为 0，那么这一段 IP 地址只能为 0</span></pre></td></tr><tr><td data-num="34"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>segStart<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token char">'0'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>            segments<span class="token punctuation">[</span>segId<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>            <span class="token function">dfs</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> segId <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> segStart <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="38"></td><td><pre></pre></td></tr><tr><td data-num="39"></td><td><pre>        <span class="token comment">// 一般情况，枚举每一种可能性并递归</span></pre></td></tr><tr><td data-num="40"></td><td><pre>        <span class="token keyword">int</span> addr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="41"></td><td><pre>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> segEnd <span class="token operator">=</span> segStart<span class="token punctuation">;</span> segEnd <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>segEnd<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="42"></td><td><pre>            addr <span class="token operator">=</span> addr <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>segEnd<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token char">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="43"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span>addr <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> addr <span class="token operator">&lt;=</span> <span class="token number">0xFF</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="44"></td><td><pre>                segments<span class="token punctuation">[</span>segId<span class="token punctuation">]</span> <span class="token operator">=</span> addr<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="45"></td><td><pre>                <span class="token function">dfs</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> segId <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> segEnd <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="46"></td><td><pre>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="47"></td><td><pre>                <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="48"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="49"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="50"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="51"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h2 id="复杂度分析"><a class="markdownIt-Anchor" href="#复杂度分析">#</a> 复杂度分析</h2><p>复杂度分析</p><p>我们用 SEG_COUNT=4 表示 IP 地址的段数。</p><p>时间复杂度： <code>O(3^SEG_COUNT × ∣s∣)</code> 。由于 IP 地址的每一段的位数不会超过 3，因此在递归的每一层，我们最多只会深入到下一层的 33 种情况。由于 SEG_COUNT=4，对应着递归的最大层数。如果我们复原出了一种满足题目要求的 IP 地址，那么需要 <code>O(∣s∣)</code> 的时间将其加入答案数组中，因此总时间复杂度为 <code>O(3 ^SEG_COUNT ×∣s∣)</code> 。</p><p>空间复杂度： <code>O(SEG_COUNT)</code> ，这里只计入除了用来存储答案数组以外的额外空间复杂度。递归使用的空间与递归的最大深度 \text {SEG_COUNT} SEG_COUNT 成正比。并且在上面的代码中，我们只额外使用了长度为 <code>SEG_COUNT</code> 的数组 <code>segments</code> 存储已经搜索过的 IP 地址，因此空间复杂度为 <code>O(SEG_COUNT)</code> 。</p></div></div><div class="article-footer"><div class="article-meta pull-left"><span class="post-categories"><i class="icon-categories"></i> <a href="/categories/java/">java</a> </span><span class="post-tags"><i class="icon-tags"></i> <a href="/tags/leetcode/">leetcode</a><a href="/tags/算法/">算法</a><a href="/tags/回溯/">回溯</a></span></div></div></article></main><footer class="site-footer"><p class="site-info"><br>&copy; 2023 SIWEN.PENG</p></footer></div></div></body></html>